import{g as Ti,a as wn}from"./index-DT8M_cqv.js";var Gn={},Br={},us;function Ua(){if(us)return Br;us=1,Br.byteLength=u,Br.toByteArray=b,Br.fromByteArray=A;for(var n=[],t=[],e=typeof Uint8Array<"u"?Uint8Array:Array,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,i=r.length;s<i;++s)n[s]=r[s],t[r.charCodeAt(s)]=s;t[45]=62,t[95]=63;function o(S){var M=S.length;if(M%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var R=S.indexOf("=");R===-1&&(R=M);var L=R===M?0:4-R%4;return[R,L]}function u(S){var M=o(S),R=M[0],L=M[1];return(R+L)*3/4-L}function d(S,M,R){return(M+R)*3/4-R}function b(S){var M,R=o(S),L=R[0],F=R[1],H=new e(d(S,L,F)),K=0,X=F>0?L-4:L,Y;for(Y=0;Y<X;Y+=4)M=t[S.charCodeAt(Y)]<<18|t[S.charCodeAt(Y+1)]<<12|t[S.charCodeAt(Y+2)]<<6|t[S.charCodeAt(Y+3)],H[K++]=M>>16&255,H[K++]=M>>8&255,H[K++]=M&255;return F===2&&(M=t[S.charCodeAt(Y)]<<2|t[S.charCodeAt(Y+1)]>>4,H[K++]=M&255),F===1&&(M=t[S.charCodeAt(Y)]<<10|t[S.charCodeAt(Y+1)]<<4|t[S.charCodeAt(Y+2)]>>2,H[K++]=M>>8&255,H[K++]=M&255),H}function I(S){return n[S>>18&63]+n[S>>12&63]+n[S>>6&63]+n[S&63]}function B(S,M,R){for(var L,F=[],H=M;H<R;H+=3)L=(S[H]<<16&16711680)+(S[H+1]<<8&65280)+(S[H+2]&255),F.push(I(L));return F.join("")}function A(S){for(var M,R=S.length,L=R%3,F=[],H=16383,K=0,X=R-L;K<X;K+=H)F.push(B(S,K,K+H>X?X:K+H));return L===1?(M=S[R-1],F.push(n[M>>2]+n[M<<4&63]+"==")):L===2&&(M=(S[R-2]<<8)+S[R-1],F.push(n[M>>10]+n[M>>4&63]+n[M<<2&63]+"=")),F.join("")}return Br}var jr={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */var fs;function Oa(){return fs||(fs=1,jr.read=function(n,t,e,r,s){var i,o,u=s*8-r-1,d=(1<<u)-1,b=d>>1,I=-7,B=e?s-1:0,A=e?-1:1,S=n[t+B];for(B+=A,i=S&(1<<-I)-1,S>>=-I,I+=u;I>0;i=i*256+n[t+B],B+=A,I-=8);for(o=i&(1<<-I)-1,i>>=-I,I+=r;I>0;o=o*256+n[t+B],B+=A,I-=8);if(i===0)i=1-b;else{if(i===d)return o?NaN:(S?-1:1)*(1/0);o=o+Math.pow(2,r),i=i-b}return(S?-1:1)*o*Math.pow(2,i-r)},jr.write=function(n,t,e,r,s,i){var o,u,d,b=i*8-s-1,I=(1<<b)-1,B=I>>1,A=s===23?Math.pow(2,-24)-Math.pow(2,-77):0,S=r?0:i-1,M=r?1:-1,R=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(u=isNaN(t)?1:0,o=I):(o=Math.floor(Math.log(t)/Math.LN2),t*(d=Math.pow(2,-o))<1&&(o--,d*=2),o+B>=1?t+=A/d:t+=A*Math.pow(2,1-B),t*d>=2&&(o++,d/=2),o+B>=I?(u=0,o=I):o+B>=1?(u=(t*d-1)*Math.pow(2,s),o=o+B):(u=t*Math.pow(2,B-1)*Math.pow(2,s),o=0));s>=8;n[e+S]=u&255,S+=M,u/=256,s-=8);for(o=o<<s|u,b+=s;b>0;n[e+S]=o&255,S+=M,o/=256,b-=8);n[e+S-M]|=R*128}),jr}/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */var ls;function Pi(){return ls||(ls=1,(function(n){const t=Ua(),e=Oa(),r=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;n.Buffer=u,n.SlowBuffer=H,n.INSPECT_MAX_BYTES=50;const s=2147483647;n.kMaxLength=s,u.TYPED_ARRAY_SUPPORT=i(),!u.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function i(){try{const m=new Uint8Array(1),l={foo:function(){return 42}};return Object.setPrototypeOf(l,Uint8Array.prototype),Object.setPrototypeOf(m,l),m.foo()===42}catch{return!1}}Object.defineProperty(u.prototype,"parent",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.buffer}}),Object.defineProperty(u.prototype,"offset",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.byteOffset}});function o(m){if(m>s)throw new RangeError('The value "'+m+'" is invalid for option "size"');const l=new Uint8Array(m);return Object.setPrototypeOf(l,u.prototype),l}function u(m,l,p){if(typeof m=="number"){if(typeof l=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return B(m)}return d(m,l,p)}u.poolSize=8192;function d(m,l,p){if(typeof m=="string")return A(m,l);if(ArrayBuffer.isView(m))return M(m);if(m==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof m);if(xe(m,ArrayBuffer)||m&&xe(m.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(xe(m,SharedArrayBuffer)||m&&xe(m.buffer,SharedArrayBuffer)))return R(m,l,p);if(typeof m=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const x=m.valueOf&&m.valueOf();if(x!=null&&x!==m)return u.from(x,l,p);const N=L(m);if(N)return N;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof m[Symbol.toPrimitive]=="function")return u.from(m[Symbol.toPrimitive]("string"),l,p);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof m)}u.from=function(m,l,p){return d(m,l,p)},Object.setPrototypeOf(u.prototype,Uint8Array.prototype),Object.setPrototypeOf(u,Uint8Array);function b(m){if(typeof m!="number")throw new TypeError('"size" argument must be of type number');if(m<0)throw new RangeError('The value "'+m+'" is invalid for option "size"')}function I(m,l,p){return b(m),m<=0?o(m):l!==void 0?typeof p=="string"?o(m).fill(l,p):o(m).fill(l):o(m)}u.alloc=function(m,l,p){return I(m,l,p)};function B(m){return b(m),o(m<0?0:F(m)|0)}u.allocUnsafe=function(m){return B(m)},u.allocUnsafeSlow=function(m){return B(m)};function A(m,l){if((typeof l!="string"||l==="")&&(l="utf8"),!u.isEncoding(l))throw new TypeError("Unknown encoding: "+l);const p=K(m,l)|0;let x=o(p);const N=x.write(m,l);return N!==p&&(x=x.slice(0,N)),x}function S(m){const l=m.length<0?0:F(m.length)|0,p=o(l);for(let x=0;x<l;x+=1)p[x]=m[x]&255;return p}function M(m){if(xe(m,Uint8Array)){const l=new Uint8Array(m);return R(l.buffer,l.byteOffset,l.byteLength)}return S(m)}function R(m,l,p){if(l<0||m.byteLength<l)throw new RangeError('"offset" is outside of buffer bounds');if(m.byteLength<l+(p||0))throw new RangeError('"length" is outside of buffer bounds');let x;return l===void 0&&p===void 0?x=new Uint8Array(m):p===void 0?x=new Uint8Array(m,l):x=new Uint8Array(m,l,p),Object.setPrototypeOf(x,u.prototype),x}function L(m){if(u.isBuffer(m)){const l=F(m.length)|0,p=o(l);return p.length===0||m.copy(p,0,0,l),p}if(m.length!==void 0)return typeof m.length!="number"||Lt(m.length)?o(0):S(m);if(m.type==="Buffer"&&Array.isArray(m.data))return S(m.data)}function F(m){if(m>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return m|0}function H(m){return+m!=m&&(m=0),u.alloc(+m)}u.isBuffer=function(l){return l!=null&&l._isBuffer===!0&&l!==u.prototype},u.compare=function(l,p){if(xe(l,Uint8Array)&&(l=u.from(l,l.offset,l.byteLength)),xe(p,Uint8Array)&&(p=u.from(p,p.offset,p.byteLength)),!u.isBuffer(l)||!u.isBuffer(p))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(l===p)return 0;let x=l.length,N=p.length;for(let q=0,j=Math.min(x,N);q<j;++q)if(l[q]!==p[q]){x=l[q],N=p[q];break}return x<N?-1:N<x?1:0},u.isEncoding=function(l){switch(String(l).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},u.concat=function(l,p){if(!Array.isArray(l))throw new TypeError('"list" argument must be an Array of Buffers');if(l.length===0)return u.alloc(0);let x;if(p===void 0)for(p=0,x=0;x<l.length;++x)p+=l[x].length;const N=u.allocUnsafe(p);let q=0;for(x=0;x<l.length;++x){let j=l[x];if(xe(j,Uint8Array))q+j.length>N.length?(u.isBuffer(j)||(j=u.from(j)),j.copy(N,q)):Uint8Array.prototype.set.call(N,j,q);else if(u.isBuffer(j))j.copy(N,q);else throw new TypeError('"list" argument must be an Array of Buffers');q+=j.length}return N};function K(m,l){if(u.isBuffer(m))return m.length;if(ArrayBuffer.isView(m)||xe(m,ArrayBuffer))return m.byteLength;if(typeof m!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof m);const p=m.length,x=arguments.length>2&&arguments[2]===!0;if(!x&&p===0)return 0;let N=!1;for(;;)switch(l){case"ascii":case"latin1":case"binary":return p;case"utf8":case"utf-8":return Pt(m).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return p*2;case"hex":return p>>>1;case"base64":return Ct(m).length;default:if(N)return x?-1:Pt(m).length;l=(""+l).toLowerCase(),N=!0}}u.byteLength=K;function X(m,l,p){let x=!1;if((l===void 0||l<0)&&(l=0),l>this.length||((p===void 0||p>this.length)&&(p=this.length),p<=0)||(p>>>=0,l>>>=0,p<=l))return"";for(m||(m="utf8");;)switch(m){case"hex":return T(this,l,p);case"utf8":case"utf-8":return a(this,l,p);case"ascii":return v(this,l,p);case"latin1":case"binary":return E(this,l,p);case"base64":return y(this,l,p);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return C(this,l,p);default:if(x)throw new TypeError("Unknown encoding: "+m);m=(m+"").toLowerCase(),x=!0}}u.prototype._isBuffer=!0;function Y(m,l,p){const x=m[l];m[l]=m[p],m[p]=x}u.prototype.swap16=function(){const l=this.length;if(l%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let p=0;p<l;p+=2)Y(this,p,p+1);return this},u.prototype.swap32=function(){const l=this.length;if(l%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let p=0;p<l;p+=4)Y(this,p,p+3),Y(this,p+1,p+2);return this},u.prototype.swap64=function(){const l=this.length;if(l%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let p=0;p<l;p+=8)Y(this,p,p+7),Y(this,p+1,p+6),Y(this,p+2,p+5),Y(this,p+3,p+4);return this},u.prototype.toString=function(){const l=this.length;return l===0?"":arguments.length===0?a(this,0,l):X.apply(this,arguments)},u.prototype.toLocaleString=u.prototype.toString,u.prototype.equals=function(l){if(!u.isBuffer(l))throw new TypeError("Argument must be a Buffer");return this===l?!0:u.compare(this,l)===0},u.prototype.inspect=function(){let l="";const p=n.INSPECT_MAX_BYTES;return l=this.toString("hex",0,p).replace(/(.{2})/g,"$1 ").trim(),this.length>p&&(l+=" ... "),"<Buffer "+l+">"},r&&(u.prototype[r]=u.prototype.inspect),u.prototype.compare=function(l,p,x,N,q){if(xe(l,Uint8Array)&&(l=u.from(l,l.offset,l.byteLength)),!u.isBuffer(l))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof l);if(p===void 0&&(p=0),x===void 0&&(x=l?l.length:0),N===void 0&&(N=0),q===void 0&&(q=this.length),p<0||x>l.length||N<0||q>this.length)throw new RangeError("out of range index");if(N>=q&&p>=x)return 0;if(N>=q)return-1;if(p>=x)return 1;if(p>>>=0,x>>>=0,N>>>=0,q>>>=0,this===l)return 0;let j=q-N,pt=x-p;const dt=Math.min(j,pt),ht=this.slice(N,q),Mt=l.slice(p,x);for(let lt=0;lt<dt;++lt)if(ht[lt]!==Mt[lt]){j=ht[lt],pt=Mt[lt];break}return j<pt?-1:pt<j?1:0};function Q(m,l,p,x,N){if(m.length===0)return-1;if(typeof p=="string"?(x=p,p=0):p>2147483647?p=2147483647:p<-2147483648&&(p=-2147483648),p=+p,Lt(p)&&(p=N?0:m.length-1),p<0&&(p=m.length+p),p>=m.length){if(N)return-1;p=m.length-1}else if(p<0)if(N)p=0;else return-1;if(typeof l=="string"&&(l=u.from(l,x)),u.isBuffer(l))return l.length===0?-1:ct(m,l,p,x,N);if(typeof l=="number")return l=l&255,typeof Uint8Array.prototype.indexOf=="function"?N?Uint8Array.prototype.indexOf.call(m,l,p):Uint8Array.prototype.lastIndexOf.call(m,l,p):ct(m,[l],p,x,N);throw new TypeError("val must be string, number or Buffer")}function ct(m,l,p,x,N){let q=1,j=m.length,pt=l.length;if(x!==void 0&&(x=String(x).toLowerCase(),x==="ucs2"||x==="ucs-2"||x==="utf16le"||x==="utf-16le")){if(m.length<2||l.length<2)return-1;q=2,j/=2,pt/=2,p/=2}function dt(Mt,lt){return q===1?Mt[lt]:Mt.readUInt16BE(lt*q)}let ht;if(N){let Mt=-1;for(ht=p;ht<j;ht++)if(dt(m,ht)===dt(l,Mt===-1?0:ht-Mt)){if(Mt===-1&&(Mt=ht),ht-Mt+1===pt)return Mt*q}else Mt!==-1&&(ht-=ht-Mt),Mt=-1}else for(p+pt>j&&(p=j-pt),ht=p;ht>=0;ht--){let Mt=!0;for(let lt=0;lt<pt;lt++)if(dt(m,ht+lt)!==dt(l,lt)){Mt=!1;break}if(Mt)return ht}return-1}u.prototype.includes=function(l,p,x){return this.indexOf(l,p,x)!==-1},u.prototype.indexOf=function(l,p,x){return Q(this,l,p,x,!0)},u.prototype.lastIndexOf=function(l,p,x){return Q(this,l,p,x,!1)};function ot(m,l,p,x){p=Number(p)||0;const N=m.length-p;x?(x=Number(x),x>N&&(x=N)):x=N;const q=l.length;x>q/2&&(x=q/2);let j;for(j=0;j<x;++j){const pt=parseInt(l.substr(j*2,2),16);if(Lt(pt))return j;m[p+j]=pt}return j}function U(m,l,p,x){return Rt(Pt(l,m.length-p),m,p,x)}function O(m,l,p,x){return Rt(Ft(l),m,p,x)}function W(m,l,p,x){return Rt(Ct(l),m,p,x)}function V(m,l,p,x){return Rt(Hr(l,m.length-p),m,p,x)}u.prototype.write=function(l,p,x,N){if(p===void 0)N="utf8",x=this.length,p=0;else if(x===void 0&&typeof p=="string")N=p,x=this.length,p=0;else if(isFinite(p))p=p>>>0,isFinite(x)?(x=x>>>0,N===void 0&&(N="utf8")):(N=x,x=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const q=this.length-p;if((x===void 0||x>q)&&(x=q),l.length>0&&(x<0||p<0)||p>this.length)throw new RangeError("Attempt to write outside buffer bounds");N||(N="utf8");let j=!1;for(;;)switch(N){case"hex":return ot(this,l,p,x);case"utf8":case"utf-8":return U(this,l,p,x);case"ascii":case"latin1":case"binary":return O(this,l,p,x);case"base64":return W(this,l,p,x);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return V(this,l,p,x);default:if(j)throw new TypeError("Unknown encoding: "+N);N=(""+N).toLowerCase(),j=!0}},u.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function y(m,l,p){return l===0&&p===m.length?t.fromByteArray(m):t.fromByteArray(m.slice(l,p))}function a(m,l,p){p=Math.min(m.length,p);const x=[];let N=l;for(;N<p;){const q=m[N];let j=null,pt=q>239?4:q>223?3:q>191?2:1;if(N+pt<=p){let dt,ht,Mt,lt;switch(pt){case 1:q<128&&(j=q);break;case 2:dt=m[N+1],(dt&192)===128&&(lt=(q&31)<<6|dt&63,lt>127&&(j=lt));break;case 3:dt=m[N+1],ht=m[N+2],(dt&192)===128&&(ht&192)===128&&(lt=(q&15)<<12|(dt&63)<<6|ht&63,lt>2047&&(lt<55296||lt>57343)&&(j=lt));break;case 4:dt=m[N+1],ht=m[N+2],Mt=m[N+3],(dt&192)===128&&(ht&192)===128&&(Mt&192)===128&&(lt=(q&15)<<18|(dt&63)<<12|(ht&63)<<6|Mt&63,lt>65535&&lt<1114112&&(j=lt))}}j===null?(j=65533,pt=1):j>65535&&(j-=65536,x.push(j>>>10&1023|55296),j=56320|j&1023),x.push(j),N+=pt}return g(x)}const h=4096;function g(m){const l=m.length;if(l<=h)return String.fromCharCode.apply(String,m);let p="",x=0;for(;x<l;)p+=String.fromCharCode.apply(String,m.slice(x,x+=h));return p}function v(m,l,p){let x="";p=Math.min(m.length,p);for(let N=l;N<p;++N)x+=String.fromCharCode(m[N]&127);return x}function E(m,l,p){let x="";p=Math.min(m.length,p);for(let N=l;N<p;++N)x+=String.fromCharCode(m[N]);return x}function T(m,l,p){const x=m.length;(!l||l<0)&&(l=0),(!p||p<0||p>x)&&(p=x);let N="";for(let q=l;q<p;++q)N+=zt[m[q]];return N}function C(m,l,p){const x=m.slice(l,p);let N="";for(let q=0;q<x.length-1;q+=2)N+=String.fromCharCode(x[q]+x[q+1]*256);return N}u.prototype.slice=function(l,p){const x=this.length;l=~~l,p=p===void 0?x:~~p,l<0?(l+=x,l<0&&(l=0)):l>x&&(l=x),p<0?(p+=x,p<0&&(p=0)):p>x&&(p=x),p<l&&(p=l);const N=this.subarray(l,p);return Object.setPrototypeOf(N,u.prototype),N};function k(m,l,p){if(m%1!==0||m<0)throw new RangeError("offset is not uint");if(m+l>p)throw new RangeError("Trying to access beyond buffer length")}u.prototype.readUintLE=u.prototype.readUIntLE=function(l,p,x){l=l>>>0,p=p>>>0,x||k(l,p,this.length);let N=this[l],q=1,j=0;for(;++j<p&&(q*=256);)N+=this[l+j]*q;return N},u.prototype.readUintBE=u.prototype.readUIntBE=function(l,p,x){l=l>>>0,p=p>>>0,x||k(l,p,this.length);let N=this[l+--p],q=1;for(;p>0&&(q*=256);)N+=this[l+--p]*q;return N},u.prototype.readUint8=u.prototype.readUInt8=function(l,p){return l=l>>>0,p||k(l,1,this.length),this[l]},u.prototype.readUint16LE=u.prototype.readUInt16LE=function(l,p){return l=l>>>0,p||k(l,2,this.length),this[l]|this[l+1]<<8},u.prototype.readUint16BE=u.prototype.readUInt16BE=function(l,p){return l=l>>>0,p||k(l,2,this.length),this[l]<<8|this[l+1]},u.prototype.readUint32LE=u.prototype.readUInt32LE=function(l,p){return l=l>>>0,p||k(l,4,this.length),(this[l]|this[l+1]<<8|this[l+2]<<16)+this[l+3]*16777216},u.prototype.readUint32BE=u.prototype.readUInt32BE=function(l,p){return l=l>>>0,p||k(l,4,this.length),this[l]*16777216+(this[l+1]<<16|this[l+2]<<8|this[l+3])},u.prototype.readBigUInt64LE=_e(function(l){l=l>>>0,Ie(l,"offset");const p=this[l],x=this[l+7];(p===void 0||x===void 0)&&_t(l,this.length-8);const N=p+this[++l]*2**8+this[++l]*2**16+this[++l]*2**24,q=this[++l]+this[++l]*2**8+this[++l]*2**16+x*2**24;return BigInt(N)+(BigInt(q)<<BigInt(32))}),u.prototype.readBigUInt64BE=_e(function(l){l=l>>>0,Ie(l,"offset");const p=this[l],x=this[l+7];(p===void 0||x===void 0)&&_t(l,this.length-8);const N=p*2**24+this[++l]*2**16+this[++l]*2**8+this[++l],q=this[++l]*2**24+this[++l]*2**16+this[++l]*2**8+x;return(BigInt(N)<<BigInt(32))+BigInt(q)}),u.prototype.readIntLE=function(l,p,x){l=l>>>0,p=p>>>0,x||k(l,p,this.length);let N=this[l],q=1,j=0;for(;++j<p&&(q*=256);)N+=this[l+j]*q;return q*=128,N>=q&&(N-=Math.pow(2,8*p)),N},u.prototype.readIntBE=function(l,p,x){l=l>>>0,p=p>>>0,x||k(l,p,this.length);let N=p,q=1,j=this[l+--N];for(;N>0&&(q*=256);)j+=this[l+--N]*q;return q*=128,j>=q&&(j-=Math.pow(2,8*p)),j},u.prototype.readInt8=function(l,p){return l=l>>>0,p||k(l,1,this.length),this[l]&128?(255-this[l]+1)*-1:this[l]},u.prototype.readInt16LE=function(l,p){l=l>>>0,p||k(l,2,this.length);const x=this[l]|this[l+1]<<8;return x&32768?x|4294901760:x},u.prototype.readInt16BE=function(l,p){l=l>>>0,p||k(l,2,this.length);const x=this[l+1]|this[l]<<8;return x&32768?x|4294901760:x},u.prototype.readInt32LE=function(l,p){return l=l>>>0,p||k(l,4,this.length),this[l]|this[l+1]<<8|this[l+2]<<16|this[l+3]<<24},u.prototype.readInt32BE=function(l,p){return l=l>>>0,p||k(l,4,this.length),this[l]<<24|this[l+1]<<16|this[l+2]<<8|this[l+3]},u.prototype.readBigInt64LE=_e(function(l){l=l>>>0,Ie(l,"offset");const p=this[l],x=this[l+7];(p===void 0||x===void 0)&&_t(l,this.length-8);const N=this[l+4]+this[l+5]*2**8+this[l+6]*2**16+(x<<24);return(BigInt(N)<<BigInt(32))+BigInt(p+this[++l]*2**8+this[++l]*2**16+this[++l]*2**24)}),u.prototype.readBigInt64BE=_e(function(l){l=l>>>0,Ie(l,"offset");const p=this[l],x=this[l+7];(p===void 0||x===void 0)&&_t(l,this.length-8);const N=(p<<24)+this[++l]*2**16+this[++l]*2**8+this[++l];return(BigInt(N)<<BigInt(32))+BigInt(this[++l]*2**24+this[++l]*2**16+this[++l]*2**8+x)}),u.prototype.readFloatLE=function(l,p){return l=l>>>0,p||k(l,4,this.length),e.read(this,l,!0,23,4)},u.prototype.readFloatBE=function(l,p){return l=l>>>0,p||k(l,4,this.length),e.read(this,l,!1,23,4)},u.prototype.readDoubleLE=function(l,p){return l=l>>>0,p||k(l,8,this.length),e.read(this,l,!0,52,8)},u.prototype.readDoubleBE=function(l,p){return l=l>>>0,p||k(l,8,this.length),e.read(this,l,!1,52,8)};function c(m,l,p,x,N,q){if(!u.isBuffer(m))throw new TypeError('"buffer" argument must be a Buffer instance');if(l>N||l<q)throw new RangeError('"value" argument is out of bounds');if(p+x>m.length)throw new RangeError("Index out of range")}u.prototype.writeUintLE=u.prototype.writeUIntLE=function(l,p,x,N){if(l=+l,p=p>>>0,x=x>>>0,!N){const pt=Math.pow(2,8*x)-1;c(this,l,p,x,pt,0)}let q=1,j=0;for(this[p]=l&255;++j<x&&(q*=256);)this[p+j]=l/q&255;return p+x},u.prototype.writeUintBE=u.prototype.writeUIntBE=function(l,p,x,N){if(l=+l,p=p>>>0,x=x>>>0,!N){const pt=Math.pow(2,8*x)-1;c(this,l,p,x,pt,0)}let q=x-1,j=1;for(this[p+q]=l&255;--q>=0&&(j*=256);)this[p+q]=l/j&255;return p+x},u.prototype.writeUint8=u.prototype.writeUInt8=function(l,p,x){return l=+l,p=p>>>0,x||c(this,l,p,1,255,0),this[p]=l&255,p+1},u.prototype.writeUint16LE=u.prototype.writeUInt16LE=function(l,p,x){return l=+l,p=p>>>0,x||c(this,l,p,2,65535,0),this[p]=l&255,this[p+1]=l>>>8,p+2},u.prototype.writeUint16BE=u.prototype.writeUInt16BE=function(l,p,x){return l=+l,p=p>>>0,x||c(this,l,p,2,65535,0),this[p]=l>>>8,this[p+1]=l&255,p+2},u.prototype.writeUint32LE=u.prototype.writeUInt32LE=function(l,p,x){return l=+l,p=p>>>0,x||c(this,l,p,4,4294967295,0),this[p+3]=l>>>24,this[p+2]=l>>>16,this[p+1]=l>>>8,this[p]=l&255,p+4},u.prototype.writeUint32BE=u.prototype.writeUInt32BE=function(l,p,x){return l=+l,p=p>>>0,x||c(this,l,p,4,4294967295,0),this[p]=l>>>24,this[p+1]=l>>>16,this[p+2]=l>>>8,this[p+3]=l&255,p+4};function f(m,l,p,x,N){It(l,x,N,m,p,7);let q=Number(l&BigInt(4294967295));m[p++]=q,q=q>>8,m[p++]=q,q=q>>8,m[p++]=q,q=q>>8,m[p++]=q;let j=Number(l>>BigInt(32)&BigInt(4294967295));return m[p++]=j,j=j>>8,m[p++]=j,j=j>>8,m[p++]=j,j=j>>8,m[p++]=j,p}function w(m,l,p,x,N){It(l,x,N,m,p,7);let q=Number(l&BigInt(4294967295));m[p+7]=q,q=q>>8,m[p+6]=q,q=q>>8,m[p+5]=q,q=q>>8,m[p+4]=q;let j=Number(l>>BigInt(32)&BigInt(4294967295));return m[p+3]=j,j=j>>8,m[p+2]=j,j=j>>8,m[p+1]=j,j=j>>8,m[p]=j,p+8}u.prototype.writeBigUInt64LE=_e(function(l,p=0){return f(this,l,p,BigInt(0),BigInt("0xffffffffffffffff"))}),u.prototype.writeBigUInt64BE=_e(function(l,p=0){return w(this,l,p,BigInt(0),BigInt("0xffffffffffffffff"))}),u.prototype.writeIntLE=function(l,p,x,N){if(l=+l,p=p>>>0,!N){const dt=Math.pow(2,8*x-1);c(this,l,p,x,dt-1,-dt)}let q=0,j=1,pt=0;for(this[p]=l&255;++q<x&&(j*=256);)l<0&&pt===0&&this[p+q-1]!==0&&(pt=1),this[p+q]=(l/j>>0)-pt&255;return p+x},u.prototype.writeIntBE=function(l,p,x,N){if(l=+l,p=p>>>0,!N){const dt=Math.pow(2,8*x-1);c(this,l,p,x,dt-1,-dt)}let q=x-1,j=1,pt=0;for(this[p+q]=l&255;--q>=0&&(j*=256);)l<0&&pt===0&&this[p+q+1]!==0&&(pt=1),this[p+q]=(l/j>>0)-pt&255;return p+x},u.prototype.writeInt8=function(l,p,x){return l=+l,p=p>>>0,x||c(this,l,p,1,127,-128),l<0&&(l=255+l+1),this[p]=l&255,p+1},u.prototype.writeInt16LE=function(l,p,x){return l=+l,p=p>>>0,x||c(this,l,p,2,32767,-32768),this[p]=l&255,this[p+1]=l>>>8,p+2},u.prototype.writeInt16BE=function(l,p,x){return l=+l,p=p>>>0,x||c(this,l,p,2,32767,-32768),this[p]=l>>>8,this[p+1]=l&255,p+2},u.prototype.writeInt32LE=function(l,p,x){return l=+l,p=p>>>0,x||c(this,l,p,4,2147483647,-2147483648),this[p]=l&255,this[p+1]=l>>>8,this[p+2]=l>>>16,this[p+3]=l>>>24,p+4},u.prototype.writeInt32BE=function(l,p,x){return l=+l,p=p>>>0,x||c(this,l,p,4,2147483647,-2147483648),l<0&&(l=4294967295+l+1),this[p]=l>>>24,this[p+1]=l>>>16,this[p+2]=l>>>8,this[p+3]=l&255,p+4},u.prototype.writeBigInt64LE=_e(function(l,p=0){return f(this,l,p,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),u.prototype.writeBigInt64BE=_e(function(l,p=0){return w(this,l,p,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function _(m,l,p,x,N,q){if(p+x>m.length)throw new RangeError("Index out of range");if(p<0)throw new RangeError("Index out of range")}function z(m,l,p,x,N){return l=+l,p=p>>>0,N||_(m,l,p,4),e.write(m,l,p,x,23,4),p+4}u.prototype.writeFloatLE=function(l,p,x){return z(this,l,p,!0,x)},u.prototype.writeFloatBE=function(l,p,x){return z(this,l,p,!1,x)};function G(m,l,p,x,N){return l=+l,p=p>>>0,N||_(m,l,p,8),e.write(m,l,p,x,52,8),p+8}u.prototype.writeDoubleLE=function(l,p,x){return G(this,l,p,!0,x)},u.prototype.writeDoubleBE=function(l,p,x){return G(this,l,p,!1,x)},u.prototype.copy=function(l,p,x,N){if(!u.isBuffer(l))throw new TypeError("argument should be a Buffer");if(x||(x=0),!N&&N!==0&&(N=this.length),p>=l.length&&(p=l.length),p||(p=0),N>0&&N<x&&(N=x),N===x||l.length===0||this.length===0)return 0;if(p<0)throw new RangeError("targetStart out of bounds");if(x<0||x>=this.length)throw new RangeError("Index out of range");if(N<0)throw new RangeError("sourceEnd out of bounds");N>this.length&&(N=this.length),l.length-p<N-x&&(N=l.length-p+x);const q=N-x;return this===l&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(p,x,N):Uint8Array.prototype.set.call(l,this.subarray(x,N),p),q},u.prototype.fill=function(l,p,x,N){if(typeof l=="string"){if(typeof p=="string"?(N=p,p=0,x=this.length):typeof x=="string"&&(N=x,x=this.length),N!==void 0&&typeof N!="string")throw new TypeError("encoding must be a string");if(typeof N=="string"&&!u.isEncoding(N))throw new TypeError("Unknown encoding: "+N);if(l.length===1){const j=l.charCodeAt(0);(N==="utf8"&&j<128||N==="latin1")&&(l=j)}}else typeof l=="number"?l=l&255:typeof l=="boolean"&&(l=Number(l));if(p<0||this.length<p||this.length<x)throw new RangeError("Out of range index");if(x<=p)return this;p=p>>>0,x=x===void 0?this.length:x>>>0,l||(l=0);let q;if(typeof l=="number")for(q=p;q<x;++q)this[q]=l;else{const j=u.isBuffer(l)?l:u.from(l,N),pt=j.length;if(pt===0)throw new TypeError('The value "'+l+'" is invalid for argument "value"');for(q=0;q<x-p;++q)this[q+p]=j[q%pt]}return this};const rt={};function st(m,l,p){rt[m]=class extends p{constructor(){super(),Object.defineProperty(this,"message",{value:l.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${m}]`,this.stack,delete this.name}get code(){return m}set code(N){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:N,writable:!0})}toString(){return`${this.name} [${m}]: ${this.message}`}}}st("ERR_BUFFER_OUT_OF_BOUNDS",function(m){return m?`${m} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),st("ERR_INVALID_ARG_TYPE",function(m,l){return`The "${m}" argument must be of type number. Received type ${typeof l}`},TypeError),st("ERR_OUT_OF_RANGE",function(m,l,p){let x=`The value of "${m}" is out of range.`,N=p;return Number.isInteger(p)&&Math.abs(p)>2**32?N=kt(String(p)):typeof p=="bigint"&&(N=String(p),(p>BigInt(2)**BigInt(32)||p<-(BigInt(2)**BigInt(32)))&&(N=kt(N)),N+="n"),x+=` It must be ${l}. Received ${N}`,x},RangeError);function kt(m){let l="",p=m.length;const x=m[0]==="-"?1:0;for(;p>=x+4;p-=3)l=`_${m.slice(p-3,p)}${l}`;return`${m.slice(0,p)}${l}`}function vt(m,l,p){Ie(l,"offset"),(m[l]===void 0||m[l+p]===void 0)&&_t(l,m.length-(p+1))}function It(m,l,p,x,N,q){if(m>p||m<l){const j=typeof l=="bigint"?"n":"";let pt;throw l===0||l===BigInt(0)?pt=`>= 0${j} and < 2${j} ** ${(q+1)*8}${j}`:pt=`>= -(2${j} ** ${(q+1)*8-1}${j}) and < 2 ** ${(q+1)*8-1}${j}`,new rt.ERR_OUT_OF_RANGE("value",pt,m)}vt(x,N,q)}function Ie(m,l){if(typeof m!="number")throw new rt.ERR_INVALID_ARG_TYPE(l,"number",m)}function _t(m,l,p){throw Math.floor(m)!==m?(Ie(m,p),new rt.ERR_OUT_OF_RANGE("offset","an integer",m)):l<0?new rt.ERR_BUFFER_OUT_OF_BOUNDS:new rt.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${l}`,m)}const Nt=/[^+/0-9A-Za-z-_]/g;function Vr(m){if(m=m.split("=")[0],m=m.trim().replace(Nt,""),m.length<2)return"";for(;m.length%4!==0;)m=m+"=";return m}function Pt(m,l){l=l||1/0;let p;const x=m.length;let N=null;const q=[];for(let j=0;j<x;++j){if(p=m.charCodeAt(j),p>55295&&p<57344){if(!N){if(p>56319){(l-=3)>-1&&q.push(239,191,189);continue}else if(j+1===x){(l-=3)>-1&&q.push(239,191,189);continue}N=p;continue}if(p<56320){(l-=3)>-1&&q.push(239,191,189),N=p;continue}p=(N-55296<<10|p-56320)+65536}else N&&(l-=3)>-1&&q.push(239,191,189);if(N=null,p<128){if((l-=1)<0)break;q.push(p)}else if(p<2048){if((l-=2)<0)break;q.push(p>>6|192,p&63|128)}else if(p<65536){if((l-=3)<0)break;q.push(p>>12|224,p>>6&63|128,p&63|128)}else if(p<1114112){if((l-=4)<0)break;q.push(p>>18|240,p>>12&63|128,p>>6&63|128,p&63|128)}else throw new Error("Invalid code point")}return q}function Ft(m){const l=[];for(let p=0;p<m.length;++p)l.push(m.charCodeAt(p)&255);return l}function Hr(m,l){let p,x,N;const q=[];for(let j=0;j<m.length&&!((l-=2)<0);++j)p=m.charCodeAt(j),x=p>>8,N=p%256,q.push(N),q.push(x);return q}function Ct(m){return t.toByteArray(Vr(m))}function Rt(m,l,p,x){let N;for(N=0;N<x&&!(N+p>=l.length||N>=m.length);++N)l[N+p]=m[N];return N}function xe(m,l){return m instanceof l||m!=null&&m.constructor!=null&&m.constructor.name!=null&&m.constructor.name===l.name}function Lt(m){return m!==m}const zt=(function(){const m="0123456789abcdef",l=new Array(256);for(let p=0;p<16;++p){const x=p*16;for(let N=0;N<16;++N)l[x+N]=m[p]+m[N]}return l})();function _e(m){return typeof BigInt>"u"?Kt:m}function Kt(){throw new Error("BigInt not supported")}})(Gn)),Gn}var ft=Pi();const hr=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Fr(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function Cr(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function $e(n,...t){if(!Fr(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error("Uint8Array expected of length "+t+", got length="+n.length)}function ho(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Cr(n.outputLen),Cr(n.blockLen)}function br(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function po(n,t){$e(n);const e=t.outputLen;if(n.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}function Na(n){return new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4))}function Qe(...n){for(let t=0;t<n.length;t++)n[t].fill(0)}function Zn(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function Re(n,t){return n<<32-t|n>>>t}const Fa=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function za(n){return n<<24&4278190080|n<<8&16711680|n>>>8&65280|n>>>24&255}function Ka(n){for(let t=0;t<n.length;t++)n[t]=za(n[t]);return n}const hs=Fa?n=>n:Ka,go=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",qa=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function sr(n){if($e(n),go)return n.toHex();let t="";for(let e=0;e<n.length;e++)t+=qa[n[e]];return t}const Oe={_0:48,_9:57,A:65,F:70,a:97,f:102};function ds(n){if(n>=Oe._0&&n<=Oe._9)return n-Oe._0;if(n>=Oe.A&&n<=Oe.F)return n-(Oe.A-10);if(n>=Oe.a&&n<=Oe.f)return n-(Oe.a-10)}function sn(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(go)return Uint8Array.fromHex(n);const t=n.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const o=ds(n.charCodeAt(i)),u=ds(n.charCodeAt(i+1));if(o===void 0||u===void 0){const d=n[i]+n[i+1];throw new Error('hex string expected, got non-hex character "'+d+'" at index '+i)}r[s]=o*16+u}return r}function Da(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function bn(n){return typeof n=="string"&&(n=Da(n)),$e(n),n}function Me(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];$e(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const i=n[r];e.set(i,s),s+=i.length}return e}class Li{}function Ci(n){const t=r=>n().update(bn(r)).digest(),e=n();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>n(),t}function Ui(n=32){if(hr&&typeof hr.getRandomValues=="function")return hr.getRandomValues(new Uint8Array(n));if(hr&&typeof hr.randomBytes=="function")return Uint8Array.from(hr.randomBytes(n));throw new Error("crypto.getRandomValues must be defined")}function Wa(n,t,e,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,e,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(e>>s&i),u=Number(e&i),d=r?4:0,b=r?0:4;n.setUint32(t+d,o,r),n.setUint32(t+b,u,r)}function $a(n,t,e){return n&t^~n&e}function Va(n,t,e){return n&t^n&e^t&e}class yo extends Li{constructor(t,e,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(t),this.view=Zn(this.buffer)}update(t){br(this),t=bn(t),$e(t);const{view:e,buffer:r,blockLen:s}=this,i=t.length;for(let o=0;o<i;){const u=Math.min(s-this.pos,i-o);if(u===s){const d=Zn(t);for(;s<=i-o;o+=s)this.process(d,o);continue}r.set(t.subarray(o,o+u),this.pos),this.pos+=u,o+=u,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){br(this),po(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:i}=this;let{pos:o}=this;e[o++]=128,Qe(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(r,0),o=0);for(let B=o;B<s;B++)e[B]=0;Wa(r,s-8,BigInt(this.length*8),i),this.process(r,0);const u=Zn(t),d=this.outputLen;if(d%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const b=d/4,I=this.get();if(b>I.length)throw new Error("_sha2: outputLen bigger than state");for(let B=0;B<b;B++)u.setUint32(4*B,I[B],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:i,destroyed:o,pos:u}=this;return t.destroyed=o,t.finished=i,t.length=s,t.pos=u,s%e&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const Ve=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),pe=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Gr=BigInt(2**32-1),ps=BigInt(32);function Ha(n,t=!1){return t?{h:Number(n&Gr),l:Number(n>>ps&Gr)}:{h:Number(n>>ps&Gr)|0,l:Number(n&Gr)|0}}function mo(n,t=!1){const e=n.length;let r=new Uint32Array(e),s=new Uint32Array(e);for(let i=0;i<e;i++){const{h:o,l:u}=Ha(n[i],t);[r[i],s[i]]=[o,u]}return[r,s]}const gs=(n,t,e)=>n>>>e,ys=(n,t,e)=>n<<32-e|t>>>e,dr=(n,t,e)=>n>>>e|t<<32-e,pr=(n,t,e)=>n<<32-e|t>>>e,Zr=(n,t,e)=>n<<64-e|t>>>e-32,Yr=(n,t,e)=>n>>>e-32|t<<64-e,ja=(n,t,e)=>n<<e|t>>>32-e,Ga=(n,t,e)=>t<<e|n>>>32-e,Za=(n,t,e)=>t<<e-32|n>>>64-e,Ya=(n,t,e)=>n<<e-32|t>>>64-e;function Ne(n,t,e,r){const s=(t>>>0)+(r>>>0);return{h:n+e+(s/2**32|0)|0,l:s|0}}const Xa=(n,t,e)=>(n>>>0)+(t>>>0)+(e>>>0),Ja=(n,t,e,r)=>t+e+r+(n/2**32|0)|0,Qa=(n,t,e,r)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0),tc=(n,t,e,r,s)=>t+e+r+s+(n/2**32|0)|0,ec=(n,t,e,r,s)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0)+(s>>>0),rc=(n,t,e,r,s,i)=>t+e+r+s+i+(n/2**32|0)|0,nc=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),He=new Uint32Array(64);class ic extends yo{constructor(t=32){super(64,t,8,!1),this.A=Ve[0]|0,this.B=Ve[1]|0,this.C=Ve[2]|0,this.D=Ve[3]|0,this.E=Ve[4]|0,this.F=Ve[5]|0,this.G=Ve[6]|0,this.H=Ve[7]|0}get(){const{A:t,B:e,C:r,D:s,E:i,F:o,G:u,H:d}=this;return[t,e,r,s,i,o,u,d]}set(t,e,r,s,i,o,u,d){this.A=t|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=u|0,this.H=d|0}process(t,e){for(let B=0;B<16;B++,e+=4)He[B]=t.getUint32(e,!1);for(let B=16;B<64;B++){const A=He[B-15],S=He[B-2],M=Re(A,7)^Re(A,18)^A>>>3,R=Re(S,17)^Re(S,19)^S>>>10;He[B]=R+He[B-7]+M+He[B-16]|0}let{A:r,B:s,C:i,D:o,E:u,F:d,G:b,H:I}=this;for(let B=0;B<64;B++){const A=Re(u,6)^Re(u,11)^Re(u,25),S=I+A+$a(u,d,b)+nc[B]+He[B]|0,R=(Re(r,2)^Re(r,13)^Re(r,22))+Va(r,s,i)|0;I=b,b=d,d=u,u=o+S|0,o=i,i=s,s=r,r=S+R|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,u=u+this.E|0,d=d+this.F|0,b=b+this.G|0,I=I+this.H|0,this.set(r,s,i,o,u,d,b,I)}roundClean(){Qe(He)}destroy(){this.set(0,0,0,0,0,0,0,0),Qe(this.buffer)}}const wo=mo(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),sc=wo[0],oc=wo[1],je=new Uint32Array(80),Ge=new Uint32Array(80);class ac extends yo{constructor(t=64){super(128,t,16,!1),this.Ah=pe[0]|0,this.Al=pe[1]|0,this.Bh=pe[2]|0,this.Bl=pe[3]|0,this.Ch=pe[4]|0,this.Cl=pe[5]|0,this.Dh=pe[6]|0,this.Dl=pe[7]|0,this.Eh=pe[8]|0,this.El=pe[9]|0,this.Fh=pe[10]|0,this.Fl=pe[11]|0,this.Gh=pe[12]|0,this.Gl=pe[13]|0,this.Hh=pe[14]|0,this.Hl=pe[15]|0}get(){const{Ah:t,Al:e,Bh:r,Bl:s,Ch:i,Cl:o,Dh:u,Dl:d,Eh:b,El:I,Fh:B,Fl:A,Gh:S,Gl:M,Hh:R,Hl:L}=this;return[t,e,r,s,i,o,u,d,b,I,B,A,S,M,R,L]}set(t,e,r,s,i,o,u,d,b,I,B,A,S,M,R,L){this.Ah=t|0,this.Al=e|0,this.Bh=r|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=u|0,this.Dl=d|0,this.Eh=b|0,this.El=I|0,this.Fh=B|0,this.Fl=A|0,this.Gh=S|0,this.Gl=M|0,this.Hh=R|0,this.Hl=L|0}process(t,e){for(let K=0;K<16;K++,e+=4)je[K]=t.getUint32(e),Ge[K]=t.getUint32(e+=4);for(let K=16;K<80;K++){const X=je[K-15]|0,Y=Ge[K-15]|0,Q=dr(X,Y,1)^dr(X,Y,8)^gs(X,Y,7),ct=pr(X,Y,1)^pr(X,Y,8)^ys(X,Y,7),ot=je[K-2]|0,U=Ge[K-2]|0,O=dr(ot,U,19)^Zr(ot,U,61)^gs(ot,U,6),W=pr(ot,U,19)^Yr(ot,U,61)^ys(ot,U,6),V=Qa(ct,W,Ge[K-7],Ge[K-16]),y=tc(V,Q,O,je[K-7],je[K-16]);je[K]=y|0,Ge[K]=V|0}let{Ah:r,Al:s,Bh:i,Bl:o,Ch:u,Cl:d,Dh:b,Dl:I,Eh:B,El:A,Fh:S,Fl:M,Gh:R,Gl:L,Hh:F,Hl:H}=this;for(let K=0;K<80;K++){const X=dr(B,A,14)^dr(B,A,18)^Zr(B,A,41),Y=pr(B,A,14)^pr(B,A,18)^Yr(B,A,41),Q=B&S^~B&R,ct=A&M^~A&L,ot=ec(H,Y,ct,oc[K],Ge[K]),U=rc(ot,F,X,Q,sc[K],je[K]),O=ot|0,W=dr(r,s,28)^Zr(r,s,34)^Zr(r,s,39),V=pr(r,s,28)^Yr(r,s,34)^Yr(r,s,39),y=r&i^r&u^i&u,a=s&o^s&d^o&d;F=R|0,H=L|0,R=S|0,L=M|0,S=B|0,M=A|0,{h:B,l:A}=Ne(b|0,I|0,U|0,O|0),b=u|0,I=d|0,u=i|0,d=o|0,i=r|0,o=s|0;const h=Xa(O,V,a);r=Ja(h,U,W,y),s=h|0}({h:r,l:s}=Ne(this.Ah|0,this.Al|0,r|0,s|0)),{h:i,l:o}=Ne(this.Bh|0,this.Bl|0,i|0,o|0),{h:u,l:d}=Ne(this.Ch|0,this.Cl|0,u|0,d|0),{h:b,l:I}=Ne(this.Dh|0,this.Dl|0,b|0,I|0),{h:B,l:A}=Ne(this.Eh|0,this.El|0,B|0,A|0),{h:S,l:M}=Ne(this.Fh|0,this.Fl|0,S|0,M|0),{h:R,l:L}=Ne(this.Gh|0,this.Gl|0,R|0,L|0),{h:F,l:H}=Ne(this.Hh|0,this.Hl|0,F|0,H|0),this.set(r,s,i,o,u,d,b,I,B,A,S,M,R,L,F,H)}roundClean(){Qe(je,Ge)}destroy(){Qe(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const bo=Ci(()=>new ic),cc=Ci(()=>new ac);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Oi=BigInt(0),Ei=BigInt(1);function ar(n,t=""){if(typeof n!="boolean"){const e=t&&`"${t}"`;throw new Error(e+"expected boolean, got type="+typeof n)}return n}function Ae(n,t,e=""){const r=Fr(n),s=n?.length,i=t!==void 0;if(!r||i&&s!==t){const o=e&&`"${e}" `,u=i?` of length ${t}`:"",d=r?`length=${s}`:`type=${typeof n}`;throw new Error(o+"expected Uint8Array"+u+", got "+d)}return n}function Xr(n){const t=n.toString(16);return t.length&1?"0"+t:t}function ko(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?Oi:BigInt("0x"+n)}function kn(n){return ko(sr(n))}function Ur(n){return $e(n),ko(sr(Uint8Array.from(n).reverse()))}function Ni(n,t){return sn(n.toString(16).padStart(t*2,"0"))}function vo(n,t){return Ni(n,t).reverse()}function Dt(n,t,e){let r;if(typeof t=="string")try{r=sn(t)}catch(i){throw new Error(n+" must be hex string or Uint8Array, cause: "+i)}else if(Fr(t))r=Uint8Array.from(t);else throw new Error(n+" must be hex string or Uint8Array");const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(n+" of length "+e+" expected, got "+s);return r}function ms(n){return Uint8Array.from(n)}const Yn=n=>typeof n=="bigint"&&Oi<=n;function uc(n,t,e){return Yn(n)&&Yn(t)&&Yn(e)&&t<=n&&n<e}function Ii(n,t,e,r){if(!uc(t,e,r))throw new Error("expected valid "+n+": "+e+" <= n < "+r+", got "+t)}function So(n){let t;for(t=0;n>Oi;n>>=Ei,t+=1);return t}const zr=n=>(Ei<<BigInt(n))-Ei;function fc(n,t,e){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");const r=S=>new Uint8Array(S),s=S=>Uint8Array.of(S);let i=r(n),o=r(n),u=0;const d=()=>{i.fill(1),o.fill(0),u=0},b=(...S)=>e(o,i,...S),I=(S=r(0))=>{o=b(s(0),S),i=b(),S.length!==0&&(o=b(s(1),S),i=b())},B=()=>{if(u++>=1e3)throw new Error("drbg: tried 1000 values");let S=0;const M=[];for(;S<t;){i=b();const R=i.slice();M.push(R),S+=i.length}return Me(...M)};return(S,M)=>{d(),I(S);let R;for(;!(R=M(B()));)I();return d(),R}}function Kr(n,t,e={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function r(s,i,o){const u=n[s];if(o&&u===void 0)return;const d=typeof u;if(d!==i||u===null)throw new Error(`param "${s}" is invalid: expected ${i}, got ${d}`)}Object.entries(t).forEach(([s,i])=>r(s,i,!1)),Object.entries(e).forEach(([s,i])=>r(s,i,!0))}function on(n){const t=new WeakMap;return(e,...r)=>{const s=t.get(e);if(s!==void 0)return s;const i=n(e,...r);return t.set(e,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Se=BigInt(0),de=BigInt(1),er=BigInt(2),xo=BigInt(3),Eo=BigInt(4),Io=BigInt(5),lc=BigInt(7),_o=BigInt(8),hc=BigInt(9),Ao=BigInt(16);function ae(n,t){const e=n%t;return e>=Se?e:t+e}function qt(n,t,e){let r=n;for(;t-- >Se;)r*=r,r%=e;return r}function ws(n,t){if(n===Se)throw new Error("invert: expected non-zero number");if(t<=Se)throw new Error("invert: expected positive modulus, got "+t);let e=ae(n,t),r=t,s=Se,i=de;for(;e!==Se;){const u=r/e,d=r%e,b=s-i*u;r=e,e=d,s=i,i=b}if(r!==de)throw new Error("invert: does not exist");return ae(s,t)}function Fi(n,t,e){if(!n.eql(n.sqr(t),e))throw new Error("Cannot find square root")}function Bo(n,t){const e=(n.ORDER+de)/Eo,r=n.pow(t,e);return Fi(n,r,t),r}function dc(n,t){const e=(n.ORDER-Io)/_o,r=n.mul(t,er),s=n.pow(r,e),i=n.mul(t,s),o=n.mul(n.mul(i,er),s),u=n.mul(i,n.sub(o,n.ONE));return Fi(n,u,t),u}function pc(n){const t=cr(n),e=Ro(n),r=e(t,t.neg(t.ONE)),s=e(t,r),i=e(t,t.neg(r)),o=(n+lc)/Ao;return(u,d)=>{let b=u.pow(d,o),I=u.mul(b,r);const B=u.mul(b,s),A=u.mul(b,i),S=u.eql(u.sqr(I),d),M=u.eql(u.sqr(B),d);b=u.cmov(b,I,S),I=u.cmov(A,B,M);const R=u.eql(u.sqr(I),d),L=u.cmov(b,I,R);return Fi(u,L,d),L}}function Ro(n){if(n<xo)throw new Error("sqrt is not defined for small field");let t=n-de,e=0;for(;t%er===Se;)t/=er,e++;let r=er;const s=cr(n);for(;bs(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return Bo;let i=s.pow(r,t);const o=(t+de)/er;return function(d,b){if(d.is0(b))return b;if(bs(d,b)!==1)throw new Error("Cannot find square root");let I=e,B=d.mul(d.ONE,i),A=d.pow(b,t),S=d.pow(b,o);for(;!d.eql(A,d.ONE);){if(d.is0(A))return d.ZERO;let M=1,R=d.sqr(A);for(;!d.eql(R,d.ONE);)if(M++,R=d.sqr(R),M===I)throw new Error("Cannot find square root");const L=de<<BigInt(I-M-1),F=d.pow(B,L);I=M,B=d.sqr(F),A=d.mul(A,B),S=d.mul(S,F)}return S}}function gc(n){return n%Eo===xo?Bo:n%_o===Io?dc:n%Ao===hc?pc(n):Ro(n)}const yc=(n,t)=>(ae(n,t)&de)===de,mc=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function wc(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},e=mc.reduce((r,s)=>(r[s]="function",r),t);return Kr(n,e),n}function bc(n,t,e){if(e<Se)throw new Error("invalid exponent, negatives unsupported");if(e===Se)return n.ONE;if(e===de)return t;let r=n.ONE,s=t;for(;e>Se;)e&de&&(r=n.mul(r,s)),s=n.sqr(s),e>>=de;return r}function Mo(n,t,e=!1){const r=new Array(t.length).fill(e?n.ZERO:void 0),s=t.reduce((o,u,d)=>n.is0(u)?o:(r[d]=o,n.mul(o,u)),n.ONE),i=n.inv(s);return t.reduceRight((o,u,d)=>n.is0(u)?o:(r[d]=n.mul(o,r[d]),n.mul(o,u)),i),r}function bs(n,t){const e=(n.ORDER-de)/er,r=n.pow(t,e),s=n.eql(r,n.ONE),i=n.eql(r,n.ZERO),o=n.eql(r,n.neg(n.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function To(n,t){t!==void 0&&Cr(t);const e=t!==void 0?t:n.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function cr(n,t,e=!1,r={}){if(n<=Se)throw new Error("invalid field: expected ORDER > 0, got "+n);let s,i,o=!1,u;if(typeof t=="object"&&t!=null){if(r.sqrt||e)throw new Error("cannot specify opts in two arguments");const A=t;A.BITS&&(s=A.BITS),A.sqrt&&(i=A.sqrt),typeof A.isLE=="boolean"&&(e=A.isLE),typeof A.modFromBytes=="boolean"&&(o=A.modFromBytes),u=A.allowedLengths}else typeof t=="number"&&(s=t),r.sqrt&&(i=r.sqrt);const{nBitLength:d,nByteLength:b}=To(n,s);if(b>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let I;const B=Object.freeze({ORDER:n,isLE:e,BITS:d,BYTES:b,MASK:zr(d),ZERO:Se,ONE:de,allowedLengths:u,create:A=>ae(A,n),isValid:A=>{if(typeof A!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof A);return Se<=A&&A<n},is0:A=>A===Se,isValidNot0:A=>!B.is0(A)&&B.isValid(A),isOdd:A=>(A&de)===de,neg:A=>ae(-A,n),eql:(A,S)=>A===S,sqr:A=>ae(A*A,n),add:(A,S)=>ae(A+S,n),sub:(A,S)=>ae(A-S,n),mul:(A,S)=>ae(A*S,n),pow:(A,S)=>bc(B,A,S),div:(A,S)=>ae(A*ws(S,n),n),sqrN:A=>A*A,addN:(A,S)=>A+S,subN:(A,S)=>A-S,mulN:(A,S)=>A*S,inv:A=>ws(A,n),sqrt:i||(A=>(I||(I=gc(n)),I(B,A))),toBytes:A=>e?vo(A,b):Ni(A,b),fromBytes:(A,S=!0)=>{if(u){if(!u.includes(A.length)||A.length>b)throw new Error("Field.fromBytes: expected "+u+" bytes, got "+A.length);const R=new Uint8Array(b);R.set(A,e?0:R.length-A.length),A=R}if(A.length!==b)throw new Error("Field.fromBytes: expected "+b+" bytes, got "+A.length);let M=e?Ur(A):kn(A);if(o&&(M=ae(M,n)),!S&&!B.isValid(M))throw new Error("invalid field element: outside of range 0..ORDER");return M},invertBatch:A=>Mo(B,A),cmov:(A,S,M)=>M?S:A});return Object.freeze(B)}function Po(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function Lo(n){const t=Po(n);return t+Math.ceil(t/2)}function kc(n,t,e=!1){const r=n.length,s=Po(t),i=Lo(t);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=e?Ur(n):kn(n),u=ae(o,t-de)+de;return e?vo(u,s):Ni(u,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const kr=BigInt(0),rr=BigInt(1);function an(n,t){const e=t.negate();return n?e:t}function nr(n,t){const e=Mo(n.Fp,t.map(r=>r.Z));return t.map((r,s)=>n.fromAffine(r.toAffine(e[s])))}function Co(n,t){if(!Number.isSafeInteger(n)||n<=0||n>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+n)}function Xn(n,t){Co(n,t);const e=Math.ceil(t/n)+1,r=2**(n-1),s=2**n,i=zr(n),o=BigInt(n);return{windows:e,windowSize:r,mask:i,maxNumber:s,shiftBy:o}}function ks(n,t,e){const{windowSize:r,mask:s,maxNumber:i,shiftBy:o}=e;let u=Number(n&s),d=n>>o;u>r&&(u-=i,d+=rr);const b=t*r,I=b+Math.abs(u)-1,B=u===0,A=u<0,S=t%2!==0;return{nextN:d,offset:I,isZero:B,isNeg:A,isNegF:S,offsetF:b}}function vc(n,t){if(!Array.isArray(n))throw new Error("array expected");n.forEach((e,r)=>{if(!(e instanceof t))throw new Error("invalid point at index "+r)})}function Sc(n,t){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((e,r)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+r)})}const Jn=new WeakMap,Uo=new WeakMap;function Qn(n){return Uo.get(n)||1}function vs(n){if(n!==kr)throw new Error("invalid wNAF")}class Oo{constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,r=this.ZERO){let s=t;for(;e>kr;)e&rr&&(r=r.add(s)),s=s.double(),e>>=rr;return r}precomputeWindow(t,e){const{windows:r,windowSize:s}=Xn(e,this.bits),i=[];let o=t,u=o;for(let d=0;d<r;d++){u=o,i.push(u);for(let b=1;b<s;b++)u=u.add(o),i.push(u);o=u.double()}return i}wNAF(t,e,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=Xn(t,this.bits);for(let u=0;u<o.windows;u++){const{nextN:d,offset:b,isZero:I,isNeg:B,isNegF:A,offsetF:S}=ks(r,u,o);r=d,I?i=i.add(an(A,e[S])):s=s.add(an(B,e[b]))}return vs(r),{p:s,f:i}}wNAFUnsafe(t,e,r,s=this.ZERO){const i=Xn(t,this.bits);for(let o=0;o<i.windows&&r!==kr;o++){const{nextN:u,offset:d,isZero:b,isNeg:I}=ks(r,o,i);if(r=u,!b){const B=e[d];s=s.add(I?B.negate():B)}}return vs(r),s}getPrecomputes(t,e,r){let s=Jn.get(e);return s||(s=this.precomputeWindow(e,t),t!==1&&(typeof r=="function"&&(s=r(s)),Jn.set(e,s))),s}cached(t,e,r){const s=Qn(t);return this.wNAF(s,this.getPrecomputes(s,t,r),e)}unsafe(t,e,r,s){const i=Qn(t);return i===1?this._unsafeLadder(t,e,s):this.wNAFUnsafe(i,this.getPrecomputes(i,t,r),e,s)}createCache(t,e){Co(e,this.bits),Uo.set(t,e),Jn.delete(t)}hasCache(t){return Qn(t)!==1}}function xc(n,t,e,r){let s=t,i=n.ZERO,o=n.ZERO;for(;e>kr||r>kr;)e&rr&&(i=i.add(s)),r&rr&&(o=o.add(s)),s=s.double(),e>>=rr,r>>=rr;return{p1:i,p2:o}}function No(n,t,e,r){vc(e,n),Sc(r,t);const s=e.length,i=r.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const o=n.ZERO,u=So(BigInt(s));let d=1;u>12?d=u-3:u>4?d=u-2:u>0&&(d=2);const b=zr(d),I=new Array(Number(b)+1).fill(o),B=Math.floor((t.BITS-1)/d)*d;let A=o;for(let S=B;S>=0;S-=d){I.fill(o);for(let R=0;R<i;R++){const L=r[R],F=Number(L>>BigInt(S)&b);I[F]=I[F].add(e[R])}let M=o;for(let R=I.length-1,L=o;R>0;R--)L=L.add(I[R]),M=M.add(L);if(A=A.add(M),S!==0)for(let R=0;R<d;R++)A=A.double()}return A}function Ss(n,t,e){if(t){if(t.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return wc(t),t}else return cr(n,{isLE:e})}function Fo(n,t,e={},r){if(r===void 0&&(r=n==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${n} CURVE object`);for(const d of["p","n","h"]){const b=t[d];if(!(typeof b=="bigint"&&b>kr))throw new Error(`CURVE.${d} must be positive bigint`)}const s=Ss(t.p,e.Fp,r),i=Ss(t.n,e.Fn,r),u=["Gx","Gy","a",n==="weierstrass"?"b":"d"];for(const d of u)if(!s.isValid(t[d]))throw new Error(`CURVE.${d} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ze=BigInt(0),ce=BigInt(1),ti=BigInt(2),Ec=BigInt(8);function Ic(n,t,e,r){const s=n.sqr(e),i=n.sqr(r),o=n.add(n.mul(t.a,s),i),u=n.add(n.ONE,n.mul(t.d,n.mul(s,i)));return n.eql(o,u)}function _c(n,t={}){const e=Fo("edwards",n,t,t.FpFnLE),{Fp:r,Fn:s}=e;let i=e.CURVE;const{h:o}=i;Kr(t,{},{uvRatio:"function"});const u=ti<<BigInt(s.BYTES*8)-ce,d=L=>r.create(L),b=t.uvRatio||((L,F)=>{try{return{isValid:!0,value:r.sqrt(r.div(L,F))}}catch{return{isValid:!1,value:Ze}}});if(!Ic(r,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function I(L,F,H=!1){const K=H?ce:Ze;return Ii("coordinate "+L,F,K,u),F}function B(L){if(!(L instanceof M))throw new Error("ExtendedPoint expected")}const A=on((L,F)=>{const{X:H,Y:K,Z:X}=L,Y=L.is0();F==null&&(F=Y?Ec:r.inv(X));const Q=d(H*F),ct=d(K*F),ot=r.mul(X,F);if(Y)return{x:Ze,y:ce};if(ot!==ce)throw new Error("invZ was invalid");return{x:Q,y:ct}}),S=on(L=>{const{a:F,d:H}=i;if(L.is0())throw new Error("bad point: ZERO");const{X:K,Y:X,Z:Y,T:Q}=L,ct=d(K*K),ot=d(X*X),U=d(Y*Y),O=d(U*U),W=d(ct*F),V=d(U*d(W+ot)),y=d(O+d(H*d(ct*ot)));if(V!==y)throw new Error("bad point: equation left != right (1)");const a=d(K*X),h=d(Y*Q);if(a!==h)throw new Error("bad point: equation left != right (2)");return!0});class M{constructor(F,H,K,X){this.X=I("x",F),this.Y=I("y",H),this.Z=I("z",K,!0),this.T=I("t",X),Object.freeze(this)}static CURVE(){return i}static fromAffine(F){if(F instanceof M)throw new Error("extended point not allowed");const{x:H,y:K}=F||{};return I("x",H),I("y",K),new M(H,K,ce,d(H*K))}static fromBytes(F,H=!1){const K=r.BYTES,{a:X,d:Y}=i;F=ms(Ae(F,K,"point")),ar(H,"zip215");const Q=ms(F),ct=F[K-1];Q[K-1]=ct&-129;const ot=Ur(Q),U=H?u:r.ORDER;Ii("point.y",ot,Ze,U);const O=d(ot*ot),W=d(O-ce),V=d(Y*O-X);let{isValid:y,value:a}=b(W,V);if(!y)throw new Error("bad point: invalid y coordinate");const h=(a&ce)===ce,g=(ct&128)!==0;if(!H&&a===Ze&&g)throw new Error("bad point: x=0 and x_0=1");return g!==h&&(a=d(-a)),M.fromAffine({x:a,y:ot})}static fromHex(F,H=!1){return M.fromBytes(Dt("point",F),H)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(F=8,H=!0){return R.createCache(this,F),H||this.multiply(ti),this}assertValidity(){S(this)}equals(F){B(F);const{X:H,Y:K,Z:X}=this,{X:Y,Y:Q,Z:ct}=F,ot=d(H*ct),U=d(Y*X),O=d(K*ct),W=d(Q*X);return ot===U&&O===W}is0(){return this.equals(M.ZERO)}negate(){return new M(d(-this.X),this.Y,this.Z,d(-this.T))}double(){const{a:F}=i,{X:H,Y:K,Z:X}=this,Y=d(H*H),Q=d(K*K),ct=d(ti*d(X*X)),ot=d(F*Y),U=H+K,O=d(d(U*U)-Y-Q),W=ot+Q,V=W-ct,y=ot-Q,a=d(O*V),h=d(W*y),g=d(O*y),v=d(V*W);return new M(a,h,v,g)}add(F){B(F);const{a:H,d:K}=i,{X,Y,Z:Q,T:ct}=this,{X:ot,Y:U,Z:O,T:W}=F,V=d(X*ot),y=d(Y*U),a=d(ct*K*W),h=d(Q*O),g=d((X+Y)*(ot+U)-V-y),v=h-a,E=h+a,T=d(y-H*V),C=d(g*v),k=d(E*T),c=d(g*T),f=d(v*E);return new M(C,k,f,c)}subtract(F){return this.add(F.negate())}multiply(F){if(!s.isValidNot0(F))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:H,f:K}=R.cached(this,F,X=>nr(M,X));return nr(M,[H,K])[0]}multiplyUnsafe(F,H=M.ZERO){if(!s.isValid(F))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return F===Ze?M.ZERO:this.is0()||F===ce?this:R.unsafe(this,F,K=>nr(M,K),H)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return R.unsafe(this,i.n).is0()}toAffine(F){return A(this,F)}clearCofactor(){return o===ce?this:this.multiplyUnsafe(o)}toBytes(){const{x:F,y:H}=this.toAffine(),K=r.toBytes(H);return K[K.length-1]|=F&ce?128:0,K}toHex(){return sr(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(F){return nr(M,F)}static msm(F,H){return No(M,s,F,H)}_setWindowSize(F){this.precompute(F)}toRawBytes(){return this.toBytes()}}M.BASE=new M(i.Gx,i.Gy,ce,d(i.Gx*i.Gy)),M.ZERO=new M(Ze,ce,ce,Ze),M.Fp=r,M.Fn=s;const R=new Oo(M,s.BITS);return M.BASE.precompute(8),M}function Ac(n,t,e={}){if(typeof t!="function")throw new Error('"hash" function param is required');Kr(e,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=e,{BASE:s,Fp:i,Fn:o}=n,u=e.randomBytes||Ui,d=e.adjustScalarBytes||(U=>U),b=e.domain||((U,O,W)=>{if(ar(W,"phflag"),O.length||W)throw new Error("Contexts/pre-hash are not supported");return U});function I(U){return o.create(Ur(U))}function B(U){const O=K.secretKey;U=Dt("private key",U,O);const W=Dt("hashed private key",t(U),2*O),V=d(W.slice(0,O)),y=W.slice(O,2*O),a=I(V);return{head:V,prefix:y,scalar:a}}function A(U){const{head:O,prefix:W,scalar:V}=B(U),y=s.multiply(V),a=y.toBytes();return{head:O,prefix:W,scalar:V,point:y,pointBytes:a}}function S(U){return A(U).pointBytes}function M(U=Uint8Array.of(),...O){const W=Me(...O);return I(t(b(W,Dt("context",U),!!r)))}function R(U,O,W={}){U=Dt("message",U),r&&(U=r(U));const{prefix:V,scalar:y,pointBytes:a}=A(O),h=M(W.context,V,U),g=s.multiply(h).toBytes(),v=M(W.context,g,a,U),E=o.create(h+v*y);if(!o.isValid(E))throw new Error("sign failed: invalid s");const T=Me(g,o.toBytes(E));return Ae(T,K.signature,"result")}const L={zip215:!0};function F(U,O,W,V=L){const{context:y,zip215:a}=V,h=K.signature;U=Dt("signature",U,h),O=Dt("message",O),W=Dt("publicKey",W,K.publicKey),a!==void 0&&ar(a,"zip215"),r&&(O=r(O));const g=h/2,v=U.subarray(0,g),E=Ur(U.subarray(g,h));let T,C,k;try{T=n.fromBytes(W,a),C=n.fromBytes(v,a),k=s.multiplyUnsafe(E)}catch{return!1}if(!a&&T.isSmallOrder())return!1;const c=M(y,C.toBytes(),T.toBytes(),O);return C.add(T.multiplyUnsafe(c)).subtract(k).clearCofactor().is0()}const H=i.BYTES,K={secretKey:H,publicKey:H,signature:2*H,seed:H};function X(U=u(K.seed)){return Ae(U,K.seed,"seed")}function Y(U){const O=ot.randomSecretKey(U);return{secretKey:O,publicKey:S(O)}}function Q(U){return Fr(U)&&U.length===o.BYTES}function ct(U,O){try{return!!n.fromBytes(U,O)}catch{return!1}}const ot={getExtendedPublicKey:A,randomSecretKey:X,isValidSecretKey:Q,isValidPublicKey:ct,toMontgomery(U){const{y:O}=n.fromBytes(U),W=K.publicKey,V=W===32;if(!V&&W!==57)throw new Error("only defined for 25519 and 448");const y=V?i.div(ce+O,ce-O):i.div(O-ce,O+ce);return i.toBytes(y)},toMontgomerySecret(U){const O=K.secretKey;Ae(U,O);const W=t(U.subarray(0,O));return d(W).subarray(0,O)},randomPrivateKey:X,precompute(U=8,O=n.BASE){return O.precompute(U,!1)}};return Object.freeze({keygen:Y,getPublicKey:S,sign:R,verify:F,utils:ot,Point:n,lengths:K})}function Bc(n){const t={a:n.a,d:n.d,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},e=n.Fp,r=cr(t.n,n.nBitLength,!0),s={Fp:e,Fn:r,uvRatio:n.uvRatio},i={randomBytes:n.randomBytes,adjustScalarBytes:n.adjustScalarBytes,domain:n.domain,prehash:n.prehash,mapToCurve:n.mapToCurve};return{CURVE:t,curveOpts:s,hash:n.hash,eddsaOpts:i}}function Rc(n,t){const e=t.Point;return Object.assign({},t,{ExtendedPoint:e,CURVE:n,nBitLength:e.Fn.BITS,nByteLength:e.Fn.BYTES})}function Mc(n){const{CURVE:t,curveOpts:e,hash:r,eddsaOpts:s}=Bc(n),i=_c(t,e),o=Ac(i,r,s);return Rc(n,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Tc=BigInt(1),xs=BigInt(2);BigInt(3);const Pc=BigInt(5),Lc=BigInt(8),zi=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),zo={p:zi,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:Lc,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function Cc(n){const t=BigInt(10),e=BigInt(20),r=BigInt(40),s=BigInt(80),i=zi,u=n*n%i*n%i,d=qt(u,xs,i)*u%i,b=qt(d,Tc,i)*n%i,I=qt(b,Pc,i)*b%i,B=qt(I,t,i)*I%i,A=qt(B,e,i)*B%i,S=qt(A,r,i)*A%i,M=qt(S,s,i)*S%i,R=qt(M,s,i)*S%i,L=qt(R,t,i)*I%i;return{pow_p_5_8:qt(L,xs,i)*n%i,b2:u}}function Uc(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}const Es=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Oc(n,t){const e=zi,r=ae(t*t*t,e),s=ae(r*r*t,e),i=Cc(n*s).pow_p_5_8;let o=ae(n*r*i,e);const u=ae(t*o*o,e),d=o,b=ae(o*Es,e),I=u===n,B=u===ae(-n,e),A=u===ae(-n*Es,e);return I&&(o=d),(B||A)&&(o=b),yc(o,e)&&(o=ae(-o,e)),{isValid:I||B,value:o}}const Nc=cr(zo.p,{isLE:!0}),Fc={...zo,Fp:Nc,hash:cc,adjustScalarBytes:Uc,uvRatio:Oc},Ir=Mc(Fc);var rn={exports:{}};const zc={},Kc=Object.freeze(Object.defineProperty({__proto__:null,default:zc},Symbol.toStringTag,{value:"Module"})),qc=Ti(Kc);var Dc=rn.exports,Is;function Ko(){return Is||(Is=1,(function(n){(function(t,e){function r(y,a){if(!y)throw new Error(a||"Assertion failed")}function s(y,a){y.super_=a;var h=function(){};h.prototype=a.prototype,y.prototype=new h,y.prototype.constructor=y}function i(y,a,h){if(i.isBN(y))return y;this.negative=0,this.words=null,this.length=0,this.red=null,y!==null&&((a==="le"||a==="be")&&(h=a,a=10),this._init(y||0,a||10,h||"be"))}typeof t=="object"?t.exports=i:e.BN=i,i.BN=i,i.wordSize=26;var o;try{typeof window<"u"&&typeof window.Buffer<"u"?o=window.Buffer:o=qc.Buffer}catch{}i.isBN=function(a){return a instanceof i?!0:a!==null&&typeof a=="object"&&a.constructor.wordSize===i.wordSize&&Array.isArray(a.words)},i.max=function(a,h){return a.cmp(h)>0?a:h},i.min=function(a,h){return a.cmp(h)<0?a:h},i.prototype._init=function(a,h,g){if(typeof a=="number")return this._initNumber(a,h,g);if(typeof a=="object")return this._initArray(a,h,g);h==="hex"&&(h=16),r(h===(h|0)&&h>=2&&h<=36),a=a.toString().replace(/\s+/g,"");var v=0;a[0]==="-"&&(v++,this.negative=1),v<a.length&&(h===16?this._parseHex(a,v,g):(this._parseBase(a,h,v),g==="le"&&this._initArray(this.toArray(),h,g)))},i.prototype._initNumber=function(a,h,g){a<0&&(this.negative=1,a=-a),a<67108864?(this.words=[a&67108863],this.length=1):a<4503599627370496?(this.words=[a&67108863,a/67108864&67108863],this.length=2):(r(a<9007199254740992),this.words=[a&67108863,a/67108864&67108863,1],this.length=3),g==="le"&&this._initArray(this.toArray(),h,g)},i.prototype._initArray=function(a,h,g){if(r(typeof a.length=="number"),a.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(a.length/3),this.words=new Array(this.length);for(var v=0;v<this.length;v++)this.words[v]=0;var E,T,C=0;if(g==="be")for(v=a.length-1,E=0;v>=0;v-=3)T=a[v]|a[v-1]<<8|a[v-2]<<16,this.words[E]|=T<<C&67108863,this.words[E+1]=T>>>26-C&67108863,C+=24,C>=26&&(C-=26,E++);else if(g==="le")for(v=0,E=0;v<a.length;v+=3)T=a[v]|a[v+1]<<8|a[v+2]<<16,this.words[E]|=T<<C&67108863,this.words[E+1]=T>>>26-C&67108863,C+=24,C>=26&&(C-=26,E++);return this._strip()};function u(y,a){var h=y.charCodeAt(a);if(h>=48&&h<=57)return h-48;if(h>=65&&h<=70)return h-55;if(h>=97&&h<=102)return h-87;r(!1,"Invalid character in "+y)}function d(y,a,h){var g=u(y,h);return h-1>=a&&(g|=u(y,h-1)<<4),g}i.prototype._parseHex=function(a,h,g){this.length=Math.ceil((a.length-h)/6),this.words=new Array(this.length);for(var v=0;v<this.length;v++)this.words[v]=0;var E=0,T=0,C;if(g==="be")for(v=a.length-1;v>=h;v-=2)C=d(a,h,v)<<E,this.words[T]|=C&67108863,E>=18?(E-=18,T+=1,this.words[T]|=C>>>26):E+=8;else{var k=a.length-h;for(v=k%2===0?h+1:h;v<a.length;v+=2)C=d(a,h,v)<<E,this.words[T]|=C&67108863,E>=18?(E-=18,T+=1,this.words[T]|=C>>>26):E+=8}this._strip()};function b(y,a,h,g){for(var v=0,E=0,T=Math.min(y.length,h),C=a;C<T;C++){var k=y.charCodeAt(C)-48;v*=g,k>=49?E=k-49+10:k>=17?E=k-17+10:E=k,r(k>=0&&E<g,"Invalid character"),v+=E}return v}i.prototype._parseBase=function(a,h,g){this.words=[0],this.length=1;for(var v=0,E=1;E<=67108863;E*=h)v++;v--,E=E/h|0;for(var T=a.length-g,C=T%v,k=Math.min(T,T-C)+g,c=0,f=g;f<k;f+=v)c=b(a,f,f+v,h),this.imuln(E),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c);if(C!==0){var w=1;for(c=b(a,f,a.length,h),f=0;f<C;f++)w*=h;this.imuln(w),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c)}this._strip()},i.prototype.copy=function(a){a.words=new Array(this.length);for(var h=0;h<this.length;h++)a.words[h]=this.words[h];a.length=this.length,a.negative=this.negative,a.red=this.red};function I(y,a){y.words=a.words,y.length=a.length,y.negative=a.negative,y.red=a.red}if(i.prototype._move=function(a){I(a,this)},i.prototype.clone=function(){var a=new i(null);return this.copy(a),a},i.prototype._expand=function(a){for(;this.length<a;)this.words[this.length++]=0;return this},i.prototype._strip=function(){for(;this.length>1&&this.words[this.length-1]===0;)this.length--;return this._normSign()},i.prototype._normSign=function(){return this.length===1&&this.words[0]===0&&(this.negative=0),this},typeof Symbol<"u"&&typeof Symbol.for=="function")try{i.prototype[Symbol.for("nodejs.util.inspect.custom")]=B}catch{i.prototype.inspect=B}else i.prototype.inspect=B;function B(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"}var A=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],S=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],M=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];i.prototype.toString=function(a,h){a=a||10,h=h|0||1;var g;if(a===16||a==="hex"){g="";for(var v=0,E=0,T=0;T<this.length;T++){var C=this.words[T],k=((C<<v|E)&16777215).toString(16);E=C>>>24-v&16777215,v+=2,v>=26&&(v-=26,T--),E!==0||T!==this.length-1?g=A[6-k.length]+k+g:g=k+g}for(E!==0&&(g=E.toString(16)+g);g.length%h!==0;)g="0"+g;return this.negative!==0&&(g="-"+g),g}if(a===(a|0)&&a>=2&&a<=36){var c=S[a],f=M[a];g="";var w=this.clone();for(w.negative=0;!w.isZero();){var _=w.modrn(f).toString(a);w=w.idivn(f),w.isZero()?g=_+g:g=A[c-_.length]+_+g}for(this.isZero()&&(g="0"+g);g.length%h!==0;)g="0"+g;return this.negative!==0&&(g="-"+g),g}r(!1,"Base should be between 2 and 36")},i.prototype.toNumber=function(){var a=this.words[0];return this.length===2?a+=this.words[1]*67108864:this.length===3&&this.words[2]===1?a+=4503599627370496+this.words[1]*67108864:this.length>2&&r(!1,"Number can only safely store up to 53 bits"),this.negative!==0?-a:a},i.prototype.toJSON=function(){return this.toString(16,2)},o&&(i.prototype.toBuffer=function(a,h){return this.toArrayLike(o,a,h)}),i.prototype.toArray=function(a,h){return this.toArrayLike(Array,a,h)};var R=function(a,h){return a.allocUnsafe?a.allocUnsafe(h):new a(h)};i.prototype.toArrayLike=function(a,h,g){this._strip();var v=this.byteLength(),E=g||Math.max(1,v);r(v<=E,"byte array longer than desired length"),r(E>0,"Requested array length <= 0");var T=R(a,E),C=h==="le"?"LE":"BE";return this["_toArrayLike"+C](T,v),T},i.prototype._toArrayLikeLE=function(a,h){for(var g=0,v=0,E=0,T=0;E<this.length;E++){var C=this.words[E]<<T|v;a[g++]=C&255,g<a.length&&(a[g++]=C>>8&255),g<a.length&&(a[g++]=C>>16&255),T===6?(g<a.length&&(a[g++]=C>>24&255),v=0,T=0):(v=C>>>24,T+=2)}if(g<a.length)for(a[g++]=v;g<a.length;)a[g++]=0},i.prototype._toArrayLikeBE=function(a,h){for(var g=a.length-1,v=0,E=0,T=0;E<this.length;E++){var C=this.words[E]<<T|v;a[g--]=C&255,g>=0&&(a[g--]=C>>8&255),g>=0&&(a[g--]=C>>16&255),T===6?(g>=0&&(a[g--]=C>>24&255),v=0,T=0):(v=C>>>24,T+=2)}if(g>=0)for(a[g--]=v;g>=0;)a[g--]=0},Math.clz32?i.prototype._countBits=function(a){return 32-Math.clz32(a)}:i.prototype._countBits=function(a){var h=a,g=0;return h>=4096&&(g+=13,h>>>=13),h>=64&&(g+=7,h>>>=7),h>=8&&(g+=4,h>>>=4),h>=2&&(g+=2,h>>>=2),g+h},i.prototype._zeroBits=function(a){if(a===0)return 26;var h=a,g=0;return(h&8191)===0&&(g+=13,h>>>=13),(h&127)===0&&(g+=7,h>>>=7),(h&15)===0&&(g+=4,h>>>=4),(h&3)===0&&(g+=2,h>>>=2),(h&1)===0&&g++,g},i.prototype.bitLength=function(){var a=this.words[this.length-1],h=this._countBits(a);return(this.length-1)*26+h};function L(y){for(var a=new Array(y.bitLength()),h=0;h<a.length;h++){var g=h/26|0,v=h%26;a[h]=y.words[g]>>>v&1}return a}i.prototype.zeroBits=function(){if(this.isZero())return 0;for(var a=0,h=0;h<this.length;h++){var g=this._zeroBits(this.words[h]);if(a+=g,g!==26)break}return a},i.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},i.prototype.toTwos=function(a){return this.negative!==0?this.abs().inotn(a).iaddn(1):this.clone()},i.prototype.fromTwos=function(a){return this.testn(a-1)?this.notn(a).iaddn(1).ineg():this.clone()},i.prototype.isNeg=function(){return this.negative!==0},i.prototype.neg=function(){return this.clone().ineg()},i.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},i.prototype.iuor=function(a){for(;this.length<a.length;)this.words[this.length++]=0;for(var h=0;h<a.length;h++)this.words[h]=this.words[h]|a.words[h];return this._strip()},i.prototype.ior=function(a){return r((this.negative|a.negative)===0),this.iuor(a)},i.prototype.or=function(a){return this.length>a.length?this.clone().ior(a):a.clone().ior(this)},i.prototype.uor=function(a){return this.length>a.length?this.clone().iuor(a):a.clone().iuor(this)},i.prototype.iuand=function(a){var h;this.length>a.length?h=a:h=this;for(var g=0;g<h.length;g++)this.words[g]=this.words[g]&a.words[g];return this.length=h.length,this._strip()},i.prototype.iand=function(a){return r((this.negative|a.negative)===0),this.iuand(a)},i.prototype.and=function(a){return this.length>a.length?this.clone().iand(a):a.clone().iand(this)},i.prototype.uand=function(a){return this.length>a.length?this.clone().iuand(a):a.clone().iuand(this)},i.prototype.iuxor=function(a){var h,g;this.length>a.length?(h=this,g=a):(h=a,g=this);for(var v=0;v<g.length;v++)this.words[v]=h.words[v]^g.words[v];if(this!==h)for(;v<h.length;v++)this.words[v]=h.words[v];return this.length=h.length,this._strip()},i.prototype.ixor=function(a){return r((this.negative|a.negative)===0),this.iuxor(a)},i.prototype.xor=function(a){return this.length>a.length?this.clone().ixor(a):a.clone().ixor(this)},i.prototype.uxor=function(a){return this.length>a.length?this.clone().iuxor(a):a.clone().iuxor(this)},i.prototype.inotn=function(a){r(typeof a=="number"&&a>=0);var h=Math.ceil(a/26)|0,g=a%26;this._expand(h),g>0&&h--;for(var v=0;v<h;v++)this.words[v]=~this.words[v]&67108863;return g>0&&(this.words[v]=~this.words[v]&67108863>>26-g),this._strip()},i.prototype.notn=function(a){return this.clone().inotn(a)},i.prototype.setn=function(a,h){r(typeof a=="number"&&a>=0);var g=a/26|0,v=a%26;return this._expand(g+1),h?this.words[g]=this.words[g]|1<<v:this.words[g]=this.words[g]&~(1<<v),this._strip()},i.prototype.iadd=function(a){var h;if(this.negative!==0&&a.negative===0)return this.negative=0,h=this.isub(a),this.negative^=1,this._normSign();if(this.negative===0&&a.negative!==0)return a.negative=0,h=this.isub(a),a.negative=1,h._normSign();var g,v;this.length>a.length?(g=this,v=a):(g=a,v=this);for(var E=0,T=0;T<v.length;T++)h=(g.words[T]|0)+(v.words[T]|0)+E,this.words[T]=h&67108863,E=h>>>26;for(;E!==0&&T<g.length;T++)h=(g.words[T]|0)+E,this.words[T]=h&67108863,E=h>>>26;if(this.length=g.length,E!==0)this.words[this.length]=E,this.length++;else if(g!==this)for(;T<g.length;T++)this.words[T]=g.words[T];return this},i.prototype.add=function(a){var h;return a.negative!==0&&this.negative===0?(a.negative=0,h=this.sub(a),a.negative^=1,h):a.negative===0&&this.negative!==0?(this.negative=0,h=a.sub(this),this.negative=1,h):this.length>a.length?this.clone().iadd(a):a.clone().iadd(this)},i.prototype.isub=function(a){if(a.negative!==0){a.negative=0;var h=this.iadd(a);return a.negative=1,h._normSign()}else if(this.negative!==0)return this.negative=0,this.iadd(a),this.negative=1,this._normSign();var g=this.cmp(a);if(g===0)return this.negative=0,this.length=1,this.words[0]=0,this;var v,E;g>0?(v=this,E=a):(v=a,E=this);for(var T=0,C=0;C<E.length;C++)h=(v.words[C]|0)-(E.words[C]|0)+T,T=h>>26,this.words[C]=h&67108863;for(;T!==0&&C<v.length;C++)h=(v.words[C]|0)+T,T=h>>26,this.words[C]=h&67108863;if(T===0&&C<v.length&&v!==this)for(;C<v.length;C++)this.words[C]=v.words[C];return this.length=Math.max(this.length,C),v!==this&&(this.negative=1),this._strip()},i.prototype.sub=function(a){return this.clone().isub(a)};function F(y,a,h){h.negative=a.negative^y.negative;var g=y.length+a.length|0;h.length=g,g=g-1|0;var v=y.words[0]|0,E=a.words[0]|0,T=v*E,C=T&67108863,k=T/67108864|0;h.words[0]=C;for(var c=1;c<g;c++){for(var f=k>>>26,w=k&67108863,_=Math.min(c,a.length-1),z=Math.max(0,c-y.length+1);z<=_;z++){var G=c-z|0;v=y.words[G]|0,E=a.words[z]|0,T=v*E+w,f+=T/67108864|0,w=T&67108863}h.words[c]=w|0,k=f|0}return k!==0?h.words[c]=k|0:h.length--,h._strip()}var H=function(a,h,g){var v=a.words,E=h.words,T=g.words,C=0,k,c,f,w=v[0]|0,_=w&8191,z=w>>>13,G=v[1]|0,rt=G&8191,st=G>>>13,kt=v[2]|0,vt=kt&8191,It=kt>>>13,Ie=v[3]|0,_t=Ie&8191,Nt=Ie>>>13,Vr=v[4]|0,Pt=Vr&8191,Ft=Vr>>>13,Hr=v[5]|0,Ct=Hr&8191,Rt=Hr>>>13,xe=v[6]|0,Lt=xe&8191,zt=xe>>>13,_e=v[7]|0,Kt=_e&8191,m=_e>>>13,l=v[8]|0,p=l&8191,x=l>>>13,N=v[9]|0,q=N&8191,j=N>>>13,pt=E[0]|0,dt=pt&8191,ht=pt>>>13,Mt=E[1]|0,lt=Mt&8191,$t=Mt>>>13,es=E[2]|0,Vt=es&8191,Ht=es>>>13,rs=E[3]|0,jt=rs&8191,Gt=rs>>>13,ns=E[4]|0,Zt=ns&8191,Yt=ns>>>13,is=E[5]|0,Xt=is&8191,Jt=is>>>13,ss=E[6]|0,Qt=ss&8191,te=ss>>>13,os=E[7]|0,ee=os&8191,re=os>>>13,as=E[8]|0,ne=as&8191,ie=as>>>13,cs=E[9]|0,se=cs&8191,oe=cs>>>13;g.negative=a.negative^h.negative,g.length=19,k=Math.imul(_,dt),c=Math.imul(_,ht),c=c+Math.imul(z,dt)|0,f=Math.imul(z,ht);var Rn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Rn>>>26)|0,Rn&=67108863,k=Math.imul(rt,dt),c=Math.imul(rt,ht),c=c+Math.imul(st,dt)|0,f=Math.imul(st,ht),k=k+Math.imul(_,lt)|0,c=c+Math.imul(_,$t)|0,c=c+Math.imul(z,lt)|0,f=f+Math.imul(z,$t)|0;var Mn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Mn>>>26)|0,Mn&=67108863,k=Math.imul(vt,dt),c=Math.imul(vt,ht),c=c+Math.imul(It,dt)|0,f=Math.imul(It,ht),k=k+Math.imul(rt,lt)|0,c=c+Math.imul(rt,$t)|0,c=c+Math.imul(st,lt)|0,f=f+Math.imul(st,$t)|0,k=k+Math.imul(_,Vt)|0,c=c+Math.imul(_,Ht)|0,c=c+Math.imul(z,Vt)|0,f=f+Math.imul(z,Ht)|0;var Tn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Tn>>>26)|0,Tn&=67108863,k=Math.imul(_t,dt),c=Math.imul(_t,ht),c=c+Math.imul(Nt,dt)|0,f=Math.imul(Nt,ht),k=k+Math.imul(vt,lt)|0,c=c+Math.imul(vt,$t)|0,c=c+Math.imul(It,lt)|0,f=f+Math.imul(It,$t)|0,k=k+Math.imul(rt,Vt)|0,c=c+Math.imul(rt,Ht)|0,c=c+Math.imul(st,Vt)|0,f=f+Math.imul(st,Ht)|0,k=k+Math.imul(_,jt)|0,c=c+Math.imul(_,Gt)|0,c=c+Math.imul(z,jt)|0,f=f+Math.imul(z,Gt)|0;var Pn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Pn>>>26)|0,Pn&=67108863,k=Math.imul(Pt,dt),c=Math.imul(Pt,ht),c=c+Math.imul(Ft,dt)|0,f=Math.imul(Ft,ht),k=k+Math.imul(_t,lt)|0,c=c+Math.imul(_t,$t)|0,c=c+Math.imul(Nt,lt)|0,f=f+Math.imul(Nt,$t)|0,k=k+Math.imul(vt,Vt)|0,c=c+Math.imul(vt,Ht)|0,c=c+Math.imul(It,Vt)|0,f=f+Math.imul(It,Ht)|0,k=k+Math.imul(rt,jt)|0,c=c+Math.imul(rt,Gt)|0,c=c+Math.imul(st,jt)|0,f=f+Math.imul(st,Gt)|0,k=k+Math.imul(_,Zt)|0,c=c+Math.imul(_,Yt)|0,c=c+Math.imul(z,Zt)|0,f=f+Math.imul(z,Yt)|0;var Ln=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Ln>>>26)|0,Ln&=67108863,k=Math.imul(Ct,dt),c=Math.imul(Ct,ht),c=c+Math.imul(Rt,dt)|0,f=Math.imul(Rt,ht),k=k+Math.imul(Pt,lt)|0,c=c+Math.imul(Pt,$t)|0,c=c+Math.imul(Ft,lt)|0,f=f+Math.imul(Ft,$t)|0,k=k+Math.imul(_t,Vt)|0,c=c+Math.imul(_t,Ht)|0,c=c+Math.imul(Nt,Vt)|0,f=f+Math.imul(Nt,Ht)|0,k=k+Math.imul(vt,jt)|0,c=c+Math.imul(vt,Gt)|0,c=c+Math.imul(It,jt)|0,f=f+Math.imul(It,Gt)|0,k=k+Math.imul(rt,Zt)|0,c=c+Math.imul(rt,Yt)|0,c=c+Math.imul(st,Zt)|0,f=f+Math.imul(st,Yt)|0,k=k+Math.imul(_,Xt)|0,c=c+Math.imul(_,Jt)|0,c=c+Math.imul(z,Xt)|0,f=f+Math.imul(z,Jt)|0;var Cn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Cn>>>26)|0,Cn&=67108863,k=Math.imul(Lt,dt),c=Math.imul(Lt,ht),c=c+Math.imul(zt,dt)|0,f=Math.imul(zt,ht),k=k+Math.imul(Ct,lt)|0,c=c+Math.imul(Ct,$t)|0,c=c+Math.imul(Rt,lt)|0,f=f+Math.imul(Rt,$t)|0,k=k+Math.imul(Pt,Vt)|0,c=c+Math.imul(Pt,Ht)|0,c=c+Math.imul(Ft,Vt)|0,f=f+Math.imul(Ft,Ht)|0,k=k+Math.imul(_t,jt)|0,c=c+Math.imul(_t,Gt)|0,c=c+Math.imul(Nt,jt)|0,f=f+Math.imul(Nt,Gt)|0,k=k+Math.imul(vt,Zt)|0,c=c+Math.imul(vt,Yt)|0,c=c+Math.imul(It,Zt)|0,f=f+Math.imul(It,Yt)|0,k=k+Math.imul(rt,Xt)|0,c=c+Math.imul(rt,Jt)|0,c=c+Math.imul(st,Xt)|0,f=f+Math.imul(st,Jt)|0,k=k+Math.imul(_,Qt)|0,c=c+Math.imul(_,te)|0,c=c+Math.imul(z,Qt)|0,f=f+Math.imul(z,te)|0;var Un=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Un>>>26)|0,Un&=67108863,k=Math.imul(Kt,dt),c=Math.imul(Kt,ht),c=c+Math.imul(m,dt)|0,f=Math.imul(m,ht),k=k+Math.imul(Lt,lt)|0,c=c+Math.imul(Lt,$t)|0,c=c+Math.imul(zt,lt)|0,f=f+Math.imul(zt,$t)|0,k=k+Math.imul(Ct,Vt)|0,c=c+Math.imul(Ct,Ht)|0,c=c+Math.imul(Rt,Vt)|0,f=f+Math.imul(Rt,Ht)|0,k=k+Math.imul(Pt,jt)|0,c=c+Math.imul(Pt,Gt)|0,c=c+Math.imul(Ft,jt)|0,f=f+Math.imul(Ft,Gt)|0,k=k+Math.imul(_t,Zt)|0,c=c+Math.imul(_t,Yt)|0,c=c+Math.imul(Nt,Zt)|0,f=f+Math.imul(Nt,Yt)|0,k=k+Math.imul(vt,Xt)|0,c=c+Math.imul(vt,Jt)|0,c=c+Math.imul(It,Xt)|0,f=f+Math.imul(It,Jt)|0,k=k+Math.imul(rt,Qt)|0,c=c+Math.imul(rt,te)|0,c=c+Math.imul(st,Qt)|0,f=f+Math.imul(st,te)|0,k=k+Math.imul(_,ee)|0,c=c+Math.imul(_,re)|0,c=c+Math.imul(z,ee)|0,f=f+Math.imul(z,re)|0;var On=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(On>>>26)|0,On&=67108863,k=Math.imul(p,dt),c=Math.imul(p,ht),c=c+Math.imul(x,dt)|0,f=Math.imul(x,ht),k=k+Math.imul(Kt,lt)|0,c=c+Math.imul(Kt,$t)|0,c=c+Math.imul(m,lt)|0,f=f+Math.imul(m,$t)|0,k=k+Math.imul(Lt,Vt)|0,c=c+Math.imul(Lt,Ht)|0,c=c+Math.imul(zt,Vt)|0,f=f+Math.imul(zt,Ht)|0,k=k+Math.imul(Ct,jt)|0,c=c+Math.imul(Ct,Gt)|0,c=c+Math.imul(Rt,jt)|0,f=f+Math.imul(Rt,Gt)|0,k=k+Math.imul(Pt,Zt)|0,c=c+Math.imul(Pt,Yt)|0,c=c+Math.imul(Ft,Zt)|0,f=f+Math.imul(Ft,Yt)|0,k=k+Math.imul(_t,Xt)|0,c=c+Math.imul(_t,Jt)|0,c=c+Math.imul(Nt,Xt)|0,f=f+Math.imul(Nt,Jt)|0,k=k+Math.imul(vt,Qt)|0,c=c+Math.imul(vt,te)|0,c=c+Math.imul(It,Qt)|0,f=f+Math.imul(It,te)|0,k=k+Math.imul(rt,ee)|0,c=c+Math.imul(rt,re)|0,c=c+Math.imul(st,ee)|0,f=f+Math.imul(st,re)|0,k=k+Math.imul(_,ne)|0,c=c+Math.imul(_,ie)|0,c=c+Math.imul(z,ne)|0,f=f+Math.imul(z,ie)|0;var Nn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Nn>>>26)|0,Nn&=67108863,k=Math.imul(q,dt),c=Math.imul(q,ht),c=c+Math.imul(j,dt)|0,f=Math.imul(j,ht),k=k+Math.imul(p,lt)|0,c=c+Math.imul(p,$t)|0,c=c+Math.imul(x,lt)|0,f=f+Math.imul(x,$t)|0,k=k+Math.imul(Kt,Vt)|0,c=c+Math.imul(Kt,Ht)|0,c=c+Math.imul(m,Vt)|0,f=f+Math.imul(m,Ht)|0,k=k+Math.imul(Lt,jt)|0,c=c+Math.imul(Lt,Gt)|0,c=c+Math.imul(zt,jt)|0,f=f+Math.imul(zt,Gt)|0,k=k+Math.imul(Ct,Zt)|0,c=c+Math.imul(Ct,Yt)|0,c=c+Math.imul(Rt,Zt)|0,f=f+Math.imul(Rt,Yt)|0,k=k+Math.imul(Pt,Xt)|0,c=c+Math.imul(Pt,Jt)|0,c=c+Math.imul(Ft,Xt)|0,f=f+Math.imul(Ft,Jt)|0,k=k+Math.imul(_t,Qt)|0,c=c+Math.imul(_t,te)|0,c=c+Math.imul(Nt,Qt)|0,f=f+Math.imul(Nt,te)|0,k=k+Math.imul(vt,ee)|0,c=c+Math.imul(vt,re)|0,c=c+Math.imul(It,ee)|0,f=f+Math.imul(It,re)|0,k=k+Math.imul(rt,ne)|0,c=c+Math.imul(rt,ie)|0,c=c+Math.imul(st,ne)|0,f=f+Math.imul(st,ie)|0,k=k+Math.imul(_,se)|0,c=c+Math.imul(_,oe)|0,c=c+Math.imul(z,se)|0,f=f+Math.imul(z,oe)|0;var Fn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Fn>>>26)|0,Fn&=67108863,k=Math.imul(q,lt),c=Math.imul(q,$t),c=c+Math.imul(j,lt)|0,f=Math.imul(j,$t),k=k+Math.imul(p,Vt)|0,c=c+Math.imul(p,Ht)|0,c=c+Math.imul(x,Vt)|0,f=f+Math.imul(x,Ht)|0,k=k+Math.imul(Kt,jt)|0,c=c+Math.imul(Kt,Gt)|0,c=c+Math.imul(m,jt)|0,f=f+Math.imul(m,Gt)|0,k=k+Math.imul(Lt,Zt)|0,c=c+Math.imul(Lt,Yt)|0,c=c+Math.imul(zt,Zt)|0,f=f+Math.imul(zt,Yt)|0,k=k+Math.imul(Ct,Xt)|0,c=c+Math.imul(Ct,Jt)|0,c=c+Math.imul(Rt,Xt)|0,f=f+Math.imul(Rt,Jt)|0,k=k+Math.imul(Pt,Qt)|0,c=c+Math.imul(Pt,te)|0,c=c+Math.imul(Ft,Qt)|0,f=f+Math.imul(Ft,te)|0,k=k+Math.imul(_t,ee)|0,c=c+Math.imul(_t,re)|0,c=c+Math.imul(Nt,ee)|0,f=f+Math.imul(Nt,re)|0,k=k+Math.imul(vt,ne)|0,c=c+Math.imul(vt,ie)|0,c=c+Math.imul(It,ne)|0,f=f+Math.imul(It,ie)|0,k=k+Math.imul(rt,se)|0,c=c+Math.imul(rt,oe)|0,c=c+Math.imul(st,se)|0,f=f+Math.imul(st,oe)|0;var zn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(zn>>>26)|0,zn&=67108863,k=Math.imul(q,Vt),c=Math.imul(q,Ht),c=c+Math.imul(j,Vt)|0,f=Math.imul(j,Ht),k=k+Math.imul(p,jt)|0,c=c+Math.imul(p,Gt)|0,c=c+Math.imul(x,jt)|0,f=f+Math.imul(x,Gt)|0,k=k+Math.imul(Kt,Zt)|0,c=c+Math.imul(Kt,Yt)|0,c=c+Math.imul(m,Zt)|0,f=f+Math.imul(m,Yt)|0,k=k+Math.imul(Lt,Xt)|0,c=c+Math.imul(Lt,Jt)|0,c=c+Math.imul(zt,Xt)|0,f=f+Math.imul(zt,Jt)|0,k=k+Math.imul(Ct,Qt)|0,c=c+Math.imul(Ct,te)|0,c=c+Math.imul(Rt,Qt)|0,f=f+Math.imul(Rt,te)|0,k=k+Math.imul(Pt,ee)|0,c=c+Math.imul(Pt,re)|0,c=c+Math.imul(Ft,ee)|0,f=f+Math.imul(Ft,re)|0,k=k+Math.imul(_t,ne)|0,c=c+Math.imul(_t,ie)|0,c=c+Math.imul(Nt,ne)|0,f=f+Math.imul(Nt,ie)|0,k=k+Math.imul(vt,se)|0,c=c+Math.imul(vt,oe)|0,c=c+Math.imul(It,se)|0,f=f+Math.imul(It,oe)|0;var Kn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Kn>>>26)|0,Kn&=67108863,k=Math.imul(q,jt),c=Math.imul(q,Gt),c=c+Math.imul(j,jt)|0,f=Math.imul(j,Gt),k=k+Math.imul(p,Zt)|0,c=c+Math.imul(p,Yt)|0,c=c+Math.imul(x,Zt)|0,f=f+Math.imul(x,Yt)|0,k=k+Math.imul(Kt,Xt)|0,c=c+Math.imul(Kt,Jt)|0,c=c+Math.imul(m,Xt)|0,f=f+Math.imul(m,Jt)|0,k=k+Math.imul(Lt,Qt)|0,c=c+Math.imul(Lt,te)|0,c=c+Math.imul(zt,Qt)|0,f=f+Math.imul(zt,te)|0,k=k+Math.imul(Ct,ee)|0,c=c+Math.imul(Ct,re)|0,c=c+Math.imul(Rt,ee)|0,f=f+Math.imul(Rt,re)|0,k=k+Math.imul(Pt,ne)|0,c=c+Math.imul(Pt,ie)|0,c=c+Math.imul(Ft,ne)|0,f=f+Math.imul(Ft,ie)|0,k=k+Math.imul(_t,se)|0,c=c+Math.imul(_t,oe)|0,c=c+Math.imul(Nt,se)|0,f=f+Math.imul(Nt,oe)|0;var qn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(qn>>>26)|0,qn&=67108863,k=Math.imul(q,Zt),c=Math.imul(q,Yt),c=c+Math.imul(j,Zt)|0,f=Math.imul(j,Yt),k=k+Math.imul(p,Xt)|0,c=c+Math.imul(p,Jt)|0,c=c+Math.imul(x,Xt)|0,f=f+Math.imul(x,Jt)|0,k=k+Math.imul(Kt,Qt)|0,c=c+Math.imul(Kt,te)|0,c=c+Math.imul(m,Qt)|0,f=f+Math.imul(m,te)|0,k=k+Math.imul(Lt,ee)|0,c=c+Math.imul(Lt,re)|0,c=c+Math.imul(zt,ee)|0,f=f+Math.imul(zt,re)|0,k=k+Math.imul(Ct,ne)|0,c=c+Math.imul(Ct,ie)|0,c=c+Math.imul(Rt,ne)|0,f=f+Math.imul(Rt,ie)|0,k=k+Math.imul(Pt,se)|0,c=c+Math.imul(Pt,oe)|0,c=c+Math.imul(Ft,se)|0,f=f+Math.imul(Ft,oe)|0;var Dn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Dn>>>26)|0,Dn&=67108863,k=Math.imul(q,Xt),c=Math.imul(q,Jt),c=c+Math.imul(j,Xt)|0,f=Math.imul(j,Jt),k=k+Math.imul(p,Qt)|0,c=c+Math.imul(p,te)|0,c=c+Math.imul(x,Qt)|0,f=f+Math.imul(x,te)|0,k=k+Math.imul(Kt,ee)|0,c=c+Math.imul(Kt,re)|0,c=c+Math.imul(m,ee)|0,f=f+Math.imul(m,re)|0,k=k+Math.imul(Lt,ne)|0,c=c+Math.imul(Lt,ie)|0,c=c+Math.imul(zt,ne)|0,f=f+Math.imul(zt,ie)|0,k=k+Math.imul(Ct,se)|0,c=c+Math.imul(Ct,oe)|0,c=c+Math.imul(Rt,se)|0,f=f+Math.imul(Rt,oe)|0;var Wn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Wn>>>26)|0,Wn&=67108863,k=Math.imul(q,Qt),c=Math.imul(q,te),c=c+Math.imul(j,Qt)|0,f=Math.imul(j,te),k=k+Math.imul(p,ee)|0,c=c+Math.imul(p,re)|0,c=c+Math.imul(x,ee)|0,f=f+Math.imul(x,re)|0,k=k+Math.imul(Kt,ne)|0,c=c+Math.imul(Kt,ie)|0,c=c+Math.imul(m,ne)|0,f=f+Math.imul(m,ie)|0,k=k+Math.imul(Lt,se)|0,c=c+Math.imul(Lt,oe)|0,c=c+Math.imul(zt,se)|0,f=f+Math.imul(zt,oe)|0;var $n=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+($n>>>26)|0,$n&=67108863,k=Math.imul(q,ee),c=Math.imul(q,re),c=c+Math.imul(j,ee)|0,f=Math.imul(j,re),k=k+Math.imul(p,ne)|0,c=c+Math.imul(p,ie)|0,c=c+Math.imul(x,ne)|0,f=f+Math.imul(x,ie)|0,k=k+Math.imul(Kt,se)|0,c=c+Math.imul(Kt,oe)|0,c=c+Math.imul(m,se)|0,f=f+Math.imul(m,oe)|0;var Vn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Vn>>>26)|0,Vn&=67108863,k=Math.imul(q,ne),c=Math.imul(q,ie),c=c+Math.imul(j,ne)|0,f=Math.imul(j,ie),k=k+Math.imul(p,se)|0,c=c+Math.imul(p,oe)|0,c=c+Math.imul(x,se)|0,f=f+Math.imul(x,oe)|0;var Hn=(C+k|0)+((c&8191)<<13)|0;C=(f+(c>>>13)|0)+(Hn>>>26)|0,Hn&=67108863,k=Math.imul(q,se),c=Math.imul(q,oe),c=c+Math.imul(j,se)|0,f=Math.imul(j,oe);var jn=(C+k|0)+((c&8191)<<13)|0;return C=(f+(c>>>13)|0)+(jn>>>26)|0,jn&=67108863,T[0]=Rn,T[1]=Mn,T[2]=Tn,T[3]=Pn,T[4]=Ln,T[5]=Cn,T[6]=Un,T[7]=On,T[8]=Nn,T[9]=Fn,T[10]=zn,T[11]=Kn,T[12]=qn,T[13]=Dn,T[14]=Wn,T[15]=$n,T[16]=Vn,T[17]=Hn,T[18]=jn,C!==0&&(T[19]=C,g.length++),g};Math.imul||(H=F);function K(y,a,h){h.negative=a.negative^y.negative,h.length=y.length+a.length;for(var g=0,v=0,E=0;E<h.length-1;E++){var T=v;v=0;for(var C=g&67108863,k=Math.min(E,a.length-1),c=Math.max(0,E-y.length+1);c<=k;c++){var f=E-c,w=y.words[f]|0,_=a.words[c]|0,z=w*_,G=z&67108863;T=T+(z/67108864|0)|0,G=G+C|0,C=G&67108863,T=T+(G>>>26)|0,v+=T>>>26,T&=67108863}h.words[E]=C,g=T,T=v}return g!==0?h.words[E]=g:h.length--,h._strip()}function X(y,a,h){return K(y,a,h)}i.prototype.mulTo=function(a,h){var g,v=this.length+a.length;return this.length===10&&a.length===10?g=H(this,a,h):v<63?g=F(this,a,h):v<1024?g=K(this,a,h):g=X(this,a,h),g},i.prototype.mul=function(a){var h=new i(null);return h.words=new Array(this.length+a.length),this.mulTo(a,h)},i.prototype.mulf=function(a){var h=new i(null);return h.words=new Array(this.length+a.length),X(this,a,h)},i.prototype.imul=function(a){return this.clone().mulTo(a,this)},i.prototype.imuln=function(a){var h=a<0;h&&(a=-a),r(typeof a=="number"),r(a<67108864);for(var g=0,v=0;v<this.length;v++){var E=(this.words[v]|0)*a,T=(E&67108863)+(g&67108863);g>>=26,g+=E/67108864|0,g+=T>>>26,this.words[v]=T&67108863}return g!==0&&(this.words[v]=g,this.length++),this.length=a===0?1:this.length,h?this.ineg():this},i.prototype.muln=function(a){return this.clone().imuln(a)},i.prototype.sqr=function(){return this.mul(this)},i.prototype.isqr=function(){return this.imul(this.clone())},i.prototype.pow=function(a){var h=L(a);if(h.length===0)return new i(1);for(var g=this,v=0;v<h.length&&h[v]===0;v++,g=g.sqr());if(++v<h.length)for(var E=g.sqr();v<h.length;v++,E=E.sqr())h[v]!==0&&(g=g.mul(E));return g},i.prototype.iushln=function(a){r(typeof a=="number"&&a>=0);var h=a%26,g=(a-h)/26,v=67108863>>>26-h<<26-h,E;if(h!==0){var T=0;for(E=0;E<this.length;E++){var C=this.words[E]&v,k=(this.words[E]|0)-C<<h;this.words[E]=k|T,T=C>>>26-h}T&&(this.words[E]=T,this.length++)}if(g!==0){for(E=this.length-1;E>=0;E--)this.words[E+g]=this.words[E];for(E=0;E<g;E++)this.words[E]=0;this.length+=g}return this._strip()},i.prototype.ishln=function(a){return r(this.negative===0),this.iushln(a)},i.prototype.iushrn=function(a,h,g){r(typeof a=="number"&&a>=0);var v;h?v=(h-h%26)/26:v=0;var E=a%26,T=Math.min((a-E)/26,this.length),C=67108863^67108863>>>E<<E,k=g;if(v-=T,v=Math.max(0,v),k){for(var c=0;c<T;c++)k.words[c]=this.words[c];k.length=T}if(T!==0)if(this.length>T)for(this.length-=T,c=0;c<this.length;c++)this.words[c]=this.words[c+T];else this.words[0]=0,this.length=1;var f=0;for(c=this.length-1;c>=0&&(f!==0||c>=v);c--){var w=this.words[c]|0;this.words[c]=f<<26-E|w>>>E,f=w&C}return k&&f!==0&&(k.words[k.length++]=f),this.length===0&&(this.words[0]=0,this.length=1),this._strip()},i.prototype.ishrn=function(a,h,g){return r(this.negative===0),this.iushrn(a,h,g)},i.prototype.shln=function(a){return this.clone().ishln(a)},i.prototype.ushln=function(a){return this.clone().iushln(a)},i.prototype.shrn=function(a){return this.clone().ishrn(a)},i.prototype.ushrn=function(a){return this.clone().iushrn(a)},i.prototype.testn=function(a){r(typeof a=="number"&&a>=0);var h=a%26,g=(a-h)/26,v=1<<h;if(this.length<=g)return!1;var E=this.words[g];return!!(E&v)},i.prototype.imaskn=function(a){r(typeof a=="number"&&a>=0);var h=a%26,g=(a-h)/26;if(r(this.negative===0,"imaskn works only with positive numbers"),this.length<=g)return this;if(h!==0&&g++,this.length=Math.min(g,this.length),h!==0){var v=67108863^67108863>>>h<<h;this.words[this.length-1]&=v}return this._strip()},i.prototype.maskn=function(a){return this.clone().imaskn(a)},i.prototype.iaddn=function(a){return r(typeof a=="number"),r(a<67108864),a<0?this.isubn(-a):this.negative!==0?this.length===1&&(this.words[0]|0)<=a?(this.words[0]=a-(this.words[0]|0),this.negative=0,this):(this.negative=0,this.isubn(a),this.negative=1,this):this._iaddn(a)},i.prototype._iaddn=function(a){this.words[0]+=a;for(var h=0;h<this.length&&this.words[h]>=67108864;h++)this.words[h]-=67108864,h===this.length-1?this.words[h+1]=1:this.words[h+1]++;return this.length=Math.max(this.length,h+1),this},i.prototype.isubn=function(a){if(r(typeof a=="number"),r(a<67108864),a<0)return this.iaddn(-a);if(this.negative!==0)return this.negative=0,this.iaddn(a),this.negative=1,this;if(this.words[0]-=a,this.length===1&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var h=0;h<this.length&&this.words[h]<0;h++)this.words[h]+=67108864,this.words[h+1]-=1;return this._strip()},i.prototype.addn=function(a){return this.clone().iaddn(a)},i.prototype.subn=function(a){return this.clone().isubn(a)},i.prototype.iabs=function(){return this.negative=0,this},i.prototype.abs=function(){return this.clone().iabs()},i.prototype._ishlnsubmul=function(a,h,g){var v=a.length+g,E;this._expand(v);var T,C=0;for(E=0;E<a.length;E++){T=(this.words[E+g]|0)+C;var k=(a.words[E]|0)*h;T-=k&67108863,C=(T>>26)-(k/67108864|0),this.words[E+g]=T&67108863}for(;E<this.length-g;E++)T=(this.words[E+g]|0)+C,C=T>>26,this.words[E+g]=T&67108863;if(C===0)return this._strip();for(r(C===-1),C=0,E=0;E<this.length;E++)T=-(this.words[E]|0)+C,C=T>>26,this.words[E]=T&67108863;return this.negative=1,this._strip()},i.prototype._wordDiv=function(a,h){var g=this.length-a.length,v=this.clone(),E=a,T=E.words[E.length-1]|0,C=this._countBits(T);g=26-C,g!==0&&(E=E.ushln(g),v.iushln(g),T=E.words[E.length-1]|0);var k=v.length-E.length,c;if(h!=="mod"){c=new i(null),c.length=k+1,c.words=new Array(c.length);for(var f=0;f<c.length;f++)c.words[f]=0}var w=v.clone()._ishlnsubmul(E,1,k);w.negative===0&&(v=w,c&&(c.words[k]=1));for(var _=k-1;_>=0;_--){var z=(v.words[E.length+_]|0)*67108864+(v.words[E.length+_-1]|0);for(z=Math.min(z/T|0,67108863),v._ishlnsubmul(E,z,_);v.negative!==0;)z--,v.negative=0,v._ishlnsubmul(E,1,_),v.isZero()||(v.negative^=1);c&&(c.words[_]=z)}return c&&c._strip(),v._strip(),h!=="div"&&g!==0&&v.iushrn(g),{div:c||null,mod:v}},i.prototype.divmod=function(a,h,g){if(r(!a.isZero()),this.isZero())return{div:new i(0),mod:new i(0)};var v,E,T;return this.negative!==0&&a.negative===0?(T=this.neg().divmod(a,h),h!=="mod"&&(v=T.div.neg()),h!=="div"&&(E=T.mod.neg(),g&&E.negative!==0&&E.iadd(a)),{div:v,mod:E}):this.negative===0&&a.negative!==0?(T=this.divmod(a.neg(),h),h!=="mod"&&(v=T.div.neg()),{div:v,mod:T.mod}):(this.negative&a.negative)!==0?(T=this.neg().divmod(a.neg(),h),h!=="div"&&(E=T.mod.neg(),g&&E.negative!==0&&E.isub(a)),{div:T.div,mod:E}):a.length>this.length||this.cmp(a)<0?{div:new i(0),mod:this}:a.length===1?h==="div"?{div:this.divn(a.words[0]),mod:null}:h==="mod"?{div:null,mod:new i(this.modrn(a.words[0]))}:{div:this.divn(a.words[0]),mod:new i(this.modrn(a.words[0]))}:this._wordDiv(a,h)},i.prototype.div=function(a){return this.divmod(a,"div",!1).div},i.prototype.mod=function(a){return this.divmod(a,"mod",!1).mod},i.prototype.umod=function(a){return this.divmod(a,"mod",!0).mod},i.prototype.divRound=function(a){var h=this.divmod(a);if(h.mod.isZero())return h.div;var g=h.div.negative!==0?h.mod.isub(a):h.mod,v=a.ushrn(1),E=a.andln(1),T=g.cmp(v);return T<0||E===1&&T===0?h.div:h.div.negative!==0?h.div.isubn(1):h.div.iaddn(1)},i.prototype.modrn=function(a){var h=a<0;h&&(a=-a),r(a<=67108863);for(var g=(1<<26)%a,v=0,E=this.length-1;E>=0;E--)v=(g*v+(this.words[E]|0))%a;return h?-v:v},i.prototype.modn=function(a){return this.modrn(a)},i.prototype.idivn=function(a){var h=a<0;h&&(a=-a),r(a<=67108863);for(var g=0,v=this.length-1;v>=0;v--){var E=(this.words[v]|0)+g*67108864;this.words[v]=E/a|0,g=E%a}return this._strip(),h?this.ineg():this},i.prototype.divn=function(a){return this.clone().idivn(a)},i.prototype.egcd=function(a){r(a.negative===0),r(!a.isZero());var h=this,g=a.clone();h.negative!==0?h=h.umod(a):h=h.clone();for(var v=new i(1),E=new i(0),T=new i(0),C=new i(1),k=0;h.isEven()&&g.isEven();)h.iushrn(1),g.iushrn(1),++k;for(var c=g.clone(),f=h.clone();!h.isZero();){for(var w=0,_=1;(h.words[0]&_)===0&&w<26;++w,_<<=1);if(w>0)for(h.iushrn(w);w-- >0;)(v.isOdd()||E.isOdd())&&(v.iadd(c),E.isub(f)),v.iushrn(1),E.iushrn(1);for(var z=0,G=1;(g.words[0]&G)===0&&z<26;++z,G<<=1);if(z>0)for(g.iushrn(z);z-- >0;)(T.isOdd()||C.isOdd())&&(T.iadd(c),C.isub(f)),T.iushrn(1),C.iushrn(1);h.cmp(g)>=0?(h.isub(g),v.isub(T),E.isub(C)):(g.isub(h),T.isub(v),C.isub(E))}return{a:T,b:C,gcd:g.iushln(k)}},i.prototype._invmp=function(a){r(a.negative===0),r(!a.isZero());var h=this,g=a.clone();h.negative!==0?h=h.umod(a):h=h.clone();for(var v=new i(1),E=new i(0),T=g.clone();h.cmpn(1)>0&&g.cmpn(1)>0;){for(var C=0,k=1;(h.words[0]&k)===0&&C<26;++C,k<<=1);if(C>0)for(h.iushrn(C);C-- >0;)v.isOdd()&&v.iadd(T),v.iushrn(1);for(var c=0,f=1;(g.words[0]&f)===0&&c<26;++c,f<<=1);if(c>0)for(g.iushrn(c);c-- >0;)E.isOdd()&&E.iadd(T),E.iushrn(1);h.cmp(g)>=0?(h.isub(g),v.isub(E)):(g.isub(h),E.isub(v))}var w;return h.cmpn(1)===0?w=v:w=E,w.cmpn(0)<0&&w.iadd(a),w},i.prototype.gcd=function(a){if(this.isZero())return a.abs();if(a.isZero())return this.abs();var h=this.clone(),g=a.clone();h.negative=0,g.negative=0;for(var v=0;h.isEven()&&g.isEven();v++)h.iushrn(1),g.iushrn(1);do{for(;h.isEven();)h.iushrn(1);for(;g.isEven();)g.iushrn(1);var E=h.cmp(g);if(E<0){var T=h;h=g,g=T}else if(E===0||g.cmpn(1)===0)break;h.isub(g)}while(!0);return g.iushln(v)},i.prototype.invm=function(a){return this.egcd(a).a.umod(a)},i.prototype.isEven=function(){return(this.words[0]&1)===0},i.prototype.isOdd=function(){return(this.words[0]&1)===1},i.prototype.andln=function(a){return this.words[0]&a},i.prototype.bincn=function(a){r(typeof a=="number");var h=a%26,g=(a-h)/26,v=1<<h;if(this.length<=g)return this._expand(g+1),this.words[g]|=v,this;for(var E=v,T=g;E!==0&&T<this.length;T++){var C=this.words[T]|0;C+=E,E=C>>>26,C&=67108863,this.words[T]=C}return E!==0&&(this.words[T]=E,this.length++),this},i.prototype.isZero=function(){return this.length===1&&this.words[0]===0},i.prototype.cmpn=function(a){var h=a<0;if(this.negative!==0&&!h)return-1;if(this.negative===0&&h)return 1;this._strip();var g;if(this.length>1)g=1;else{h&&(a=-a),r(a<=67108863,"Number is too big");var v=this.words[0]|0;g=v===a?0:v<a?-1:1}return this.negative!==0?-g|0:g},i.prototype.cmp=function(a){if(this.negative!==0&&a.negative===0)return-1;if(this.negative===0&&a.negative!==0)return 1;var h=this.ucmp(a);return this.negative!==0?-h|0:h},i.prototype.ucmp=function(a){if(this.length>a.length)return 1;if(this.length<a.length)return-1;for(var h=0,g=this.length-1;g>=0;g--){var v=this.words[g]|0,E=a.words[g]|0;if(v!==E){v<E?h=-1:v>E&&(h=1);break}}return h},i.prototype.gtn=function(a){return this.cmpn(a)===1},i.prototype.gt=function(a){return this.cmp(a)===1},i.prototype.gten=function(a){return this.cmpn(a)>=0},i.prototype.gte=function(a){return this.cmp(a)>=0},i.prototype.ltn=function(a){return this.cmpn(a)===-1},i.prototype.lt=function(a){return this.cmp(a)===-1},i.prototype.lten=function(a){return this.cmpn(a)<=0},i.prototype.lte=function(a){return this.cmp(a)<=0},i.prototype.eqn=function(a){return this.cmpn(a)===0},i.prototype.eq=function(a){return this.cmp(a)===0},i.red=function(a){return new W(a)},i.prototype.toRed=function(a){return r(!this.red,"Already a number in reduction context"),r(this.negative===0,"red works only with positives"),a.convertTo(this)._forceRed(a)},i.prototype.fromRed=function(){return r(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},i.prototype._forceRed=function(a){return this.red=a,this},i.prototype.forceRed=function(a){return r(!this.red,"Already a number in reduction context"),this._forceRed(a)},i.prototype.redAdd=function(a){return r(this.red,"redAdd works only with red numbers"),this.red.add(this,a)},i.prototype.redIAdd=function(a){return r(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,a)},i.prototype.redSub=function(a){return r(this.red,"redSub works only with red numbers"),this.red.sub(this,a)},i.prototype.redISub=function(a){return r(this.red,"redISub works only with red numbers"),this.red.isub(this,a)},i.prototype.redShl=function(a){return r(this.red,"redShl works only with red numbers"),this.red.shl(this,a)},i.prototype.redMul=function(a){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,a),this.red.mul(this,a)},i.prototype.redIMul=function(a){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,a),this.red.imul(this,a)},i.prototype.redSqr=function(){return r(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},i.prototype.redISqr=function(){return r(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},i.prototype.redSqrt=function(){return r(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},i.prototype.redInvm=function(){return r(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},i.prototype.redNeg=function(){return r(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},i.prototype.redPow=function(a){return r(this.red&&!a.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,a)};var Y={k256:null,p224:null,p192:null,p25519:null};function Q(y,a){this.name=y,this.p=new i(a,16),this.n=this.p.bitLength(),this.k=new i(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}Q.prototype._tmp=function(){var a=new i(null);return a.words=new Array(Math.ceil(this.n/13)),a},Q.prototype.ireduce=function(a){var h=a,g;do this.split(h,this.tmp),h=this.imulK(h),h=h.iadd(this.tmp),g=h.bitLength();while(g>this.n);var v=g<this.n?-1:h.ucmp(this.p);return v===0?(h.words[0]=0,h.length=1):v>0?h.isub(this.p):h.strip!==void 0?h.strip():h._strip(),h},Q.prototype.split=function(a,h){a.iushrn(this.n,0,h)},Q.prototype.imulK=function(a){return a.imul(this.k)};function ct(){Q.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}s(ct,Q),ct.prototype.split=function(a,h){for(var g=4194303,v=Math.min(a.length,9),E=0;E<v;E++)h.words[E]=a.words[E];if(h.length=v,a.length<=9){a.words[0]=0,a.length=1;return}var T=a.words[9];for(h.words[h.length++]=T&g,E=10;E<a.length;E++){var C=a.words[E]|0;a.words[E-10]=(C&g)<<4|T>>>22,T=C}T>>>=22,a.words[E-10]=T,T===0&&a.length>10?a.length-=10:a.length-=9},ct.prototype.imulK=function(a){a.words[a.length]=0,a.words[a.length+1]=0,a.length+=2;for(var h=0,g=0;g<a.length;g++){var v=a.words[g]|0;h+=v*977,a.words[g]=h&67108863,h=v*64+(h/67108864|0)}return a.words[a.length-1]===0&&(a.length--,a.words[a.length-1]===0&&a.length--),a};function ot(){Q.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}s(ot,Q);function U(){Q.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}s(U,Q);function O(){Q.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}s(O,Q),O.prototype.imulK=function(a){for(var h=0,g=0;g<a.length;g++){var v=(a.words[g]|0)*19+h,E=v&67108863;v>>>=26,a.words[g]=E,h=v}return h!==0&&(a.words[a.length++]=h),a},i._prime=function(a){if(Y[a])return Y[a];var h;if(a==="k256")h=new ct;else if(a==="p224")h=new ot;else if(a==="p192")h=new U;else if(a==="p25519")h=new O;else throw new Error("Unknown prime "+a);return Y[a]=h,h};function W(y){if(typeof y=="string"){var a=i._prime(y);this.m=a.p,this.prime=a}else r(y.gtn(1),"modulus must be greater than 1"),this.m=y,this.prime=null}W.prototype._verify1=function(a){r(a.negative===0,"red works only with positives"),r(a.red,"red works only with red numbers")},W.prototype._verify2=function(a,h){r((a.negative|h.negative)===0,"red works only with positives"),r(a.red&&a.red===h.red,"red works only with red numbers")},W.prototype.imod=function(a){return this.prime?this.prime.ireduce(a)._forceRed(this):(I(a,a.umod(this.m)._forceRed(this)),a)},W.prototype.neg=function(a){return a.isZero()?a.clone():this.m.sub(a)._forceRed(this)},W.prototype.add=function(a,h){this._verify2(a,h);var g=a.add(h);return g.cmp(this.m)>=0&&g.isub(this.m),g._forceRed(this)},W.prototype.iadd=function(a,h){this._verify2(a,h);var g=a.iadd(h);return g.cmp(this.m)>=0&&g.isub(this.m),g},W.prototype.sub=function(a,h){this._verify2(a,h);var g=a.sub(h);return g.cmpn(0)<0&&g.iadd(this.m),g._forceRed(this)},W.prototype.isub=function(a,h){this._verify2(a,h);var g=a.isub(h);return g.cmpn(0)<0&&g.iadd(this.m),g},W.prototype.shl=function(a,h){return this._verify1(a),this.imod(a.ushln(h))},W.prototype.imul=function(a,h){return this._verify2(a,h),this.imod(a.imul(h))},W.prototype.mul=function(a,h){return this._verify2(a,h),this.imod(a.mul(h))},W.prototype.isqr=function(a){return this.imul(a,a.clone())},W.prototype.sqr=function(a){return this.mul(a,a)},W.prototype.sqrt=function(a){if(a.isZero())return a.clone();var h=this.m.andln(3);if(r(h%2===1),h===3){var g=this.m.add(new i(1)).iushrn(2);return this.pow(a,g)}for(var v=this.m.subn(1),E=0;!v.isZero()&&v.andln(1)===0;)E++,v.iushrn(1);r(!v.isZero());var T=new i(1).toRed(this),C=T.redNeg(),k=this.m.subn(1).iushrn(1),c=this.m.bitLength();for(c=new i(2*c*c).toRed(this);this.pow(c,k).cmp(C)!==0;)c.redIAdd(C);for(var f=this.pow(c,v),w=this.pow(a,v.addn(1).iushrn(1)),_=this.pow(a,v),z=E;_.cmp(T)!==0;){for(var G=_,rt=0;G.cmp(T)!==0;rt++)G=G.redSqr();r(rt<z);var st=this.pow(f,new i(1).iushln(z-rt-1));w=w.redMul(st),f=st.redSqr(),_=_.redMul(f),z=rt}return w},W.prototype.invm=function(a){var h=a._invmp(this.m);return h.negative!==0?(h.negative=0,this.imod(h).redNeg()):this.imod(h)},W.prototype.pow=function(a,h){if(h.isZero())return new i(1).toRed(this);if(h.cmpn(1)===0)return a.clone();var g=4,v=new Array(1<<g);v[0]=new i(1).toRed(this),v[1]=a;for(var E=2;E<v.length;E++)v[E]=this.mul(v[E-1],a);var T=v[0],C=0,k=0,c=h.bitLength()%26;for(c===0&&(c=26),E=h.length-1;E>=0;E--){for(var f=h.words[E],w=c-1;w>=0;w--){var _=f>>w&1;if(T!==v[0]&&(T=this.sqr(T)),_===0&&C===0){k=0;continue}C<<=1,C|=_,k++,!(k!==g&&(E!==0||w!==0))&&(T=this.mul(T,v[C]),k=0,C=0)}c=26}return T},W.prototype.convertTo=function(a){var h=a.umod(this.m);return h===a?h.clone():h},W.prototype.convertFrom=function(a){var h=a.clone();return h.red=null,h},i.mont=function(a){return new V(a)};function V(y){W.call(this,y),this.shift=this.m.bitLength(),this.shift%26!==0&&(this.shift+=26-this.shift%26),this.r=new i(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}s(V,W),V.prototype.convertTo=function(a){return this.imod(a.ushln(this.shift))},V.prototype.convertFrom=function(a){var h=this.imod(a.mul(this.rinv));return h.red=null,h},V.prototype.imul=function(a,h){if(a.isZero()||h.isZero())return a.words[0]=0,a.length=1,a;var g=a.imul(h),v=g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),E=g.isub(v).iushrn(this.shift),T=E;return E.cmp(this.m)>=0?T=E.isub(this.m):E.cmpn(0)<0&&(T=E.iadd(this.m)),T._forceRed(this)},V.prototype.mul=function(a,h){if(a.isZero()||h.isZero())return new i(0)._forceRed(this);var g=a.mul(h),v=g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),E=g.isub(v).iushrn(this.shift),T=E;return E.cmp(this.m)>=0?T=E.isub(this.m):E.cmpn(0)<0&&(T=E.iadd(this.m)),T._forceRed(this)},V.prototype.invm=function(a){var h=this.imod(a._invmp(this.m).mul(this.r2));return h._forceRed(this)}})(n,Dc)})(rn)),rn.exports}var Wc=Ko();const _s=wn(Wc);var Jr={exports:{}};/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var As;function qo(){return As||(As=1,(function(n,t){var e=Pi(),r=e.Buffer;function s(o,u){for(var d in o)u[d]=o[d]}r.from&&r.alloc&&r.allocUnsafe&&r.allocUnsafeSlow?n.exports=e:(s(e,t),t.Buffer=i);function i(o,u,d){return r(o,u,d)}i.prototype=Object.create(r.prototype),s(r,i),i.from=function(o,u,d){if(typeof o=="number")throw new TypeError("Argument must not be a number");return r(o,u,d)},i.alloc=function(o,u,d){if(typeof o!="number")throw new TypeError("Argument must be a number");var b=r(o);return u!==void 0?typeof d=="string"?b.fill(u,d):b.fill(u):b.fill(0),b},i.allocUnsafe=function(o){if(typeof o!="number")throw new TypeError("Argument must be a number");return r(o)},i.allocUnsafeSlow=function(o){if(typeof o!="number")throw new TypeError("Argument must be a number");return e.SlowBuffer(o)}})(Jr,Jr.exports)),Jr.exports}var ei,Bs;function $c(){if(Bs)return ei;Bs=1;var n=qo().Buffer;function t(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),s=0;s<r.length;s++)r[s]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),u=o.charCodeAt(0);if(r[u]!==255)throw new TypeError(o+" is ambiguous");r[u]=i}var d=e.length,b=e.charAt(0),I=Math.log(d)/Math.log(256),B=Math.log(256)/Math.log(d);function A(R){if((Array.isArray(R)||R instanceof Uint8Array)&&(R=n.from(R)),!n.isBuffer(R))throw new TypeError("Expected Buffer");if(R.length===0)return"";for(var L=0,F=0,H=0,K=R.length;H!==K&&R[H]===0;)H++,L++;for(var X=(K-H)*B+1>>>0,Y=new Uint8Array(X);H!==K;){for(var Q=R[H],ct=0,ot=X-1;(Q!==0||ct<F)&&ot!==-1;ot--,ct++)Q+=256*Y[ot]>>>0,Y[ot]=Q%d>>>0,Q=Q/d>>>0;if(Q!==0)throw new Error("Non-zero carry");F=ct,H++}for(var U=X-F;U!==X&&Y[U]===0;)U++;for(var O=b.repeat(L);U<X;++U)O+=e.charAt(Y[U]);return O}function S(R){if(typeof R!="string")throw new TypeError("Expected String");if(R.length===0)return n.alloc(0);for(var L=0,F=0,H=0;R[L]===b;)F++,L++;for(var K=(R.length-L)*I+1>>>0,X=new Uint8Array(K);L<R.length;){var Y=R.charCodeAt(L);if(Y>255)return;var Q=r[Y];if(Q===255)return;for(var ct=0,ot=K-1;(Q!==0||ct<H)&&ot!==-1;ot--,ct++)Q+=d*X[ot]>>>0,X[ot]=Q%256>>>0,Q=Q/256>>>0;if(Q!==0)throw new Error("Non-zero carry");H=ct,L++}for(var U=K-H;U!==K&&X[U]===0;)U++;var O=n.allocUnsafe(F+(K-U));O.fill(0,0,F);for(var W=F;U!==K;)O[W++]=X[U++];return O}function M(R){var L=S(R);if(L)return L;throw new Error("Non-base"+d+" character")}return{encode:A,decodeUnsafe:S,decode:M}}return ei=t,ei}var ri,Rs;function Vc(){if(Rs)return ri;Rs=1;var n=$c(),t="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return ri=n(t),ri}var Hc=Vc();const le=wn(Hc),Ms=bo;var Et={},ni,Ts;function jc(){if(Ts)return ni;Ts=1;var n=qo().Buffer;function t(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),s=0;s<r.length;s++)r[s]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),u=o.charCodeAt(0);if(r[u]!==255)throw new TypeError(o+" is ambiguous");r[u]=i}var d=e.length,b=e.charAt(0),I=Math.log(d)/Math.log(256),B=Math.log(256)/Math.log(d);function A(R){if((Array.isArray(R)||R instanceof Uint8Array)&&(R=n.from(R)),!n.isBuffer(R))throw new TypeError("Expected Buffer");if(R.length===0)return"";for(var L=0,F=0,H=0,K=R.length;H!==K&&R[H]===0;)H++,L++;for(var X=(K-H)*B+1>>>0,Y=new Uint8Array(X);H!==K;){for(var Q=R[H],ct=0,ot=X-1;(Q!==0||ct<F)&&ot!==-1;ot--,ct++)Q+=256*Y[ot]>>>0,Y[ot]=Q%d>>>0,Q=Q/d>>>0;if(Q!==0)throw new Error("Non-zero carry");F=ct,H++}for(var U=X-F;U!==X&&Y[U]===0;)U++;for(var O=b.repeat(L);U<X;++U)O+=e.charAt(Y[U]);return O}function S(R){if(typeof R!="string")throw new TypeError("Expected String");if(R.length===0)return n.alloc(0);for(var L=0,F=0,H=0;R[L]===b;)F++,L++;for(var K=(R.length-L)*I+1>>>0,X=new Uint8Array(K);L<R.length;){var Y=R.charCodeAt(L);if(Y>255)return;var Q=r[Y];if(Q===255)return;for(var ct=0,ot=K-1;(Q!==0||ct<H)&&ot!==-1;ot--,ct++)Q+=d*X[ot]>>>0,X[ot]=Q%256>>>0,Q=Q/256>>>0;if(Q!==0)throw new Error("Non-zero carry");H=ct,L++}for(var U=K-H;U!==K&&X[U]===0;)U++;var O=n.allocUnsafe(F+(K-U));O.fill(0,0,F);for(var W=F;U!==K;)O[W++]=X[U++];return O}function M(R){var L=S(R);if(L)return L;throw new Error("Non-base"+d+" character")}return{encode:A,decodeUnsafe:S,decode:M}}return ni=t,ni}var ii,Ps;function Gc(){if(Ps)return ii;Ps=1;var n=jc(),t="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return ii=n(t),ii}function Ke(n,t,e){return t<=n&&n<=e}function vn(n){if(n===void 0)return{};if(n===Object(n))return n;throw TypeError("Could not convert argument to dictionary")}function Zc(n){for(var t=String(n),e=t.length,r=0,s=[];r<e;){var i=t.charCodeAt(r);if(i<55296||i>57343)s.push(i);else if(56320<=i&&i<=57343)s.push(65533);else if(55296<=i&&i<=56319)if(r===e-1)s.push(65533);else{var o=n.charCodeAt(r+1);if(56320<=o&&o<=57343){var u=i&1023,d=o&1023;s.push(65536+(u<<10)+d),r+=1}else s.push(65533)}r+=1}return s}function Yc(n){for(var t="",e=0;e<n.length;++e){var r=n[e];r<=65535?t+=String.fromCharCode(r):(r-=65536,t+=String.fromCharCode((r>>10)+55296,(r&1023)+56320))}return t}var cn=-1;function Ki(n){this.tokens=[].slice.call(n)}Ki.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():cn},prepend:function(n){if(Array.isArray(n))for(var t=n;t.length;)this.tokens.unshift(t.pop());else this.tokens.unshift(n)},push:function(n){if(Array.isArray(n))for(var t=n;t.length;)this.tokens.push(t.shift());else this.tokens.push(n)}};var vr=-1;function si(n,t){if(n)throw TypeError("Decoder error");return t||65533}var un="utf-8";function fn(n,t){if(!(this instanceof fn))return new fn(n,t);if(n=n!==void 0?String(n).toLowerCase():un,n!==un)throw new Error("Encoding not supported. Only utf-8 is supported");t=vn(t),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!t.fatal,this._ignoreBOM=!!t.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}fn.prototype={decode:function(t,e){var r;typeof t=="object"&&t instanceof ArrayBuffer?r=new Uint8Array(t):typeof t=="object"&&"buffer"in t&&t.buffer instanceof ArrayBuffer?r=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):r=new Uint8Array(0),e=vn(e),this._streaming||(this._decoder=new Xc({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!e.stream;for(var s=new Ki(r),i=[],o;!s.endOfStream()&&(o=this._decoder.handler(s,s.read()),o!==vr);)o!==null&&(Array.isArray(o)?i.push.apply(i,o):i.push(o));if(!this._streaming){do{if(o=this._decoder.handler(s,s.read()),o===vr)break;o!==null&&(Array.isArray(o)?i.push.apply(i,o):i.push(o))}while(!s.endOfStream());this._decoder=null}return i.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(i[0]===65279?(this._BOMseen=!0,i.shift()):this._BOMseen=!0),Yc(i)}};function ln(n,t){if(!(this instanceof ln))return new ln(n,t);if(n=n!==void 0?String(n).toLowerCase():un,n!==un)throw new Error("Encoding not supported. Only utf-8 is supported");t=vn(t),this._streaming=!1,this._encoder=null,this._options={fatal:!!t.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}ln.prototype={encode:function(t,e){t=t?String(t):"",e=vn(e),this._streaming||(this._encoder=new Jc(this._options)),this._streaming=!!e.stream;for(var r=[],s=new Ki(Zc(t)),i;!s.endOfStream()&&(i=this._encoder.handler(s,s.read()),i!==vr);)Array.isArray(i)?r.push.apply(r,i):r.push(i);if(!this._streaming){for(;i=this._encoder.handler(s,s.read()),i!==vr;)Array.isArray(i)?r.push.apply(r,i):r.push(i);this._encoder=null}return new Uint8Array(r)}};function Xc(n){var t=n.fatal,e=0,r=0,s=0,i=128,o=191;this.handler=function(u,d){if(d===cn&&s!==0)return s=0,si(t);if(d===cn)return vr;if(s===0){if(Ke(d,0,127))return d;if(Ke(d,194,223))s=1,e=d-192;else if(Ke(d,224,239))d===224&&(i=160),d===237&&(o=159),s=2,e=d-224;else if(Ke(d,240,244))d===240&&(i=144),d===244&&(o=143),s=3,e=d-240;else return si(t);return e=e<<6*s,null}if(!Ke(d,i,o))return e=s=r=0,i=128,o=191,u.prepend(d),si(t);if(i=128,o=191,r+=1,e+=d-128<<6*(s-r),r!==s)return null;var b=e;return e=s=r=0,b}}function Jc(n){n.fatal,this.handler=function(t,e){if(e===cn)return vr;if(Ke(e,0,127))return e;var r,s;Ke(e,128,2047)?(r=1,s=192):Ke(e,2048,65535)?(r=2,s=224):Ke(e,65536,1114111)&&(r=3,s=240);for(var i=[(e>>6*r)+s];r>0;){var o=e>>6*(r-1);i.push(128|o&63),r-=1}return i}}const Qc=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:fn,TextEncoder:ln},Symbol.toStringTag,{value:"Module"})),tu=Ti(Qc);var Ls;function eu(){if(Ls)return Et;Ls=1;var n=Et&&Et.__createBinding||(Object.create?(function(U,O,W,V){V===void 0&&(V=W),Object.defineProperty(U,V,{enumerable:!0,get:function(){return O[W]}})}):(function(U,O,W,V){V===void 0&&(V=W),U[V]=O[W]})),t=Et&&Et.__setModuleDefault||(Object.create?(function(U,O){Object.defineProperty(U,"default",{enumerable:!0,value:O})}):function(U,O){U.default=O}),e=Et&&Et.__decorate||function(U,O,W,V){var y=arguments.length,a=y<3?O:V===null?V=Object.getOwnPropertyDescriptor(O,W):V,h;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")a=Reflect.decorate(U,O,W,V);else for(var g=U.length-1;g>=0;g--)(h=U[g])&&(a=(y<3?h(a):y>3?h(O,W,a):h(O,W))||a);return y>3&&a&&Object.defineProperty(O,W,a),a},r=Et&&Et.__importStar||function(U){if(U&&U.__esModule)return U;var O={};if(U!=null)for(var W in U)W!=="default"&&Object.hasOwnProperty.call(U,W)&&n(O,U,W);return t(O,U),O},s=Et&&Et.__importDefault||function(U){return U&&U.__esModule?U:{default:U}};Object.defineProperty(Et,"__esModule",{value:!0}),Et.deserializeUnchecked=Et.deserialize=Et.serialize=Et.BinaryReader=Et.BinaryWriter=Et.BorshError=Et.baseDecode=Et.baseEncode=void 0;const i=s(Ko()),o=s(Gc()),u=r(tu),d=typeof TextDecoder!="function"?u.TextDecoder:TextDecoder,b=new d("utf-8",{fatal:!0});function I(U){return typeof U=="string"&&(U=Buffer.from(U,"utf8")),o.default.encode(Buffer.from(U))}Et.baseEncode=I;function B(U){return Buffer.from(o.default.decode(U))}Et.baseDecode=B;const A=1024;class S extends Error{constructor(O){super(O),this.fieldPath=[],this.originalMessage=O}addToFieldPath(O){this.fieldPath.splice(0,0,O),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}Et.BorshError=S;class M{constructor(){this.buf=Buffer.alloc(A),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(A)]))}writeU8(O){this.maybeResize(),this.buf.writeUInt8(O,this.length),this.length+=1}writeU16(O){this.maybeResize(),this.buf.writeUInt16LE(O,this.length),this.length+=2}writeU32(O){this.maybeResize(),this.buf.writeUInt32LE(O,this.length),this.length+=4}writeU64(O){this.maybeResize(),this.writeBuffer(Buffer.from(new i.default(O).toArray("le",8)))}writeU128(O){this.maybeResize(),this.writeBuffer(Buffer.from(new i.default(O).toArray("le",16)))}writeU256(O){this.maybeResize(),this.writeBuffer(Buffer.from(new i.default(O).toArray("le",32)))}writeU512(O){this.maybeResize(),this.writeBuffer(Buffer.from(new i.default(O).toArray("le",64)))}writeBuffer(O){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),O,Buffer.alloc(A)]),this.length+=O.length}writeString(O){this.maybeResize();const W=Buffer.from(O,"utf8");this.writeU32(W.length),this.writeBuffer(W)}writeFixedArray(O){this.writeBuffer(Buffer.from(O))}writeArray(O,W){this.maybeResize(),this.writeU32(O.length);for(const V of O)this.maybeResize(),W(V)}toArray(){return this.buf.subarray(0,this.length)}}Et.BinaryWriter=M;function R(U,O,W){const V=W.value;W.value=function(...y){try{return V.apply(this,y)}catch(a){if(a instanceof RangeError){const h=a.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(h)>=0)throw new S("Reached the end of buffer when deserializing")}throw a}}}class L{constructor(O){this.buf=O,this.offset=0}readU8(){const O=this.buf.readUInt8(this.offset);return this.offset+=1,O}readU16(){const O=this.buf.readUInt16LE(this.offset);return this.offset+=2,O}readU32(){const O=this.buf.readUInt32LE(this.offset);return this.offset+=4,O}readU64(){const O=this.readBuffer(8);return new i.default(O,"le")}readU128(){const O=this.readBuffer(16);return new i.default(O,"le")}readU256(){const O=this.readBuffer(32);return new i.default(O,"le")}readU512(){const O=this.readBuffer(64);return new i.default(O,"le")}readBuffer(O){if(this.offset+O>this.buf.length)throw new S(`Expected buffer length ${O} isn't within bounds`);const W=this.buf.slice(this.offset,this.offset+O);return this.offset+=O,W}readString(){const O=this.readU32(),W=this.readBuffer(O);try{return b.decode(W)}catch(V){throw new S(`Error decoding UTF-8 string: ${V}`)}}readFixedArray(O){return new Uint8Array(this.readBuffer(O))}readArray(O){const W=this.readU32(),V=Array();for(let y=0;y<W;++y)V.push(O());return V}}e([R],L.prototype,"readU8",null),e([R],L.prototype,"readU16",null),e([R],L.prototype,"readU32",null),e([R],L.prototype,"readU64",null),e([R],L.prototype,"readU128",null),e([R],L.prototype,"readU256",null),e([R],L.prototype,"readU512",null),e([R],L.prototype,"readString",null),e([R],L.prototype,"readFixedArray",null),e([R],L.prototype,"readArray",null),Et.BinaryReader=L;function F(U){return U.charAt(0).toUpperCase()+U.slice(1)}function H(U,O,W,V,y){try{if(typeof V=="string")y[`write${F(V)}`](W);else if(V instanceof Array)if(typeof V[0]=="number"){if(W.length!==V[0])throw new S(`Expecting byte array of length ${V[0]}, but got ${W.length} bytes`);y.writeFixedArray(W)}else if(V.length===2&&typeof V[1]=="number"){if(W.length!==V[1])throw new S(`Expecting byte array of length ${V[1]}, but got ${W.length} bytes`);for(let a=0;a<V[1];a++)H(U,null,W[a],V[0],y)}else y.writeArray(W,a=>{H(U,O,a,V[0],y)});else if(V.kind!==void 0)switch(V.kind){case"option":{W==null?y.writeU8(0):(y.writeU8(1),H(U,O,W,V.type,y));break}case"map":{y.writeU32(W.size),W.forEach((a,h)=>{H(U,O,h,V.key,y),H(U,O,a,V.value,y)});break}default:throw new S(`FieldType ${V} unrecognized`)}else K(U,W,y)}catch(a){throw a instanceof S&&a.addToFieldPath(O),a}}function K(U,O,W){if(typeof O.borshSerialize=="function"){O.borshSerialize(W);return}const V=U.get(O.constructor);if(!V)throw new S(`Class ${O.constructor.name} is missing in schema`);if(V.kind==="struct")V.fields.map(([y,a])=>{H(U,y,O[y],a,W)});else if(V.kind==="enum"){const y=O[V.field];for(let a=0;a<V.values.length;++a){const[h,g]=V.values[a];if(h===y){W.writeU8(a),H(U,h,O[h],g,W);break}}}else throw new S(`Unexpected schema kind: ${V.kind} for ${O.constructor.name}`)}function X(U,O,W=M){const V=new W;return K(U,O,V),V.toArray()}Et.serialize=X;function Y(U,O,W,V){try{if(typeof W=="string")return V[`read${F(W)}`]();if(W instanceof Array){if(typeof W[0]=="number")return V.readFixedArray(W[0]);if(typeof W[1]=="number"){const y=[];for(let a=0;a<W[1];a++)y.push(Y(U,null,W[0],V));return y}else return V.readArray(()=>Y(U,O,W[0],V))}if(W.kind==="option")return V.readU8()?Y(U,O,W.type,V):void 0;if(W.kind==="map"){let y=new Map;const a=V.readU32();for(let h=0;h<a;h++){const g=Y(U,O,W.key,V),v=Y(U,O,W.value,V);y.set(g,v)}return y}return Q(U,W,V)}catch(y){throw y instanceof S&&y.addToFieldPath(O),y}}function Q(U,O,W){if(typeof O.borshDeserialize=="function")return O.borshDeserialize(W);const V=U.get(O);if(!V)throw new S(`Class ${O.name} is missing in schema`);if(V.kind==="struct"){const y={};for(const[a,h]of U.get(O).fields)y[a]=Y(U,a,h,W);return new O(y)}if(V.kind==="enum"){const y=W.readU8();if(y>=V.values.length)throw new S(`Enum index: ${y} is out of range`);const[a,h]=V.values[y],g=Y(U,a,h,W);return new O({[a]:g})}throw new S(`Unexpected schema kind: ${V.kind} for ${O.constructor.name}`)}function ct(U,O,W,V=L){const y=new V(W),a=Q(U,O,y);if(y.offset<W.length)throw new S(`Unexpected ${W.length-y.offset} bytes after deserialized data`);return a}Et.deserialize=ct;function ot(U,O,W,V=L){const y=new V(W);return Q(U,O,y)}return Et.deserializeUnchecked=ot,Et}var oi=eu(),$={},Cs;function ru(){if(Cs)return $;Cs=1,Object.defineProperty($,"__esModule",{value:!0}),$.s16=$.s8=$.nu64be=$.u48be=$.u40be=$.u32be=$.u24be=$.u16be=$.nu64=$.u48=$.u40=$.u32=$.u24=$.u16=$.u8=$.offset=$.greedy=$.Constant=$.UTF8=$.CString=$.Blob=$.Boolean=$.BitField=$.BitStructure=$.VariantLayout=$.Union=$.UnionLayoutDiscriminator=$.UnionDiscriminator=$.Structure=$.Sequence=$.DoubleBE=$.Double=$.FloatBE=$.Float=$.NearInt64BE=$.NearInt64=$.NearUInt64BE=$.NearUInt64=$.IntBE=$.Int=$.UIntBE=$.UInt=$.OffsetLayout=$.GreedyCount=$.ExternalLayout=$.bindConstructorLayout=$.nameWithProperty=$.Layout=$.uint8ArrayToBuffer=$.checkUint8Array=void 0,$.constant=$.utf8=$.cstr=$.blob=$.unionLayoutDiscriminator=$.union=$.seq=$.bits=$.struct=$.f64be=$.f64=$.f32be=$.f32=$.ns64be=$.s48be=$.s40be=$.s32be=$.s24be=$.s16be=$.ns64=$.s48=$.s40=$.s32=$.s24=void 0;const n=Pi();function t(c){if(!(c instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}$.checkUint8Array=t;function e(c){return t(c),n.Buffer.from(c.buffer,c.byteOffset,c.length)}$.uint8ArrayToBuffer=e;let r=class{constructor(f,w){if(!Number.isInteger(f))throw new TypeError("span must be an integer");this.span=f,this.property=w}makeDestinationObject(){return{}}getSpan(f,w){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(f){const w=Object.create(this.constructor.prototype);return Object.assign(w,this),w.property=f,w}fromArray(f){}};$.Layout=r;function s(c,f){return f.property?c+"["+f.property+"]":c}$.nameWithProperty=s;function i(c,f){if(typeof c!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(c,"layout_"))throw new Error("Class is already bound to a layout");if(!(f&&f instanceof r))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(f,"boundConstructor_"))throw new Error("layout is already bound to a constructor");c.layout_=f,f.boundConstructor_=c,f.makeDestinationObject=(()=>new c),Object.defineProperty(c.prototype,"encode",{value(w,_){return f.encode(this,w,_)},writable:!0}),Object.defineProperty(c,"decode",{value(w,_){return f.decode(w,_)},writable:!0})}$.bindConstructorLayout=i;class o extends r{isCount(){throw new Error("ExternalLayout is abstract")}}$.ExternalLayout=o;class u extends o{constructor(f=1,w){if(!Number.isInteger(f)||0>=f)throw new TypeError("elementSpan must be a (positive) integer");super(-1,w),this.elementSpan=f}isCount(){return!0}decode(f,w=0){t(f);const _=f.length-w;return Math.floor(_/this.elementSpan)}encode(f,w,_){return 0}}$.GreedyCount=u;class d extends o{constructor(f,w=0,_){if(!(f instanceof r))throw new TypeError("layout must be a Layout");if(!Number.isInteger(w))throw new TypeError("offset must be integer or undefined");super(f.span,_||f.property),this.layout=f,this.offset=w}isCount(){return this.layout instanceof b||this.layout instanceof I}decode(f,w=0){return this.layout.decode(f,w+this.offset)}encode(f,w,_=0){return this.layout.encode(f,w,_+this.offset)}}$.OffsetLayout=d;class b extends r{constructor(f,w){if(super(f,w),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(f,w=0){return e(f).readUIntLE(w,this.span)}encode(f,w,_=0){return e(w).writeUIntLE(f,_,this.span),this.span}}$.UInt=b;class I extends r{constructor(f,w){if(super(f,w),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(f,w=0){return e(f).readUIntBE(w,this.span)}encode(f,w,_=0){return e(w).writeUIntBE(f,_,this.span),this.span}}$.UIntBE=I;class B extends r{constructor(f,w){if(super(f,w),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(f,w=0){return e(f).readIntLE(w,this.span)}encode(f,w,_=0){return e(w).writeIntLE(f,_,this.span),this.span}}$.Int=B;class A extends r{constructor(f,w){if(super(f,w),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(f,w=0){return e(f).readIntBE(w,this.span)}encode(f,w,_=0){return e(w).writeIntBE(f,_,this.span),this.span}}$.IntBE=A;const S=Math.pow(2,32);function M(c){const f=Math.floor(c/S),w=c-f*S;return{hi32:f,lo32:w}}function R(c,f){return c*S+f}class L extends r{constructor(f){super(8,f)}decode(f,w=0){const _=e(f),z=_.readUInt32LE(w),G=_.readUInt32LE(w+4);return R(G,z)}encode(f,w,_=0){const z=M(f),G=e(w);return G.writeUInt32LE(z.lo32,_),G.writeUInt32LE(z.hi32,_+4),8}}$.NearUInt64=L;class F extends r{constructor(f){super(8,f)}decode(f,w=0){const _=e(f),z=_.readUInt32BE(w),G=_.readUInt32BE(w+4);return R(z,G)}encode(f,w,_=0){const z=M(f),G=e(w);return G.writeUInt32BE(z.hi32,_),G.writeUInt32BE(z.lo32,_+4),8}}$.NearUInt64BE=F;class H extends r{constructor(f){super(8,f)}decode(f,w=0){const _=e(f),z=_.readUInt32LE(w),G=_.readInt32LE(w+4);return R(G,z)}encode(f,w,_=0){const z=M(f),G=e(w);return G.writeUInt32LE(z.lo32,_),G.writeInt32LE(z.hi32,_+4),8}}$.NearInt64=H;class K extends r{constructor(f){super(8,f)}decode(f,w=0){const _=e(f),z=_.readInt32BE(w),G=_.readUInt32BE(w+4);return R(z,G)}encode(f,w,_=0){const z=M(f),G=e(w);return G.writeInt32BE(z.hi32,_),G.writeUInt32BE(z.lo32,_+4),8}}$.NearInt64BE=K;class X extends r{constructor(f){super(4,f)}decode(f,w=0){return e(f).readFloatLE(w)}encode(f,w,_=0){return e(w).writeFloatLE(f,_),4}}$.Float=X;class Y extends r{constructor(f){super(4,f)}decode(f,w=0){return e(f).readFloatBE(w)}encode(f,w,_=0){return e(w).writeFloatBE(f,_),4}}$.FloatBE=Y;class Q extends r{constructor(f){super(8,f)}decode(f,w=0){return e(f).readDoubleLE(w)}encode(f,w,_=0){return e(w).writeDoubleLE(f,_),8}}$.Double=Q;class ct extends r{constructor(f){super(8,f)}decode(f,w=0){return e(f).readDoubleBE(w)}encode(f,w,_=0){return e(w).writeDoubleBE(f,_),8}}$.DoubleBE=ct;class ot extends r{constructor(f,w,_){if(!(f instanceof r))throw new TypeError("elementLayout must be a Layout");if(!(w instanceof o&&w.isCount()||Number.isInteger(w)&&0<=w))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let z=-1;!(w instanceof o)&&0<f.span&&(z=w*f.span),super(z,_),this.elementLayout=f,this.count=w}getSpan(f,w=0){if(0<=this.span)return this.span;let _=0,z=this.count;if(z instanceof o&&(z=z.decode(f,w)),0<this.elementLayout.span)_=z*this.elementLayout.span;else{let G=0;for(;G<z;)_+=this.elementLayout.getSpan(f,w+_),++G}return _}decode(f,w=0){const _=[];let z=0,G=this.count;for(G instanceof o&&(G=G.decode(f,w));z<G;)_.push(this.elementLayout.decode(f,w)),w+=this.elementLayout.getSpan(f,w),z+=1;return _}encode(f,w,_=0){const z=this.elementLayout,G=f.reduce((rt,st)=>rt+z.encode(st,w,_+rt),0);return this.count instanceof o&&this.count.encode(f.length,w,_),G}}$.Sequence=ot;class U extends r{constructor(f,w,_){if(!(Array.isArray(f)&&f.reduce((G,rt)=>G&&rt instanceof r,!0)))throw new TypeError("fields must be array of Layout instances");typeof w=="boolean"&&_===void 0&&(_=w,w=void 0);for(const G of f)if(0>G.span&&G.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let z=-1;try{z=f.reduce((G,rt)=>G+rt.getSpan(),0)}catch{}super(z,w),this.fields=f,this.decodePrefixes=!!_}getSpan(f,w=0){if(0<=this.span)return this.span;let _=0;try{_=this.fields.reduce((z,G)=>{const rt=G.getSpan(f,w);return w+=rt,z+rt},0)}catch{throw new RangeError("indeterminate span")}return _}decode(f,w=0){t(f);const _=this.makeDestinationObject();for(const z of this.fields)if(z.property!==void 0&&(_[z.property]=z.decode(f,w)),w+=z.getSpan(f,w),this.decodePrefixes&&f.length===w)break;return _}encode(f,w,_=0){const z=_;let G=0,rt=0;for(const st of this.fields){let kt=st.span;if(rt=0<kt?kt:0,st.property!==void 0){const vt=f[st.property];vt!==void 0&&(rt=st.encode(vt,w,_),0>kt&&(kt=st.getSpan(w,_)))}G=_,_+=kt}return G+rt-z}fromArray(f){const w=this.makeDestinationObject();for(const _ of this.fields)_.property!==void 0&&0<f.length&&(w[_.property]=f.shift());return w}layoutFor(f){if(typeof f!="string")throw new TypeError("property must be string");for(const w of this.fields)if(w.property===f)return w}offsetOf(f){if(typeof f!="string")throw new TypeError("property must be string");let w=0;for(const _ of this.fields){if(_.property===f)return w;0>_.span?w=-1:0<=w&&(w+=_.span)}}}$.Structure=U;class O{constructor(f){this.property=f}decode(f,w){throw new Error("UnionDiscriminator is abstract")}encode(f,w,_){throw new Error("UnionDiscriminator is abstract")}}$.UnionDiscriminator=O;class W extends O{constructor(f,w){if(!(f instanceof o&&f.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(w||f.property||"variant"),this.layout=f}decode(f,w){return this.layout.decode(f,w)}encode(f,w,_){return this.layout.encode(f,w,_)}}$.UnionLayoutDiscriminator=W;class V extends r{constructor(f,w,_){let z;if(f instanceof b||f instanceof I)z=new W(new d(f));else if(f instanceof o&&f.isCount())z=new W(f);else if(f instanceof O)z=f;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(w===void 0&&(w=null),!(w===null||w instanceof r))throw new TypeError("defaultLayout must be null or a Layout");if(w!==null){if(0>w.span)throw new Error("defaultLayout must have constant span");w.property===void 0&&(w=w.replicate("content"))}let G=-1;w&&(G=w.span,0<=G&&(f instanceof b||f instanceof I)&&(G+=z.layout.span)),super(G,_),this.discriminator=z,this.usesPrefixDiscriminator=f instanceof b||f instanceof I,this.defaultLayout=w,this.registry={};let rt=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(st){return rt(st)},this.configGetSourceVariant=function(st){rt=st.bind(this)}}getSpan(f,w=0){if(0<=this.span)return this.span;const _=this.getVariant(f,w);if(!_)throw new Error("unable to determine span for unrecognized variant");return _.getSpan(f,w)}defaultGetSourceVariant(f){if(Object.prototype.hasOwnProperty.call(f,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(f,this.defaultLayout.property))return;const w=this.registry[f[this.discriminator.property]];if(w&&(!w.layout||w.property&&Object.prototype.hasOwnProperty.call(f,w.property)))return w}else for(const w in this.registry){const _=this.registry[w];if(_.property&&Object.prototype.hasOwnProperty.call(f,_.property))return _}throw new Error("unable to infer src variant")}decode(f,w=0){let _;const z=this.discriminator,G=z.decode(f,w),rt=this.registry[G];if(rt===void 0){const st=this.defaultLayout;let kt=0;this.usesPrefixDiscriminator&&(kt=z.layout.span),_=this.makeDestinationObject(),_[z.property]=G,_[st.property]=st.decode(f,w+kt)}else _=rt.decode(f,w);return _}encode(f,w,_=0){const z=this.getSourceVariant(f);if(z===void 0){const G=this.discriminator,rt=this.defaultLayout;let st=0;return this.usesPrefixDiscriminator&&(st=G.layout.span),G.encode(f[G.property],w,_),st+rt.encode(f[rt.property],w,_+st)}return z.encode(f,w,_)}addVariant(f,w,_){const z=new y(this,f,w,_);return this.registry[f]=z,z}getVariant(f,w=0){let _;return f instanceof Uint8Array?_=this.discriminator.decode(f,w):_=f,this.registry[_]}}$.Union=V;class y extends r{constructor(f,w,_,z){if(!(f instanceof V))throw new TypeError("union must be a Union");if(!Number.isInteger(w)||0>w)throw new TypeError("variant must be a (non-negative) integer");if(typeof _=="string"&&z===void 0&&(z=_,_=null),_){if(!(_ instanceof r))throw new TypeError("layout must be a Layout");if(f.defaultLayout!==null&&0<=_.span&&_.span>f.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof z!="string")throw new TypeError("variant must have a String property")}let G=f.span;0>f.span&&(G=_?_.span:0,0<=G&&f.usesPrefixDiscriminator&&(G+=f.discriminator.layout.span)),super(G,z),this.union=f,this.variant=w,this.layout=_||null}getSpan(f,w=0){if(0<=this.span)return this.span;let _=0;this.union.usesPrefixDiscriminator&&(_=this.union.discriminator.layout.span);let z=0;return this.layout&&(z=this.layout.getSpan(f,w+_)),_+z}decode(f,w=0){const _=this.makeDestinationObject();if(this!==this.union.getVariant(f,w))throw new Error("variant mismatch");let z=0;return this.union.usesPrefixDiscriminator&&(z=this.union.discriminator.layout.span),this.layout?_[this.property]=this.layout.decode(f,w+z):this.property?_[this.property]=!0:this.union.usesPrefixDiscriminator&&(_[this.union.discriminator.property]=this.variant),_}encode(f,w,_=0){let z=0;if(this.union.usesPrefixDiscriminator&&(z=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(f,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,w,_);let G=z;if(this.layout&&(this.layout.encode(f[this.property],w,_+z),G+=this.layout.getSpan(w,_+z),0<=this.union.span&&G>this.union.span))throw new Error("encoded variant overruns containing union");return G}fromArray(f){if(this.layout)return this.layout.fromArray(f)}}$.VariantLayout=y;function a(c){return 0>c&&(c+=4294967296),c}class h extends r{constructor(f,w,_){if(!(f instanceof b||f instanceof I))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof w=="string"&&_===void 0&&(_=w,w=!1),4<f.span)throw new RangeError("word cannot exceed 32 bits");super(f.span,_),this.word=f,this.msb=!!w,this.fields=[];let z=0;this._packedSetValue=function(G){return z=a(G),this},this._packedGetValue=function(){return z}}decode(f,w=0){const _=this.makeDestinationObject(),z=this.word.decode(f,w);this._packedSetValue(z);for(const G of this.fields)G.property!==void 0&&(_[G.property]=G.decode(f));return _}encode(f,w,_=0){const z=this.word.decode(w,_);this._packedSetValue(z);for(const G of this.fields)if(G.property!==void 0){const rt=f[G.property];rt!==void 0&&G.encode(rt)}return this.word.encode(this._packedGetValue(),w,_)}addField(f,w){const _=new g(this,f,w);return this.fields.push(_),_}addBoolean(f){const w=new v(this,f);return this.fields.push(w),w}fieldFor(f){if(typeof f!="string")throw new TypeError("property must be string");for(const w of this.fields)if(w.property===f)return w}}$.BitStructure=h;class g{constructor(f,w,_){if(!(f instanceof h))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(w)||0>=w)throw new TypeError("bits must be positive integer");const z=8*f.span,G=f.fields.reduce((rt,st)=>rt+st.bits,0);if(w+G>z)throw new Error("bits too long for span remainder ("+(z-G)+" of "+z+" remain)");this.container=f,this.bits=w,this.valueMask=(1<<w)-1,w===32&&(this.valueMask=4294967295),this.start=G,this.container.msb&&(this.start=z-G-w),this.wordMask=a(this.valueMask<<this.start),this.property=_}decode(f,w){const _=this.container._packedGetValue();return a(_&this.wordMask)>>>this.start}encode(f){if(typeof f!="number"||!Number.isInteger(f)||f!==a(f&this.valueMask))throw new TypeError(s("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const w=this.container._packedGetValue(),_=a(f<<this.start);this.container._packedSetValue(a(w&~this.wordMask)|_)}}$.BitField=g;class v extends g{constructor(f,w){super(f,1,w)}decode(f,w){return!!super.decode(f,w)}encode(f){typeof f=="boolean"&&(f=+f),super.encode(f)}}$.Boolean=v;class E extends r{constructor(f,w){if(!(f instanceof o&&f.isCount()||Number.isInteger(f)&&0<=f))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let _=-1;f instanceof o||(_=f),super(_,w),this.length=f}getSpan(f,w){let _=this.span;return 0>_&&(_=this.length.decode(f,w)),_}decode(f,w=0){let _=this.span;return 0>_&&(_=this.length.decode(f,w)),e(f).slice(w,w+_)}encode(f,w,_){let z=this.length;if(this.length instanceof o&&(z=f.length),!(f instanceof Uint8Array&&z===f.length))throw new TypeError(s("Blob.encode",this)+" requires (length "+z+") Uint8Array as src");if(_+z>w.length)throw new RangeError("encoding overruns Uint8Array");const G=e(f);return e(w).write(G.toString("hex"),_,z,"hex"),this.length instanceof o&&this.length.encode(z,w,_),z}}$.Blob=E;class T extends r{constructor(f){super(-1,f)}getSpan(f,w=0){t(f);let _=w;for(;_<f.length&&f[_]!==0;)_+=1;return 1+_-w}decode(f,w=0){const _=this.getSpan(f,w);return e(f).slice(w,w+_-1).toString("utf-8")}encode(f,w,_=0){typeof f!="string"&&(f=String(f));const z=n.Buffer.from(f,"utf8"),G=z.length;if(_+G>w.length)throw new RangeError("encoding overruns Buffer");const rt=e(w);return z.copy(rt,_),rt[_+G]=0,G+1}}$.CString=T;class C extends r{constructor(f,w){if(typeof f=="string"&&w===void 0&&(w=f,f=void 0),f===void 0)f=-1;else if(!Number.isInteger(f))throw new TypeError("maxSpan must be an integer");super(-1,w),this.maxSpan=f}getSpan(f,w=0){return t(f),f.length-w}decode(f,w=0){const _=this.getSpan(f,w);if(0<=this.maxSpan&&this.maxSpan<_)throw new RangeError("text length exceeds maxSpan");return e(f).slice(w,w+_).toString("utf-8")}encode(f,w,_=0){typeof f!="string"&&(f=String(f));const z=n.Buffer.from(f,"utf8"),G=z.length;if(0<=this.maxSpan&&this.maxSpan<G)throw new RangeError("text length exceeds maxSpan");if(_+G>w.length)throw new RangeError("encoding overruns Buffer");return z.copy(e(w),_),G}}$.UTF8=C;class k extends r{constructor(f,w){super(0,w),this.value=f}decode(f,w){return this.value}encode(f,w,_){return 0}}return $.Constant=k,$.greedy=((c,f)=>new u(c,f)),$.offset=((c,f,w)=>new d(c,f,w)),$.u8=(c=>new b(1,c)),$.u16=(c=>new b(2,c)),$.u24=(c=>new b(3,c)),$.u32=(c=>new b(4,c)),$.u40=(c=>new b(5,c)),$.u48=(c=>new b(6,c)),$.nu64=(c=>new L(c)),$.u16be=(c=>new I(2,c)),$.u24be=(c=>new I(3,c)),$.u32be=(c=>new I(4,c)),$.u40be=(c=>new I(5,c)),$.u48be=(c=>new I(6,c)),$.nu64be=(c=>new F(c)),$.s8=(c=>new B(1,c)),$.s16=(c=>new B(2,c)),$.s24=(c=>new B(3,c)),$.s32=(c=>new B(4,c)),$.s40=(c=>new B(5,c)),$.s48=(c=>new B(6,c)),$.ns64=(c=>new H(c)),$.s16be=(c=>new A(2,c)),$.s24be=(c=>new A(3,c)),$.s32be=(c=>new A(4,c)),$.s40be=(c=>new A(5,c)),$.s48be=(c=>new A(6,c)),$.ns64be=(c=>new K(c)),$.f32=(c=>new X(c)),$.f32be=(c=>new Y(c)),$.f64=(c=>new Q(c)),$.f64be=(c=>new ct(c)),$.struct=((c,f,w)=>new U(c,f,w)),$.bits=((c,f,w)=>new h(c,f,w)),$.seq=((c,f,w)=>new ot(c,f,w)),$.union=((c,f,w)=>new V(c,f,w)),$.unionLayoutDiscriminator=((c,f)=>new W(c,f)),$.blob=((c,f)=>new E(c,f)),$.cstr=(c=>new T(c)),$.utf8=((c,f)=>new C(c,f)),$.constant=((c,f)=>new k(c,f)),$}var P=ru(),nu=8078e3,iu=8078001,su=8078004,ou=8078005,au=8078006,cu=8078011;function Do(n){return Array.isArray(n)?"%5B"+n.map(Do).join("%2C%20")+"%5D":typeof n=="bigint"?`${n}n`:encodeURIComponent(String(n!=null&&Object.getPrototypeOf(n)===null?{...n}:n))}function uu([n,t]){return`${n}=${Do(t)}`}function fu(n){const t=Object.entries(n).map(uu).join("&");return btoa(t)}function lu(n,t={}){{let e=`Solana error #${n}; Decode this error by running \`npx @solana/errors decode -- ${n}`;return Object.keys(t).length&&(e+=` '${fu(t)}'`),`${e}\``}}var mr=class extends Error{cause=this.cause;context;constructor(...[n,t]){let e,r;if(t){const{cause:i,...o}=t;i&&(r={cause:i}),Object.keys(o).length>0&&(e=o)}const s=lu(n,e);super(s,r),this.context={__code:n,...e},this.name="SolanaError"}};function hu(n,t){return"fixedSize"in t?t.fixedSize:t.getSizeFromValue(n)}function du(n){return Object.freeze({...n,encode:t=>{const e=new Uint8Array(hu(t,n));return n.write(t,e,0),e}})}function pu(n){return Object.freeze({...n,decode:(t,e=0)=>n.read(t,e)[0]})}function gr(n){return"fixedSize"in n&&typeof n.fixedSize=="number"}function gu(n,t){if(gr(n)!==gr(t))throw new mr(su);if(gr(n)&&gr(t)&&n.fixedSize!==t.fixedSize)throw new mr(ou,{decoderFixedSize:t.fixedSize,encoderFixedSize:n.fixedSize});if(!gr(n)&&!gr(t)&&n.maxSize!==t.maxSize)throw new mr(au,{decoderMaxSize:t.maxSize,encoderMaxSize:n.maxSize});return{...t,...n,decode:t.decode,encode:n.encode,read:t.read,write:n.write}}function yu(n,t,e=0){if(t.length-e<=0)throw new mr(nu,{codecDescription:n})}function mu(n,t,e,r=0){const s=e.length-r;if(s<t)throw new mr(iu,{bytesLength:s,codecDescription:n,expected:t})}function wu(n,t,e,r){if(r<t||r>e)throw new mr(cu,{codecDescription:n,max:e,min:t,value:r})}function Wo(n){return n?.endian!==1}function bu(n){return du({fixedSize:n.size,write(t,e,r){n.range&&wu(n.name,n.range[0],n.range[1],t);const s=new ArrayBuffer(n.size);return n.set(new DataView(s),t,Wo(n.config)),e.set(new Uint8Array(s),r),r+n.size}})}function ku(n){return pu({fixedSize:n.size,read(t,e=0){yu(n.name,t,e),mu(n.name,n.size,t,e);const r=new DataView(vu(t,e,n.size));return[n.get(r,Wo(n.config)),e+n.size]}})}function vu(n,t,e){const r=n.byteOffset+(t??0),s=e??n.byteLength;return n.buffer.slice(r,r+s)}var $o=(n={})=>bu({config:n,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(t,e,r)=>t.setBigUint64(0,BigInt(e),r),size:8}),Su=(n={})=>ku({config:n,get:(t,e)=>t.getBigUint64(0,e),name:"u64",size:8}),xu=(n={})=>gu($o(n),Su(n));class Eu extends TypeError{constructor(t,e){let r;const{message:s,explanation:i,...o}=t,{path:u}=t,d=u.length===0?s:`At path: ${u.join(".")} -- ${s}`;super(i??d),i!=null&&(this.cause=d),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>r??(r=[t,...e()])}}function Iu(n){return qr(n)&&typeof n[Symbol.iterator]=="function"}function qr(n){return typeof n=="object"&&n!=null}function hn(n){return qr(n)&&!Array.isArray(n)}function Be(n){return typeof n=="symbol"?n.toString():typeof n=="string"?JSON.stringify(n):`${n}`}function _u(n){const{done:t,value:e}=n.next();return t?void 0:e}function Au(n,t,e,r){if(n===!0)return;n===!1?n={}:typeof n=="string"&&(n={message:n});const{path:s,branch:i}=t,{type:o}=e,{refinement:u,message:d=`Expected a value of type \`${o}\`${u?` with refinement \`${u}\``:""}, but received: \`${Be(r)}\``}=n;return{value:r,type:o,refinement:u,key:s[s.length-1],path:s,branch:i,...n,message:d}}function*Us(n,t,e,r){Iu(n)||(n=[n]);for(const s of n){const i=Au(s,t,e,r);i&&(yield i)}}function*qi(n,t,e={}){const{path:r=[],branch:s=[n],coerce:i=!1,mask:o=!1}=e,u={path:r,branch:s,mask:o};i&&(n=t.coercer(n,u));let d="valid";for(const b of t.validator(n,u))b.explanation=e.message,d="not_valid",yield[b,void 0];for(let[b,I,B]of t.entries(n,u)){const A=qi(I,B,{path:b===void 0?r:[...r,b],branch:b===void 0?s:[...s,I],coerce:i,mask:o,message:e.message});for(const S of A)S[0]?(d=S[0].refinement!=null?"not_refined":"not_valid",yield[S[0],void 0]):i&&(I=S[1],b===void 0?n=I:n instanceof Map?n.set(b,I):n instanceof Set?n.add(I):qr(n)&&(I!==void 0||b in n)&&(n[b]=I))}if(d!=="not_valid")for(const b of t.refiner(n,u))b.explanation=e.message,d="not_refined",yield[b,void 0];d==="valid"&&(yield[void 0,n])}let Ue=class{constructor(t){const{type:e,schema:r,validator:s,refiner:i,coercer:o=d=>d,entries:u=function*(){}}=t;this.type=e,this.schema=r,this.entries=u,this.coercer=o,s?this.validator=(d,b)=>{const I=s(d,b);return Us(I,b,this,d)}:this.validator=()=>[],i?this.refiner=(d,b)=>{const I=i(d,b);return Us(I,b,this,d)}:this.refiner=()=>[]}assert(t,e){return Vo(t,this,e)}create(t,e){return et(t,this,e)}is(t){return Ho(t,this)}mask(t,e){return Bu(t,this,e)}validate(t,e={}){return Dr(t,this,e)}};function Vo(n,t,e){const r=Dr(n,t,{message:e});if(r[0])throw r[0]}function et(n,t,e){const r=Dr(n,t,{coerce:!0,message:e});if(r[0])throw r[0];return r[1]}function Bu(n,t,e){const r=Dr(n,t,{coerce:!0,mask:!0,message:e});if(r[0])throw r[0];return r[1]}function Ho(n,t){return!Dr(n,t)[0]}function Dr(n,t,e={}){const r=qi(n,t,e),s=_u(r);return s[0]?[new Eu(s[0],function*(){for(const o of r)o[0]&&(yield o[0])}),void 0]:[void 0,s[1]]}function ur(n,t){return new Ue({type:n,schema:null,validator:t})}function Ru(){return ur("any",()=>!0)}function nt(n){return new Ue({type:"array",schema:n,*entries(t){if(n&&Array.isArray(t))for(const[e,r]of t.entries())yield[e,r,n]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||`Expected an array value, but received: ${Be(t)}`}})}function Le(){return ur("boolean",n=>typeof n=="boolean")}function Di(n){return ur("instance",t=>t instanceof n||`Expected a \`${n.name}\` instance, but received: ${Be(t)}`)}function Ut(n){const t=Be(n),e=typeof n;return new Ue({type:"literal",schema:e==="string"||e==="number"||e==="boolean"?n:null,validator(r){return r===n||`Expected the literal \`${t}\`, but received: ${Be(r)}`}})}function Mu(){return ur("never",()=>!1)}function it(n){return new Ue({...n,validator:(t,e)=>t===null||n.validator(t,e),refiner:(t,e)=>t===null||n.refiner(t,e)})}function D(){return ur("number",n=>typeof n=="number"&&!isNaN(n)||`Expected a number, but received: ${Be(n)}`)}function ut(n){return new Ue({...n,validator:(t,e)=>t===void 0||n.validator(t,e),refiner:(t,e)=>t===void 0||n.refiner(t,e)})}function jo(n,t){return new Ue({type:"record",schema:null,*entries(e){if(qr(e))for(const r in e){const s=e[r];yield[r,r,n],yield[r,s,t]}},validator(e){return hn(e)||`Expected an object, but received: ${Be(e)}`},coercer(e){return hn(e)?{...e}:e}})}function J(){return ur("string",n=>typeof n=="string"||`Expected a string, but received: ${Be(n)}`)}function Wi(n){const t=Mu();return new Ue({type:"tuple",schema:null,*entries(e){if(Array.isArray(e)){const r=Math.max(n.length,e.length);for(let s=0;s<r;s++)yield[s,e[s],n[s]||t]}},validator(e){return Array.isArray(e)||`Expected an array, but received: ${Be(e)}`},coercer(e){return Array.isArray(e)?e.slice():e}})}function Z(n){const t=Object.keys(n);return new Ue({type:"type",schema:n,*entries(e){if(qr(e))for(const r of t)yield[r,e[r],n[r]]},validator(e){return hn(e)||`Expected an object, but received: ${Be(e)}`},coercer(e){return hn(e)?{...e}:e}})}function be(n){const t=n.map(e=>e.type).join(" | ");return new Ue({type:"union",schema:null,coercer(e,r){for(const s of n){const[i,o]=s.validate(e,{coerce:!0,mask:r.mask});if(!i)return o}return e},validator(e,r){const s=[];for(const i of n){const[...o]=qi(e,i,r),[u]=o;if(u[0])for(const[d]of o)d&&s.push(d);else return[]}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${Be(e)}`,...s]}})}function _r(){return ur("unknown",()=>!0)}function Wr(n,t,e){return new Ue({...n,coercer:(r,s)=>Ho(r,t)?n.coercer(e(r,s),s):n.coercer(r,s)})}var Qr,Tu=new Uint8Array(16);function Go(){if(!Qr&&(Qr=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!Qr))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return Qr(Tu)}const Pu=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function Sn(n){return typeof n=="string"&&Pu.test(n)}var ue=[];for(var ai=0;ai<256;++ai)ue.push((ai+256).toString(16).substr(1));function xn(n){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,e=(ue[n[t+0]]+ue[n[t+1]]+ue[n[t+2]]+ue[n[t+3]]+"-"+ue[n[t+4]]+ue[n[t+5]]+"-"+ue[n[t+6]]+ue[n[t+7]]+"-"+ue[n[t+8]]+ue[n[t+9]]+"-"+ue[n[t+10]]+ue[n[t+11]]+ue[n[t+12]]+ue[n[t+13]]+ue[n[t+14]]+ue[n[t+15]]).toLowerCase();if(!Sn(e))throw TypeError("Stringified UUID is invalid");return e}var Os,ci,ui=0,fi=0;function Lu(n,t,e){var r=t&&e||0,s=t||new Array(16);n=n||{};var i=n.node||Os,o=n.clockseq!==void 0?n.clockseq:ci;if(i==null||o==null){var u=n.random||(n.rng||Go)();i==null&&(i=Os=[u[0]|1,u[1],u[2],u[3],u[4],u[5]]),o==null&&(o=ci=(u[6]<<8|u[7])&16383)}var d=n.msecs!==void 0?n.msecs:Date.now(),b=n.nsecs!==void 0?n.nsecs:fi+1,I=d-ui+(b-fi)/1e4;if(I<0&&n.clockseq===void 0&&(o=o+1&16383),(I<0||d>ui)&&n.nsecs===void 0&&(b=0),b>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");ui=d,fi=b,ci=o,d+=122192928e5;var B=((d&268435455)*1e4+b)%4294967296;s[r++]=B>>>24&255,s[r++]=B>>>16&255,s[r++]=B>>>8&255,s[r++]=B&255;var A=d/4294967296*1e4&268435455;s[r++]=A>>>8&255,s[r++]=A&255,s[r++]=A>>>24&15|16,s[r++]=A>>>16&255,s[r++]=o>>>8|128,s[r++]=o&255;for(var S=0;S<6;++S)s[r+S]=i[S];return t||xn(s)}function Zo(n){if(!Sn(n))throw TypeError("Invalid UUID");var t,e=new Uint8Array(16);return e[0]=(t=parseInt(n.slice(0,8),16))>>>24,e[1]=t>>>16&255,e[2]=t>>>8&255,e[3]=t&255,e[4]=(t=parseInt(n.slice(9,13),16))>>>8,e[5]=t&255,e[6]=(t=parseInt(n.slice(14,18),16))>>>8,e[7]=t&255,e[8]=(t=parseInt(n.slice(19,23),16))>>>8,e[9]=t&255,e[10]=(t=parseInt(n.slice(24,36),16))/1099511627776&255,e[11]=t/4294967296&255,e[12]=t>>>24&255,e[13]=t>>>16&255,e[14]=t>>>8&255,e[15]=t&255,e}function Cu(n){n=unescape(encodeURIComponent(n));for(var t=[],e=0;e<n.length;++e)t.push(n.charCodeAt(e));return t}var Uu="6ba7b810-9dad-11d1-80b4-00c04fd430c8",Ou="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function Yo(n,t,e){function r(s,i,o,u){if(typeof s=="string"&&(s=Cu(s)),typeof i=="string"&&(i=Zo(i)),i.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var d=new Uint8Array(16+s.length);if(d.set(i),d.set(s,i.length),d=e(d),d[6]=d[6]&15|t,d[8]=d[8]&63|128,o){u=u||0;for(var b=0;b<16;++b)o[u+b]=d[b];return o}return xn(d)}try{r.name=n}catch{}return r.DNS=Uu,r.URL=Ou,r}function Nu(n){if(typeof n=="string"){var t=unescape(encodeURIComponent(n));n=new Uint8Array(t.length);for(var e=0;e<t.length;++e)n[e]=t.charCodeAt(e)}return Fu(zu(Ku(n),n.length*8))}function Fu(n){for(var t=[],e=n.length*32,r="0123456789abcdef",s=0;s<e;s+=8){var i=n[s>>5]>>>s%32&255,o=parseInt(r.charAt(i>>>4&15)+r.charAt(i&15),16);t.push(o)}return t}function Xo(n){return(n+64>>>9<<4)+14+1}function zu(n,t){n[t>>5]|=128<<t%32,n[Xo(t)-1]=t;for(var e=1732584193,r=-271733879,s=-1732584194,i=271733878,o=0;o<n.length;o+=16){var u=e,d=r,b=s,I=i;e=ge(e,r,s,i,n[o],7,-680876936),i=ge(i,e,r,s,n[o+1],12,-389564586),s=ge(s,i,e,r,n[o+2],17,606105819),r=ge(r,s,i,e,n[o+3],22,-1044525330),e=ge(e,r,s,i,n[o+4],7,-176418897),i=ge(i,e,r,s,n[o+5],12,1200080426),s=ge(s,i,e,r,n[o+6],17,-1473231341),r=ge(r,s,i,e,n[o+7],22,-45705983),e=ge(e,r,s,i,n[o+8],7,1770035416),i=ge(i,e,r,s,n[o+9],12,-1958414417),s=ge(s,i,e,r,n[o+10],17,-42063),r=ge(r,s,i,e,n[o+11],22,-1990404162),e=ge(e,r,s,i,n[o+12],7,1804603682),i=ge(i,e,r,s,n[o+13],12,-40341101),s=ge(s,i,e,r,n[o+14],17,-1502002290),r=ge(r,s,i,e,n[o+15],22,1236535329),e=ye(e,r,s,i,n[o+1],5,-165796510),i=ye(i,e,r,s,n[o+6],9,-1069501632),s=ye(s,i,e,r,n[o+11],14,643717713),r=ye(r,s,i,e,n[o],20,-373897302),e=ye(e,r,s,i,n[o+5],5,-701558691),i=ye(i,e,r,s,n[o+10],9,38016083),s=ye(s,i,e,r,n[o+15],14,-660478335),r=ye(r,s,i,e,n[o+4],20,-405537848),e=ye(e,r,s,i,n[o+9],5,568446438),i=ye(i,e,r,s,n[o+14],9,-1019803690),s=ye(s,i,e,r,n[o+3],14,-187363961),r=ye(r,s,i,e,n[o+8],20,1163531501),e=ye(e,r,s,i,n[o+13],5,-1444681467),i=ye(i,e,r,s,n[o+2],9,-51403784),s=ye(s,i,e,r,n[o+7],14,1735328473),r=ye(r,s,i,e,n[o+12],20,-1926607734),e=me(e,r,s,i,n[o+5],4,-378558),i=me(i,e,r,s,n[o+8],11,-2022574463),s=me(s,i,e,r,n[o+11],16,1839030562),r=me(r,s,i,e,n[o+14],23,-35309556),e=me(e,r,s,i,n[o+1],4,-1530992060),i=me(i,e,r,s,n[o+4],11,1272893353),s=me(s,i,e,r,n[o+7],16,-155497632),r=me(r,s,i,e,n[o+10],23,-1094730640),e=me(e,r,s,i,n[o+13],4,681279174),i=me(i,e,r,s,n[o],11,-358537222),s=me(s,i,e,r,n[o+3],16,-722521979),r=me(r,s,i,e,n[o+6],23,76029189),e=me(e,r,s,i,n[o+9],4,-640364487),i=me(i,e,r,s,n[o+12],11,-421815835),s=me(s,i,e,r,n[o+15],16,530742520),r=me(r,s,i,e,n[o+2],23,-995338651),e=we(e,r,s,i,n[o],6,-198630844),i=we(i,e,r,s,n[o+7],10,1126891415),s=we(s,i,e,r,n[o+14],15,-1416354905),r=we(r,s,i,e,n[o+5],21,-57434055),e=we(e,r,s,i,n[o+12],6,1700485571),i=we(i,e,r,s,n[o+3],10,-1894986606),s=we(s,i,e,r,n[o+10],15,-1051523),r=we(r,s,i,e,n[o+1],21,-2054922799),e=we(e,r,s,i,n[o+8],6,1873313359),i=we(i,e,r,s,n[o+15],10,-30611744),s=we(s,i,e,r,n[o+6],15,-1560198380),r=we(r,s,i,e,n[o+13],21,1309151649),e=we(e,r,s,i,n[o+4],6,-145523070),i=we(i,e,r,s,n[o+11],10,-1120210379),s=we(s,i,e,r,n[o+2],15,718787259),r=we(r,s,i,e,n[o+9],21,-343485551),e=Je(e,u),r=Je(r,d),s=Je(s,b),i=Je(i,I)}return[e,r,s,i]}function Ku(n){if(n.length===0)return[];for(var t=n.length*8,e=new Uint32Array(Xo(t)),r=0;r<t;r+=8)e[r>>5]|=(n[r/8]&255)<<r%32;return e}function Je(n,t){var e=(n&65535)+(t&65535),r=(n>>16)+(t>>16)+(e>>16);return r<<16|e&65535}function qu(n,t){return n<<t|n>>>32-t}function En(n,t,e,r,s,i){return Je(qu(Je(Je(t,n),Je(r,i)),s),e)}function ge(n,t,e,r,s,i,o){return En(t&e|~t&r,n,t,s,i,o)}function ye(n,t,e,r,s,i,o){return En(t&r|e&~r,n,t,s,i,o)}function me(n,t,e,r,s,i,o){return En(t^e^r,n,t,s,i,o)}function we(n,t,e,r,s,i,o){return En(e^(t|~r),n,t,s,i,o)}var Du=Yo("v3",48,Nu);function Wu(n,t,e){n=n||{};var r=n.random||(n.rng||Go)();if(r[6]=r[6]&15|64,r[8]=r[8]&63|128,t){e=e||0;for(var s=0;s<16;++s)t[e+s]=r[s];return t}return xn(r)}function $u(n,t,e,r){switch(n){case 0:return t&e^~t&r;case 1:return t^e^r;case 2:return t&e^t&r^e&r;case 3:return t^e^r}}function li(n,t){return n<<t|n>>>32-t}function Vu(n){var t=[1518500249,1859775393,2400959708,3395469782],e=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof n=="string"){var r=unescape(encodeURIComponent(n));n=[];for(var s=0;s<r.length;++s)n.push(r.charCodeAt(s))}else Array.isArray(n)||(n=Array.prototype.slice.call(n));n.push(128);for(var i=n.length/4+2,o=Math.ceil(i/16),u=new Array(o),d=0;d<o;++d){for(var b=new Uint32Array(16),I=0;I<16;++I)b[I]=n[d*64+I*4]<<24|n[d*64+I*4+1]<<16|n[d*64+I*4+2]<<8|n[d*64+I*4+3];u[d]=b}u[o-1][14]=(n.length-1)*8/Math.pow(2,32),u[o-1][14]=Math.floor(u[o-1][14]),u[o-1][15]=(n.length-1)*8&4294967295;for(var B=0;B<o;++B){for(var A=new Uint32Array(80),S=0;S<16;++S)A[S]=u[B][S];for(var M=16;M<80;++M)A[M]=li(A[M-3]^A[M-8]^A[M-14]^A[M-16],1);for(var R=e[0],L=e[1],F=e[2],H=e[3],K=e[4],X=0;X<80;++X){var Y=Math.floor(X/20),Q=li(R,5)+$u(Y,L,F,H)+K+t[Y]+A[X]>>>0;K=H,H=F,F=li(L,30)>>>0,L=R,R=Q}e[0]=e[0]+R>>>0,e[1]=e[1]+L>>>0,e[2]=e[2]+F>>>0,e[3]=e[3]+H>>>0,e[4]=e[4]+K>>>0}return[e[0]>>24&255,e[0]>>16&255,e[0]>>8&255,e[0]&255,e[1]>>24&255,e[1]>>16&255,e[1]>>8&255,e[1]&255,e[2]>>24&255,e[2]>>16&255,e[2]>>8&255,e[2]&255,e[3]>>24&255,e[3]>>16&255,e[3]>>8&255,e[3]&255,e[4]>>24&255,e[4]>>16&255,e[4]>>8&255,e[4]&255]}var Hu=Yo("v5",80,Vu);const ju="00000000-0000-0000-0000-000000000000";function Gu(n){if(!Sn(n))throw TypeError("Invalid UUID");return parseInt(n.substr(14,1),16)}const Zu=Object.freeze(Object.defineProperty({__proto__:null,NIL:ju,parse:Zo,stringify:xn,v1:Lu,v3:Du,v4:Wu,v5:Hu,validate:Sn,version:Gu},Symbol.toStringTag,{value:"Module"})),Jo=Ti(Zu);var hi,Ns;function Yu(){if(Ns)return hi;Ns=1;const n=Jo.v4;return hi=function(e,r,s,i){if(typeof e!="string")throw new TypeError(e+" must be a string");i=i||{};const o=typeof i.version=="number"?i.version:2;if(o!==1&&o!==2)throw new TypeError(o+" must be 1 or 2");const u={method:e};if(o===2&&(u.jsonrpc="2.0"),r){if(typeof r!="object"&&!Array.isArray(r))throw new TypeError(r+" must be an object, array or omitted");u.params=r}if(typeof s>"u"){const d=typeof i.generator=="function"?i.generator:function(){return n()};u.id=d(u,i)}else o===2&&s===null?i.notificationIdNull&&(u.id=null):u.id=s;return u},hi}var di,Fs;function Xu(){if(Fs)return di;Fs=1;const n=Jo.v4,t=Yu(),e=function(r,s){if(!(this instanceof e))return new e(r,s);s||(s={}),this.options={reviver:typeof s.reviver<"u"?s.reviver:null,replacer:typeof s.replacer<"u"?s.replacer:null,generator:typeof s.generator<"u"?s.generator:function(){return n()},version:typeof s.version<"u"?s.version:2,notificationIdNull:typeof s.notificationIdNull=="boolean"?s.notificationIdNull:!1},this.callServer=r};return di=e,e.prototype.request=function(r,s,i,o){const u=this;let d=null;const b=Array.isArray(r)&&typeof s=="function";if(this.options.version===1&&b)throw new TypeError("JSON-RPC 1.0 does not support batching");if(b||!b&&r&&typeof r=="object"&&typeof s=="function")o=s,d=r;else{typeof i=="function"&&(o=i,i=void 0);const A=typeof o=="function";try{d=t(r,s,i,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(S){if(A)return o(S);throw S}if(!A)return d}let B;try{B=JSON.stringify(d,this.options.replacer)}catch(A){return o(A)}return this.callServer(B,function(A,S){u._parseResponse(A,S,o)}),d},e.prototype._parseResponse=function(r,s,i){if(r){i(r);return}if(!s)return i();let o;try{o=JSON.parse(s,this.options.reviver)}catch(u){return i(u)}if(i.length===3)if(Array.isArray(o)){const u=function(b){return typeof b.error<"u"},d=function(b){return!u(b)};return i(null,o.filter(u),o.filter(d))}else return i(null,o.error,o.result);i(null,o)},di}var Ju=Xu();const Qu=wn(Ju);var pi={exports:{}},zs;function tf(){return zs||(zs=1,(function(n){var t=Object.prototype.hasOwnProperty,e="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(e=!1));function s(d,b,I){this.fn=d,this.context=b,this.once=I||!1}function i(d,b,I,B,A){if(typeof I!="function")throw new TypeError("The listener must be a function");var S=new s(I,B||d,A),M=e?e+b:b;return d._events[M]?d._events[M].fn?d._events[M]=[d._events[M],S]:d._events[M].push(S):(d._events[M]=S,d._eventsCount++),d}function o(d,b){--d._eventsCount===0?d._events=new r:delete d._events[b]}function u(){this._events=new r,this._eventsCount=0}u.prototype.eventNames=function(){var b=[],I,B;if(this._eventsCount===0)return b;for(B in I=this._events)t.call(I,B)&&b.push(e?B.slice(1):B);return Object.getOwnPropertySymbols?b.concat(Object.getOwnPropertySymbols(I)):b},u.prototype.listeners=function(b){var I=e?e+b:b,B=this._events[I];if(!B)return[];if(B.fn)return[B.fn];for(var A=0,S=B.length,M=new Array(S);A<S;A++)M[A]=B[A].fn;return M},u.prototype.listenerCount=function(b){var I=e?e+b:b,B=this._events[I];return B?B.fn?1:B.length:0},u.prototype.emit=function(b,I,B,A,S,M){var R=e?e+b:b;if(!this._events[R])return!1;var L=this._events[R],F=arguments.length,H,K;if(L.fn){switch(L.once&&this.removeListener(b,L.fn,void 0,!0),F){case 1:return L.fn.call(L.context),!0;case 2:return L.fn.call(L.context,I),!0;case 3:return L.fn.call(L.context,I,B),!0;case 4:return L.fn.call(L.context,I,B,A),!0;case 5:return L.fn.call(L.context,I,B,A,S),!0;case 6:return L.fn.call(L.context,I,B,A,S,M),!0}for(K=1,H=new Array(F-1);K<F;K++)H[K-1]=arguments[K];L.fn.apply(L.context,H)}else{var X=L.length,Y;for(K=0;K<X;K++)switch(L[K].once&&this.removeListener(b,L[K].fn,void 0,!0),F){case 1:L[K].fn.call(L[K].context);break;case 2:L[K].fn.call(L[K].context,I);break;case 3:L[K].fn.call(L[K].context,I,B);break;case 4:L[K].fn.call(L[K].context,I,B,A);break;default:if(!H)for(Y=1,H=new Array(F-1);Y<F;Y++)H[Y-1]=arguments[Y];L[K].fn.apply(L[K].context,H)}}return!0},u.prototype.on=function(b,I,B){return i(this,b,I,B,!1)},u.prototype.once=function(b,I,B){return i(this,b,I,B,!0)},u.prototype.removeListener=function(b,I,B,A){var S=e?e+b:b;if(!this._events[S])return this;if(!I)return o(this,S),this;var M=this._events[S];if(M.fn)M.fn===I&&(!A||M.once)&&(!B||M.context===B)&&o(this,S);else{for(var R=0,L=[],F=M.length;R<F;R++)(M[R].fn!==I||A&&!M[R].once||B&&M[R].context!==B)&&L.push(M[R]);L.length?this._events[S]=L.length===1?L[0]:L:o(this,S)}return this},u.prototype.removeAllListeners=function(b){var I;return b?(I=e?e+b:b,this._events[I]&&o(this,I)):(this._events=new r,this._eventsCount=0),this},u.prototype.off=u.prototype.removeListener,u.prototype.addListener=u.prototype.on,u.prefixed=e,u.EventEmitter=u,n.exports=u})(pi)),pi.exports}var ef=tf();const Qo=wn(ef);var rf=class extends Qo{socket;constructor(n,t,e){super(),this.socket=new window.WebSocket(n,e),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=r=>this.emit("message",r.data),this.socket.onerror=r=>this.emit("error",r),this.socket.onclose=r=>{this.emit("close",r.code,r.reason)}}send(n,t,e){const r=e||t;try{this.socket.send(n),r()}catch(s){r(s)}}close(n,t){this.socket.close(n,t)}addEventListener(n,t,e){this.socket.addEventListener(n,t,e)}};function nf(n,t){return new rf(n,t)}var sf=class{encode(n){return JSON.stringify(n)}decode(n){return JSON.parse(n)}},of=class extends Qo{address;rpc_id;queue;options;autoconnect;ready;reconnect;reconnect_timer_id;reconnect_interval;max_reconnects;rest_options;current_reconnects;generate_request_id;socket;webSocketFactory;dataPack;constructor(n,t="ws://localhost:8080",{autoconnect:e=!0,reconnect:r=!0,reconnect_interval:s=1e3,max_reconnects:i=5,...o}={},u,d){super(),this.webSocketFactory=n,this.queue={},this.rpc_id=0,this.address=t,this.autoconnect=e,this.ready=!1,this.reconnect=r,this.reconnect_timer_id=void 0,this.reconnect_interval=s,this.max_reconnects=i,this.rest_options=o,this.current_reconnects=0,this.generate_request_id=u||(()=>typeof this.rpc_id=="number"?++this.rpc_id:Number(this.rpc_id)+1),d?this.dataPack=d:this.dataPack=new sf,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(n,t,e,r){return!r&&typeof e=="object"&&(r=e,e=null),new Promise((s,i)=>{if(!this.ready)return i(new Error("socket not ready"));const o=this.generate_request_id(n,t),u={jsonrpc:"2.0",method:n,params:t||void 0,id:o};this.socket.send(this.dataPack.encode(u),r,d=>{if(d)return i(d);this.queue[o]={promise:[s,i]},e&&(this.queue[o].timeout=setTimeout(()=>{delete this.queue[o],i(new Error("reply timeout"))},e))})})}async login(n){const t=await this.call("rpc.login",n);if(!t)throw new Error("authentication failed");return t}async listMethods(){return await this.call("__listMethods")}notify(n,t){return new Promise((e,r)=>{if(!this.ready)return r(new Error("socket not ready"));const s={jsonrpc:"2.0",method:n,params:t};this.socket.send(this.dataPack.encode(s),i=>{if(i)return r(i);e()})})}async subscribe(n){typeof n=="string"&&(n=[n]);const t=await this.call("rpc.on",n);if(typeof n=="string"&&t[n]!=="ok")throw new Error("Failed subscribing to an event '"+n+"' with: "+t[n]);return t}async unsubscribe(n){typeof n=="string"&&(n=[n]);const t=await this.call("rpc.off",n);if(typeof n=="string"&&t[n]!=="ok")throw new Error("Failed unsubscribing from an event with: "+t);return t}close(n,t){this.socket.close(n||1e3,t)}setAutoReconnect(n){this.reconnect=n}setReconnectInterval(n){this.reconnect_interval=n}setMaxReconnects(n){this.max_reconnects=n}_connect(n,t){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(n,t),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:e})=>{e instanceof ArrayBuffer&&(e=ft.Buffer.from(e).toString());try{e=this.dataPack.decode(e)}catch{return}if(e.notification&&this.listeners(e.notification).length){if(!Object.keys(e.params).length)return this.emit(e.notification);const r=[e.notification];if(e.params.constructor===Object)r.push(e.params);else for(let s=0;s<e.params.length;s++)r.push(e.params[s]);return Promise.resolve().then(()=>{this.emit.apply(this,r)})}if(!this.queue[e.id])return e.method?Promise.resolve().then(()=>{this.emit(e.method,e?.params)}):void 0;"error"in e=="result"in e&&this.queue[e.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[e.id].timeout&&clearTimeout(this.queue[e.id].timeout),e.error?this.queue[e.id].promise[1](e.error):this.queue[e.id].promise[0](e.result),delete this.queue[e.id]}),this.socket.addEventListener("error",e=>this.emit("error",e)),this.socket.addEventListener("close",({code:e,reason:r})=>{this.ready&&setTimeout(()=>this.emit("close",e,r),0),this.ready=!1,this.socket=void 0,e!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)&&(this.reconnect_timer_id=setTimeout(()=>this._connect(n,t),this.reconnect_interval)))})}};const af=BigInt(0),Rr=BigInt(1),cf=BigInt(2),uf=BigInt(7),ff=BigInt(256),lf=BigInt(113),ta=[],ea=[],ra=[];for(let n=0,t=Rr,e=1,r=0;n<24;n++){[e,r]=[r,(2*e+3*r)%5],ta.push(2*(5*r+e)),ea.push((n+1)*(n+2)/2%64);let s=af;for(let i=0;i<7;i++)t=(t<<Rr^(t>>uf)*lf)%ff,t&cf&&(s^=Rr<<(Rr<<BigInt(i))-Rr);ra.push(s)}const na=mo(ra,!0),hf=na[0],df=na[1],Ks=(n,t,e)=>e>32?Za(n,t,e):ja(n,t,e),qs=(n,t,e)=>e>32?Ya(n,t,e):Ga(n,t,e);function pf(n,t=24){const e=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let o=0;o<10;o++)e[o]=n[o]^n[o+10]^n[o+20]^n[o+30]^n[o+40];for(let o=0;o<10;o+=2){const u=(o+8)%10,d=(o+2)%10,b=e[d],I=e[d+1],B=Ks(b,I,1)^e[u],A=qs(b,I,1)^e[u+1];for(let S=0;S<50;S+=10)n[o+S]^=B,n[o+S+1]^=A}let s=n[2],i=n[3];for(let o=0;o<24;o++){const u=ea[o],d=Ks(s,i,u),b=qs(s,i,u),I=ta[o];s=n[I],i=n[I+1],n[I]=d,n[I+1]=b}for(let o=0;o<50;o+=10){for(let u=0;u<10;u++)e[u]=n[o+u];for(let u=0;u<10;u++)n[o+u]^=~e[(u+2)%10]&e[(u+4)%10]}n[0]^=hf[r],n[1]^=df[r]}Qe(e)}class $i extends Li{constructor(t,e,r,s=!1,i=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=s,this.rounds=i,Cr(r),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=Na(this.state)}clone(){return this._cloneInto()}keccak(){hs(this.state32),pf(this.state32,this.rounds),hs(this.state32),this.posOut=0,this.pos=0}update(t){br(this),t=bn(t),$e(t);const{blockLen:e,state:r}=this,s=t.length;for(let i=0;i<s;){const o=Math.min(e-this.pos,s-i);for(let u=0;u<o;u++)r[this.pos++]^=t[i++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:r,blockLen:s}=this;t[r]^=e,(e&128)!==0&&r===s-1&&this.keccak(),t[s-1]^=128,this.keccak()}writeInto(t){br(this,!1),$e(t),this.finish();const e=this.state,{blockLen:r}=this;for(let s=0,i=t.length;s<i;){this.posOut>=r&&this.keccak();const o=Math.min(r-this.posOut,i-s);t.set(e.subarray(this.posOut,this.posOut+o),s),this.posOut+=o,s+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return Cr(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(po(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,Qe(this.state)}_cloneInto(t){const{blockLen:e,suffix:r,outputLen:s,rounds:i,enableXOF:o}=this;return t||(t=new $i(e,r,s,o,i)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=i,t.suffix=r,t.outputLen=s,t.enableXOF=o,t.destroyed=this.destroyed,t}}const gf=(n,t,e)=>Ci(()=>new $i(t,n,e)),Ds=gf(1,136,256/8);class ia extends Li{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,ho(t);const r=bn(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?t.create().update(r).digest():r);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=t.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),Qe(i)}update(t){return br(this),this.iHash.update(t),this}digestInto(t){br(this),$e(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:u}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=o,t.outputLen=u,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const sa=(n,t,e)=>new ia(n,t).update(e).digest();sa.create=(n,t)=>new ia(n,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ws=(n,t)=>(n+(n>=0?t:-t)/oa)/t;function yf(n,t,e){const[[r,s],[i,o]]=t,u=Ws(o*n,e),d=Ws(-s*n,e);let b=n-u*r-d*i,I=-u*s-d*o;const B=b<De,A=I<De;B&&(b=-b),A&&(I=-I);const S=zr(Math.ceil(So(e)/2))+wr;if(b<De||b>=S||I<De||I>=S)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:B,k1:b,k2neg:A,k2:I}}function _i(n){if(!["compact","recovered","der"].includes(n))throw new Error('Signature format must be "compact", "recovered", or "der"');return n}function gi(n,t){const e={};for(let r of Object.keys(t))e[r]=n[r]===void 0?t[r]:n[r];return ar(e.lowS,"lowS"),ar(e.prehash,"prehash"),e.format!==void 0&&_i(e.format),e}class mf extends Error{constructor(t=""){super(t)}}const Fe={Err:mf,_tlv:{encode:(n,t)=>{const{Err:e}=Fe;if(n<0||n>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const r=t.length/2,s=Xr(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=r>127?Xr(s.length/2|128):"";return Xr(n)+i+s+t},decode(n,t){const{Err:e}=Fe;let r=0;if(n<0||n>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[r++]!==n)throw new e("tlv.decode: wrong tlv");const s=t[r++],i=!!(s&128);let o=0;if(!i)o=s;else{const d=s&127;if(!d)throw new e("tlv.decode(long): indefinite length not supported");if(d>4)throw new e("tlv.decode(long): byte length is too big");const b=t.subarray(r,r+d);if(b.length!==d)throw new e("tlv.decode: length bytes not complete");if(b[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const I of b)o=o<<8|I;if(r+=d,o<128)throw new e("tlv.decode(long): not minimal encoding")}const u=t.subarray(r,r+o);if(u.length!==o)throw new e("tlv.decode: wrong value length");return{v:u,l:t.subarray(r+o)}}},_int:{encode(n){const{Err:t}=Fe;if(n<De)throw new t("integer: negative integers are not allowed");let e=Xr(n);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(n){const{Err:t}=Fe;if(n[0]&128)throw new t("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return kn(n)}},toSig(n){const{Err:t,_int:e,_tlv:r}=Fe,s=Dt("signature",n),{v:i,l:o}=r.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:u,l:d}=r.decode(2,i),{v:b,l:I}=r.decode(2,d);if(I.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(u),s:e.decode(b)}},hexFromSig(n){const{_tlv:t,_int:e}=Fe,r=t.encode(2,e.encode(n.r)),s=t.encode(2,e.encode(n.s)),i=r+s;return t.encode(48,i)}},De=BigInt(0),wr=BigInt(1),oa=BigInt(2),tn=BigInt(3),wf=BigInt(4);function yr(n,t){const{BYTES:e}=n;let r;if(typeof t=="bigint")r=t;else{let s=Dt("private key",t);try{r=n.fromBytes(s)}catch{throw new Error(`invalid private key: expected ui8a of size ${e}, got ${typeof t}`)}}if(!n.isValidNot0(r))throw new Error("invalid private key: out of range [1..N-1]");return r}function bf(n,t={}){const e=Fo("weierstrass",n,t),{Fp:r,Fn:s}=e;let i=e.CURVE;const{h:o,n:u}=i;Kr(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:d}=t;if(d&&(!r.is0(i.a)||typeof d.beta!="bigint"||!Array.isArray(d.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const b=ca(r,s);function I(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function B(V,y,a){const{x:h,y:g}=y.toAffine(),v=r.toBytes(h);if(ar(a,"isCompressed"),a){I();const E=!r.isOdd(g);return Me(aa(E),v)}else return Me(Uint8Array.of(4),v,r.toBytes(g))}function A(V){Ae(V,void 0,"Point");const{publicKey:y,publicKeyUncompressed:a}=b,h=V.length,g=V[0],v=V.subarray(1);if(h===y&&(g===2||g===3)){const E=r.fromBytes(v);if(!r.isValid(E))throw new Error("bad point: is not on curve, wrong x");const T=R(E);let C;try{C=r.sqrt(T)}catch(f){const w=f instanceof Error?": "+f.message:"";throw new Error("bad point: is not on curve, sqrt error"+w)}I();const k=r.isOdd(C);return(g&1)===1!==k&&(C=r.neg(C)),{x:E,y:C}}else if(h===a&&g===4){const E=r.BYTES,T=r.fromBytes(v.subarray(0,E)),C=r.fromBytes(v.subarray(E,E*2));if(!L(T,C))throw new Error("bad point: is not on curve");return{x:T,y:C}}else throw new Error(`bad point: got length ${h}, expected compressed=${y} or uncompressed=${a}`)}const S=t.toBytes||B,M=t.fromBytes||A;function R(V){const y=r.sqr(V),a=r.mul(y,V);return r.add(r.add(a,r.mul(V,i.a)),i.b)}function L(V,y){const a=r.sqr(y),h=R(V);return r.eql(a,h)}if(!L(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const F=r.mul(r.pow(i.a,tn),wf),H=r.mul(r.sqr(i.b),BigInt(27));if(r.is0(r.add(F,H)))throw new Error("bad curve params: a or b");function K(V,y,a=!1){if(!r.isValid(y)||a&&r.is0(y))throw new Error(`bad point coordinate ${V}`);return y}function X(V){if(!(V instanceof U))throw new Error("ProjectivePoint expected")}function Y(V){if(!d||!d.basises)throw new Error("no endo");return yf(V,d.basises,s.ORDER)}const Q=on((V,y)=>{const{X:a,Y:h,Z:g}=V;if(r.eql(g,r.ONE))return{x:a,y:h};const v=V.is0();y==null&&(y=v?r.ONE:r.inv(g));const E=r.mul(a,y),T=r.mul(h,y),C=r.mul(g,y);if(v)return{x:r.ZERO,y:r.ZERO};if(!r.eql(C,r.ONE))throw new Error("invZ was invalid");return{x:E,y:T}}),ct=on(V=>{if(V.is0()){if(t.allowInfinityPoint&&!r.is0(V.Y))return;throw new Error("bad point: ZERO")}const{x:y,y:a}=V.toAffine();if(!r.isValid(y)||!r.isValid(a))throw new Error("bad point: x or y not field elements");if(!L(y,a))throw new Error("bad point: equation left != right");if(!V.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function ot(V,y,a,h,g){return a=new U(r.mul(a.X,V),a.Y,a.Z),y=an(h,y),a=an(g,a),y.add(a)}class U{constructor(y,a,h){this.X=K("x",y),this.Y=K("y",a,!0),this.Z=K("z",h),Object.freeze(this)}static CURVE(){return i}static fromAffine(y){const{x:a,y:h}=y||{};if(!y||!r.isValid(a)||!r.isValid(h))throw new Error("invalid affine point");if(y instanceof U)throw new Error("projective point not allowed");return r.is0(a)&&r.is0(h)?U.ZERO:new U(a,h,r.ONE)}static fromBytes(y){const a=U.fromAffine(M(Ae(y,void 0,"point")));return a.assertValidity(),a}static fromHex(y){return U.fromBytes(Dt("pointHex",y))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(y=8,a=!0){return W.createCache(this,y),a||this.multiply(tn),this}assertValidity(){ct(this)}hasEvenY(){const{y}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(y)}equals(y){X(y);const{X:a,Y:h,Z:g}=this,{X:v,Y:E,Z:T}=y,C=r.eql(r.mul(a,T),r.mul(v,g)),k=r.eql(r.mul(h,T),r.mul(E,g));return C&&k}negate(){return new U(this.X,r.neg(this.Y),this.Z)}double(){const{a:y,b:a}=i,h=r.mul(a,tn),{X:g,Y:v,Z:E}=this;let T=r.ZERO,C=r.ZERO,k=r.ZERO,c=r.mul(g,g),f=r.mul(v,v),w=r.mul(E,E),_=r.mul(g,v);return _=r.add(_,_),k=r.mul(g,E),k=r.add(k,k),T=r.mul(y,k),C=r.mul(h,w),C=r.add(T,C),T=r.sub(f,C),C=r.add(f,C),C=r.mul(T,C),T=r.mul(_,T),k=r.mul(h,k),w=r.mul(y,w),_=r.sub(c,w),_=r.mul(y,_),_=r.add(_,k),k=r.add(c,c),c=r.add(k,c),c=r.add(c,w),c=r.mul(c,_),C=r.add(C,c),w=r.mul(v,E),w=r.add(w,w),c=r.mul(w,_),T=r.sub(T,c),k=r.mul(w,f),k=r.add(k,k),k=r.add(k,k),new U(T,C,k)}add(y){X(y);const{X:a,Y:h,Z:g}=this,{X:v,Y:E,Z:T}=y;let C=r.ZERO,k=r.ZERO,c=r.ZERO;const f=i.a,w=r.mul(i.b,tn);let _=r.mul(a,v),z=r.mul(h,E),G=r.mul(g,T),rt=r.add(a,h),st=r.add(v,E);rt=r.mul(rt,st),st=r.add(_,z),rt=r.sub(rt,st),st=r.add(a,g);let kt=r.add(v,T);return st=r.mul(st,kt),kt=r.add(_,G),st=r.sub(st,kt),kt=r.add(h,g),C=r.add(E,T),kt=r.mul(kt,C),C=r.add(z,G),kt=r.sub(kt,C),c=r.mul(f,st),C=r.mul(w,G),c=r.add(C,c),C=r.sub(z,c),c=r.add(z,c),k=r.mul(C,c),z=r.add(_,_),z=r.add(z,_),G=r.mul(f,G),st=r.mul(w,st),z=r.add(z,G),G=r.sub(_,G),G=r.mul(f,G),st=r.add(st,G),_=r.mul(z,st),k=r.add(k,_),_=r.mul(kt,st),C=r.mul(rt,C),C=r.sub(C,_),_=r.mul(rt,z),c=r.mul(kt,c),c=r.add(c,_),new U(C,k,c)}subtract(y){return this.add(y.negate())}is0(){return this.equals(U.ZERO)}multiply(y){const{endo:a}=t;if(!s.isValidNot0(y))throw new Error("invalid scalar: out of range");let h,g;const v=E=>W.cached(this,E,T=>nr(U,T));if(a){const{k1neg:E,k1:T,k2neg:C,k2:k}=Y(y),{p:c,f}=v(T),{p:w,f:_}=v(k);g=f.add(_),h=ot(a.beta,c,w,E,C)}else{const{p:E,f:T}=v(y);h=E,g=T}return nr(U,[h,g])[0]}multiplyUnsafe(y){const{endo:a}=t,h=this;if(!s.isValid(y))throw new Error("invalid scalar: out of range");if(y===De||h.is0())return U.ZERO;if(y===wr)return h;if(W.hasCache(this))return this.multiply(y);if(a){const{k1neg:g,k1:v,k2neg:E,k2:T}=Y(y),{p1:C,p2:k}=xc(U,h,v,T);return ot(a.beta,C,k,g,E)}else return W.unsafe(h,y)}multiplyAndAddUnsafe(y,a,h){const g=this.multiplyUnsafe(a).add(y.multiplyUnsafe(h));return g.is0()?void 0:g}toAffine(y){return Q(this,y)}isTorsionFree(){const{isTorsionFree:y}=t;return o===wr?!0:y?y(U,this):W.unsafe(this,u).is0()}clearCofactor(){const{clearCofactor:y}=t;return o===wr?this:y?y(U,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(y=!0){return ar(y,"isCompressed"),this.assertValidity(),S(U,this,y)}toHex(y=!0){return sr(this.toBytes(y))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(y=!0){return this.toBytes(y)}_setWindowSize(y){this.precompute(y)}static normalizeZ(y){return nr(U,y)}static msm(y,a){return No(U,s,y,a)}static fromPrivateKey(y){return U.BASE.multiply(yr(s,y))}}U.BASE=new U(i.Gx,i.Gy,r.ONE),U.ZERO=new U(r.ZERO,r.ONE,r.ZERO),U.Fp=r,U.Fn=s;const O=s.BITS,W=new Oo(U,t.endo?Math.ceil(O/2):O);return U.BASE.precompute(8),U}function aa(n){return Uint8Array.of(n?2:3)}function ca(n,t){return{secretKey:t.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function kf(n,t={}){const{Fn:e}=n,r=t.randomBytes||Ui,s=Object.assign(ca(n.Fp,e),{seed:Lo(e.ORDER)});function i(S){try{return!!yr(e,S)}catch{return!1}}function o(S,M){const{publicKey:R,publicKeyUncompressed:L}=s;try{const F=S.length;return M===!0&&F!==R||M===!1&&F!==L?!1:!!n.fromBytes(S)}catch{return!1}}function u(S=r(s.seed)){return kc(Ae(S,s.seed,"seed"),e.ORDER)}function d(S,M=!0){return n.BASE.multiply(yr(e,S)).toBytes(M)}function b(S){const M=u(S);return{secretKey:M,publicKey:d(M)}}function I(S){if(typeof S=="bigint")return!1;if(S instanceof n)return!0;const{secretKey:M,publicKey:R,publicKeyUncompressed:L}=s;if(e.allowedLengths||M===R)return;const F=Dt("key",S).length;return F===R||F===L}function B(S,M,R=!0){if(I(S)===!0)throw new Error("first arg must be private key");if(I(M)===!1)throw new Error("second arg must be public key");const L=yr(e,S);return n.fromHex(M).multiply(L).toBytes(R)}return Object.freeze({getPublicKey:d,getSharedSecret:B,keygen:b,Point:n,utils:{isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:u,isValidPrivateKey:i,randomPrivateKey:u,normPrivateKeyToScalar:S=>yr(e,S),precompute(S=8,M=n.BASE){return M.precompute(S,!1)}},lengths:s})}function vf(n,t,e={}){ho(t),Kr(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=e.randomBytes||Ui,s=e.hmac||((a,...h)=>sa(t,a,Me(...h))),{Fp:i,Fn:o}=n,{ORDER:u,BITS:d}=o,{keygen:b,getPublicKey:I,getSharedSecret:B,utils:A,lengths:S}=kf(n,e),M={prehash:!1,lowS:typeof e.lowS=="boolean"?e.lowS:!1,format:void 0,extraEntropy:!1},R="compact";function L(a){const h=u>>wr;return a>h}function F(a,h){if(!o.isValidNot0(h))throw new Error(`invalid signature ${a}: out of range 1..Point.Fn.ORDER`);return h}function H(a,h){_i(h);const g=S.signature,v=h==="compact"?g:h==="recovered"?g+1:void 0;return Ae(a,v,`${h} signature`)}class K{constructor(h,g,v){this.r=F("r",h),this.s=F("s",g),v!=null&&(this.recovery=v),Object.freeze(this)}static fromBytes(h,g=R){H(h,g);let v;if(g==="der"){const{r:k,s:c}=Fe.toSig(Ae(h));return new K(k,c)}g==="recovered"&&(v=h[0],g="compact",h=h.subarray(1));const E=o.BYTES,T=h.subarray(0,E),C=h.subarray(E,E*2);return new K(o.fromBytes(T),o.fromBytes(C),v)}static fromHex(h,g){return this.fromBytes(sn(h),g)}addRecoveryBit(h){return new K(this.r,this.s,h)}recoverPublicKey(h){const g=i.ORDER,{r:v,s:E,recovery:T}=this;if(T==null||![0,1,2,3].includes(T))throw new Error("recovery id invalid");if(u*oa<g&&T>1)throw new Error("recovery id is ambiguous for h>1 curve");const k=T===2||T===3?v+u:v;if(!i.isValid(k))throw new Error("recovery id 2 or 3 invalid");const c=i.toBytes(k),f=n.fromBytes(Me(aa((T&1)===0),c)),w=o.inv(k),_=Y(Dt("msgHash",h)),z=o.create(-_*w),G=o.create(E*w),rt=n.BASE.multiplyUnsafe(z).add(f.multiplyUnsafe(G));if(rt.is0())throw new Error("point at infinify");return rt.assertValidity(),rt}hasHighS(){return L(this.s)}toBytes(h=R){if(_i(h),h==="der")return sn(Fe.hexFromSig(this));const g=o.toBytes(this.r),v=o.toBytes(this.s);if(h==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return Me(Uint8Array.of(this.recovery),g,v)}return Me(g,v)}toHex(h){return sr(this.toBytes(h))}assertValidity(){}static fromCompact(h){return K.fromBytes(Dt("sig",h),"compact")}static fromDER(h){return K.fromBytes(Dt("sig",h),"der")}normalizeS(){return this.hasHighS()?new K(this.r,o.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return sr(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return sr(this.toBytes("compact"))}}const X=e.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const g=kn(h),v=h.length*8-d;return v>0?g>>BigInt(v):g},Y=e.bits2int_modN||function(h){return o.create(X(h))},Q=zr(d);function ct(a){return Ii("num < 2^"+d,a,De,Q),o.toBytes(a)}function ot(a,h){return Ae(a,void 0,"message"),h?Ae(t(a),void 0,"prehashed message"):a}function U(a,h,g){if(["recovered","canonical"].some(z=>z in g))throw new Error("sign() legacy options not supported");const{lowS:v,prehash:E,extraEntropy:T}=gi(g,M);a=ot(a,E);const C=Y(a),k=yr(o,h),c=[ct(k),ct(C)];if(T!=null&&T!==!1){const z=T===!0?r(S.secretKey):T;c.push(Dt("extraEntropy",z))}const f=Me(...c),w=C;function _(z){const G=X(z);if(!o.isValidNot0(G))return;const rt=o.inv(G),st=n.BASE.multiply(G).toAffine(),kt=o.create(st.x);if(kt===De)return;const vt=o.create(rt*o.create(w+kt*k));if(vt===De)return;let It=(st.x===kt?0:2)|Number(st.y&wr),Ie=vt;return v&&L(vt)&&(Ie=o.neg(vt),It^=1),new K(kt,Ie,It)}return{seed:f,k2sig:_}}function O(a,h,g={}){a=Dt("message",a);const{seed:v,k2sig:E}=U(a,h,g);return fc(t.outputLen,o.BYTES,s)(v,E)}function W(a){let h;const g=typeof a=="string"||Fr(a),v=!g&&a!==null&&typeof a=="object"&&typeof a.r=="bigint"&&typeof a.s=="bigint";if(!g&&!v)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(v)h=new K(a.r,a.s);else if(g){try{h=K.fromBytes(Dt("sig",a),"der")}catch(E){if(!(E instanceof Fe.Err))throw E}if(!h)try{h=K.fromBytes(Dt("sig",a),"compact")}catch{return!1}}return h||!1}function V(a,h,g,v={}){const{lowS:E,prehash:T,format:C}=gi(v,M);if(g=Dt("publicKey",g),h=ot(Dt("message",h),T),"strict"in v)throw new Error("options.strict was renamed to lowS");const k=C===void 0?W(a):K.fromBytes(Dt("sig",a),C);if(k===!1)return!1;try{const c=n.fromBytes(g);if(E&&k.hasHighS())return!1;const{r:f,s:w}=k,_=Y(h),z=o.inv(w),G=o.create(_*z),rt=o.create(f*z),st=n.BASE.multiplyUnsafe(G).add(c.multiplyUnsafe(rt));return st.is0()?!1:o.create(st.x)===f}catch{return!1}}function y(a,h,g={}){const{prehash:v}=gi(g,M);return h=ot(h,v),K.fromBytes(a,"recovered").recoverPublicKey(h).toBytes()}return Object.freeze({keygen:b,getPublicKey:I,getSharedSecret:B,utils:A,lengths:S,Point:n,sign:O,verify:V,recoverPublicKey:y,Signature:K,hash:t})}function Sf(n){const t={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},e=n.Fp;let r=n.allowedPrivateKeyLengths?Array.from(new Set(n.allowedPrivateKeyLengths.map(o=>Math.ceil(o/2)))):void 0;const s=cr(t.n,{BITS:n.nBitLength,allowedLengths:r,modFromBytes:n.wrapPrivateKey}),i={Fp:e,Fn:s,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:t,curveOpts:i}}function xf(n){const{CURVE:t,curveOpts:e}=Sf(n),r={hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:t,curveOpts:e,hash:n.hash,ecdsaOpts:r}}function Ef(n,t){const e=t.Point;return Object.assign({},t,{ProjectivePoint:e,CURVE:Object.assign({},n,To(e.Fn.ORDER,e.Fn.BITS))})}function If(n){const{CURVE:t,curveOpts:e,hash:r,ecdsaOpts:s}=xf(n),i=bf(t,e),o=vf(i,r,s);return Ef(n,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function _f(n,t){const e=r=>If({...n,hash:r});return{...e(t),create:e}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vi={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Af={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},$s=BigInt(2);function Bf(n){const t=Vi.p,e=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),u=BigInt(44),d=BigInt(88),b=n*n*n%t,I=b*b*n%t,B=qt(I,e,t)*I%t,A=qt(B,e,t)*I%t,S=qt(A,$s,t)*b%t,M=qt(S,s,t)*S%t,R=qt(M,i,t)*M%t,L=qt(R,u,t)*R%t,F=qt(L,d,t)*L%t,H=qt(F,u,t)*R%t,K=qt(H,e,t)*I%t,X=qt(K,o,t)*M%t,Y=qt(X,r,t)*b%t,Q=qt(Y,$s,t);if(!Ai.eql(Ai.sqr(Q),n))throw new Error("Cannot find square root");return Q}const Ai=cr(Vi.p,{sqrt:Bf}),Hi=_f({...Vi,Fp:Ai,lowS:!0,endo:Af},bo),Rf=Ir.utils.randomPrivateKey,Vs=()=>{const n=Ir.utils.randomPrivateKey(),t=dn(n),e=new Uint8Array(64);return e.set(n),e.set(t,32),{publicKey:t,secretKey:e}},dn=Ir.getPublicKey;function Hs(n){try{return Ir.ExtendedPoint.fromHex(n),!0}catch{return!1}}const ji=(n,t)=>Ir.sign(n,t.slice(0,32)),Mf=Ir.verify,yt=n=>ft.Buffer.isBuffer(n)?n:n instanceof Uint8Array?ft.Buffer.from(n.buffer,n.byteOffset,n.byteLength):ft.Buffer.from(n);class ua{constructor(t){Object.assign(this,t)}encode(){return ft.Buffer.from(oi.serialize(nn,this))}static decode(t){return oi.deserialize(nn,this,t)}static decodeUnchecked(t){return oi.deserializeUnchecked(nn,this,t)}}class Lh extends ua{constructor(t){if(super(t),this.enum="",Object.keys(t).length!==1)throw new Error("Enum can only take single value");Object.keys(t).map(e=>{this.enum=e})}}const nn=new Map;var fa;const Tf=32,We=32;function Pf(n){return n._bn!==void 0}let js=1;class tt extends ua{constructor(t){if(super({}),this._bn=void 0,Pf(t))this._bn=t._bn;else{if(typeof t=="string"){const e=le.decode(t);if(e.length!=We)throw new Error("Invalid public key input");this._bn=new _s(e)}else this._bn=new _s(t);if(this._bn.byteLength()>We)throw new Error("Invalid public key input")}}static unique(){const t=new tt(js);return js+=1,new tt(t.toBuffer())}equals(t){return this._bn.eq(t._bn)}toBase58(){return le.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const t=this.toBuffer();return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}toBuffer(){const t=this._bn.toArrayLike(ft.Buffer);if(t.length===We)return t;const e=ft.Buffer.alloc(32);return t.copy(e,32-t.length),e}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(t,e,r){const s=ft.Buffer.concat([t.toBuffer(),ft.Buffer.from(e),r.toBuffer()]),i=Ms(s);return new tt(i)}static createProgramAddressSync(t,e){let r=ft.Buffer.alloc(0);t.forEach(function(i){if(i.length>Tf)throw new TypeError("Max seed length exceeded");r=ft.Buffer.concat([r,yt(i)])}),r=ft.Buffer.concat([r,e.toBuffer(),ft.Buffer.from("ProgramDerivedAddress")]);const s=Ms(r);if(Hs(s))throw new Error("Invalid seeds, address must fall off the curve");return new tt(s)}static async createProgramAddress(t,e){return this.createProgramAddressSync(t,e)}static findProgramAddressSync(t,e){let r=255,s;for(;r!=0;){try{const i=t.concat(ft.Buffer.from([r]));s=this.createProgramAddressSync(i,e)}catch(i){if(i instanceof TypeError)throw i;r--;continue}return[s,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(t,e){return this.findProgramAddressSync(t,e)}static isOnCurve(t){const e=new tt(t);return Hs(e.toBytes())}}fa=tt;tt.default=new fa("11111111111111111111111111111111");nn.set(tt,{kind:"struct",fields:[["_bn","u256"]]});class Ch{constructor(t){if(this._publicKey=void 0,this._secretKey=void 0,t){const e=yt(t);if(t.length!==64)throw new Error("bad secret key size");this._publicKey=e.slice(32,64),this._secretKey=e.slice(0,32)}else this._secretKey=yt(Rf()),this._publicKey=yt(dn(this._secretKey))}get publicKey(){return new tt(this._publicKey)}get secretKey(){return ft.Buffer.concat([this._secretKey,this._publicKey],64)}}const Uh=new tt("BPFLoader1111111111111111111111111111111111"),or=1232,Gi=127,pn=64;class la extends Error{constructor(t){super(`Signature ${t} has expired: block height exceeded.`),this.signature=void 0,this.signature=t}}Object.defineProperty(la.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class ha extends Error{constructor(t,e){super(`Transaction was not confirmed in ${e.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=t}}Object.defineProperty(ha.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Tr extends Error{constructor(t){super(`Signature ${t} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Tr.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class gn{constructor(t,e){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=t,this.accountKeysFromLookups=e}keySegments(){const t=[this.staticAccountKeys];return this.accountKeysFromLookups&&(t.push(this.accountKeysFromLookups.writable),t.push(this.accountKeysFromLookups.readonly)),t}get(t){for(const e of this.keySegments()){if(t<e.length)return e[t];t-=e.length}}get length(){return this.keySegments().flat().length}compileInstructions(t){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((i,o)=>{r.set(i.toBase58(),o)});const s=i=>{const o=r.get(i.toBase58());if(o===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return o};return t.map(i=>({programIdIndex:s(i.programId),accountKeyIndexes:i.keys.map(o=>s(o.pubkey)),data:i.data}))}}const mt=(n="publicKey")=>P.blob(32,n),Lf=(n="signature")=>P.blob(64,n),ir=(n="string")=>{const t=P.struct([P.u32("length"),P.u32("lengthPadding"),P.blob(P.offset(P.u32(),-8),"chars")],n),e=t.decode.bind(t),r=t.encode.bind(t),s=t;return s.decode=(i,o)=>e(i,o).chars.toString(),s.encode=(i,o,u)=>{const d={chars:ft.Buffer.from(i,"utf8")};return r(d,o,u)},s.alloc=i=>P.u32().span+P.u32().span+ft.Buffer.from(i,"utf8").length,s},Cf=(n="authorized")=>P.struct([mt("staker"),mt("withdrawer")],n),Uf=(n="lockup")=>P.struct([P.ns64("unixTimestamp"),P.ns64("epoch"),mt("custodian")],n),Of=(n="voteInit")=>P.struct([mt("nodePubkey"),mt("authorizedVoter"),mt("authorizedWithdrawer"),P.u8("commission")],n),Nf=(n="voteAuthorizeWithSeedArgs")=>P.struct([P.u32("voteAuthorizationType"),mt("currentAuthorityDerivedKeyOwnerPubkey"),ir("currentAuthorityDerivedKeySeed"),mt("newAuthorized")],n);function da(n,t){const e=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(t[s.property]);if("count"in s&&"elementLayout"in s){const i=t[s.property];if(Array.isArray(i))return i.length*e(s.elementLayout)}else if("fields"in s)return da({layout:s},t[s.property]);return 0};let r=0;return n.layout.fields.forEach(s=>{r+=e(s)}),r}function ke(n){let t=0,e=0;for(;;){let r=n.shift();if(t|=(r&127)<<e*7,e+=1,(r&128)===0)break}return t}function Ee(n,t){let e=t;for(;;){let r=e&127;if(e>>=7,e==0){n.push(r);break}else r|=128,n.push(r)}}function bt(n,t){if(!n)throw new Error(t||"Assertion failed")}class In{constructor(t,e){this.payer=void 0,this.keyMetaMap=void 0,this.payer=t,this.keyMetaMap=e}static compile(t,e){const r=new Map,s=o=>{const u=o.toBase58();let d=r.get(u);return d===void 0&&(d={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(u,d)),d},i=s(e);i.isSigner=!0,i.isWritable=!0;for(const o of t){s(o.programId).isInvoked=!0;for(const u of o.keys){const d=s(u.pubkey);d.isSigner||=u.isSigner,d.isWritable||=u.isWritable}}return new In(e,r)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];bt(t.length<=256,"Max static account keys length exceeded");const e=t.filter(([,d])=>d.isSigner&&d.isWritable),r=t.filter(([,d])=>d.isSigner&&!d.isWritable),s=t.filter(([,d])=>!d.isSigner&&d.isWritable),i=t.filter(([,d])=>!d.isSigner&&!d.isWritable),o={numRequiredSignatures:e.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:i.length};{bt(e.length>0,"Expected at least one writable signer key");const[d]=e[0];bt(d===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const u=[...e.map(([d])=>new tt(d)),...r.map(([d])=>new tt(d)),...s.map(([d])=>new tt(d)),...i.map(([d])=>new tt(d))];return[o,u]}extractTableLookup(t){const[e,r]=this.drainKeysFoundInLookupTable(t.state.addresses,o=>!o.isSigner&&!o.isInvoked&&o.isWritable),[s,i]=this.drainKeysFoundInLookupTable(t.state.addresses,o=>!o.isSigner&&!o.isInvoked&&!o.isWritable);if(!(e.length===0&&s.length===0))return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:s},{writable:r,readonly:i}]}drainKeysFoundInLookupTable(t,e){const r=new Array,s=new Array;for(const[i,o]of this.keyMetaMap.entries())if(e(o)){const u=new tt(i),d=t.findIndex(b=>b.equals(u));d>=0&&(bt(d<256,"Max lookup table index exceeded"),r.push(d),s.push(u),this.keyMetaMap.delete(i))}return[r,s]}}const pa="Reached end of buffer unexpectedly";function Te(n){if(n.length===0)throw new Error(pa);return n.shift()}function ve(n,...t){const[e]=t;if(t.length===2?e+(t[1]??0)>n.length:e>=n.length)throw new Error(pa);return n.splice(...t)}class Ce{constructor(t){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=t.header,this.accountKeys=t.accountKeys.map(e=>new tt(e)),this.recentBlockhash=t.recentBlockhash,this.instructions=t.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:le.decode(t.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new gn(this.staticAccountKeys)}static compile(t){const e=In.compile(t.instructions,t.payerKey),[r,s]=e.getMessageComponents(),o=new gn(s).compileInstructions(t.instructions).map(u=>({programIdIndex:u.programIdIndex,accounts:u.accountKeyIndexes,data:le.encode(u.data)}));return new Ce({header:r,accountKeys:s,recentBlockhash:t.recentBlockhash,instructions:o})}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures;if(t>=this.header.numRequiredSignatures){const r=t-e,i=this.accountKeys.length-e-this.header.numReadonlyUnsignedAccounts;return r<i}else{const r=e-this.header.numReadonlySignedAccounts;return t<r}}isProgramId(t){return this.indexToProgramIds.has(t)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((t,e)=>!this.isProgramId(e))}serialize(){const t=this.accountKeys.length;let e=[];Ee(e,t);const r=this.instructions.map(B=>{const{accounts:A,programIdIndex:S}=B,M=Array.from(le.decode(B.data));let R=[];Ee(R,A.length);let L=[];return Ee(L,M.length),{programIdIndex:S,keyIndicesCount:ft.Buffer.from(R),keyIndices:A,dataLength:ft.Buffer.from(L),data:M}});let s=[];Ee(s,r.length);let i=ft.Buffer.alloc(or);ft.Buffer.from(s).copy(i);let o=s.length;r.forEach(B=>{const S=P.struct([P.u8("programIdIndex"),P.blob(B.keyIndicesCount.length,"keyIndicesCount"),P.seq(P.u8("keyIndex"),B.keyIndices.length,"keyIndices"),P.blob(B.dataLength.length,"dataLength"),P.seq(P.u8("userdatum"),B.data.length,"data")]).encode(B,i,o);o+=S}),i=i.slice(0,o);const u=P.struct([P.blob(1,"numRequiredSignatures"),P.blob(1,"numReadonlySignedAccounts"),P.blob(1,"numReadonlyUnsignedAccounts"),P.blob(e.length,"keyCount"),P.seq(mt("key"),t,"keys"),mt("recentBlockhash")]),d={numRequiredSignatures:ft.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:ft.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:ft.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:ft.Buffer.from(e),keys:this.accountKeys.map(B=>yt(B.toBytes())),recentBlockhash:le.decode(this.recentBlockhash)};let b=ft.Buffer.alloc(2048);const I=u.encode(d,b);return i.copy(b,I),b.slice(0,I+i.length)}static from(t){let e=[...t];const r=Te(e);if(r!==(r&Gi))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=Te(e),i=Te(e),o=ke(e);let u=[];for(let A=0;A<o;A++){const S=ve(e,0,We);u.push(new tt(ft.Buffer.from(S)))}const d=ve(e,0,We),b=ke(e);let I=[];for(let A=0;A<b;A++){const S=Te(e),M=ke(e),R=ve(e,0,M),L=ke(e),F=ve(e,0,L),H=le.encode(ft.Buffer.from(F));I.push({programIdIndex:S,accounts:R,data:H})}const B={header:{numRequiredSignatures:r,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:i},recentBlockhash:le.encode(ft.Buffer.from(d)),accountKeys:u,instructions:I};return new Ce(B)}}class Sr{constructor(t){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=t.header,this.staticAccountKeys=t.staticAccountKeys,this.recentBlockhash=t.recentBlockhash,this.compiledInstructions=t.compiledInstructions,this.addressTableLookups=t.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let t=0;for(const e of this.addressTableLookups)t+=e.readonlyIndexes.length+e.writableIndexes.length;return t}getAccountKeys(t){let e;if(t&&"accountKeysFromLookups"in t&&t.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=t.accountKeysFromLookups.writable.length+t.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");e=t.accountKeysFromLookups}else if(t&&"addressLookupTableAccounts"in t&&t.addressLookupTableAccounts)e=this.resolveAddressTableLookups(t.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new gn(this.staticAccountKeys,e)}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(t>=r){const s=t-r,i=this.addressTableLookups.reduce((o,u)=>o+u.writableIndexes.length,0);return s<i}else if(t>=this.header.numRequiredSignatures){const s=t-e,o=r-e-this.header.numReadonlyUnsignedAccounts;return s<o}else{const s=e-this.header.numReadonlySignedAccounts;return t<s}}resolveAddressTableLookups(t){const e={writable:[],readonly:[]};for(const r of this.addressTableLookups){const s=t.find(i=>i.key.equals(r.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const i of r.writableIndexes)if(i<s.state.addresses.length)e.writable.push(s.state.addresses[i]);else throw new Error(`Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`);for(const i of r.readonlyIndexes)if(i<s.state.addresses.length)e.readonly.push(s.state.addresses[i]);else throw new Error(`Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`)}return e}static compile(t){const e=In.compile(t.instructions,t.payerKey),r=new Array,s={writable:new Array,readonly:new Array},i=t.addressLookupTableAccounts||[];for(const I of i){const B=e.extractTableLookup(I);if(B!==void 0){const[A,{writable:S,readonly:M}]=B;r.push(A),s.writable.push(...S),s.readonly.push(...M)}}const[o,u]=e.getMessageComponents(),b=new gn(u,s).compileInstructions(t.instructions);return new Sr({header:o,staticAccountKeys:u,recentBlockhash:t.recentBlockhash,compiledInstructions:b,addressTableLookups:r})}serialize(){const t=Array();Ee(t,this.staticAccountKeys.length);const e=this.serializeInstructions(),r=Array();Ee(r,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),i=Array();Ee(i,this.addressTableLookups.length);const o=P.struct([P.u8("prefix"),P.struct([P.u8("numRequiredSignatures"),P.u8("numReadonlySignedAccounts"),P.u8("numReadonlyUnsignedAccounts")],"header"),P.blob(t.length,"staticAccountKeysLength"),P.seq(mt(),this.staticAccountKeys.length,"staticAccountKeys"),mt("recentBlockhash"),P.blob(r.length,"instructionsLength"),P.blob(e.length,"serializedInstructions"),P.blob(i.length,"addressTableLookupsLength"),P.blob(s.length,"serializedAddressTableLookups")]),u=new Uint8Array(or),b=o.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(t),staticAccountKeys:this.staticAccountKeys.map(I=>I.toBytes()),recentBlockhash:le.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:e,addressTableLookupsLength:new Uint8Array(i),serializedAddressTableLookups:s},u);return u.slice(0,b)}serializeInstructions(){let t=0;const e=new Uint8Array(or);for(const r of this.compiledInstructions){const s=Array();Ee(s,r.accountKeyIndexes.length);const i=Array();Ee(i,r.data.length);const o=P.struct([P.u8("programIdIndex"),P.blob(s.length,"encodedAccountKeyIndexesLength"),P.seq(P.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),P.blob(i.length,"encodedDataLength"),P.blob(r.data.length,"data")]);t+=o.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(i),data:r.data},e,t)}return e.slice(0,t)}serializeAddressTableLookups(){let t=0;const e=new Uint8Array(or);for(const r of this.addressTableLookups){const s=Array();Ee(s,r.writableIndexes.length);const i=Array();Ee(i,r.readonlyIndexes.length);const o=P.struct([mt("accountKey"),P.blob(s.length,"encodedWritableIndexesLength"),P.seq(P.u8(),r.writableIndexes.length,"writableIndexes"),P.blob(i.length,"encodedReadonlyIndexesLength"),P.seq(P.u8(),r.readonlyIndexes.length,"readonlyIndexes")]);t+=o.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(i),readonlyIndexes:r.readonlyIndexes},e,t)}return e.slice(0,t)}static deserialize(t){let e=[...t];const r=Te(e),s=r&Gi;bt(r!==s,"Expected versioned message but received legacy message");const i=s;bt(i===0,`Expected versioned message with version 0 but found version ${i}`);const o={numRequiredSignatures:Te(e),numReadonlySignedAccounts:Te(e),numReadonlyUnsignedAccounts:Te(e)},u=[],d=ke(e);for(let M=0;M<d;M++)u.push(new tt(ve(e,0,We)));const b=le.encode(ve(e,0,We)),I=ke(e),B=[];for(let M=0;M<I;M++){const R=Te(e),L=ke(e),F=ve(e,0,L),H=ke(e),K=new Uint8Array(ve(e,0,H));B.push({programIdIndex:R,accountKeyIndexes:F,data:K})}const A=ke(e),S=[];for(let M=0;M<A;M++){const R=new tt(ve(e,0,We)),L=ke(e),F=ve(e,0,L),H=ke(e),K=ve(e,0,H);S.push({accountKey:R,writableIndexes:F,readonlyIndexes:K})}return new Sr({header:o,staticAccountKeys:u,recentBlockhash:b,compiledInstructions:B,addressTableLookups:S})}}const ga={deserializeMessageVersion(n){const t=n[0],e=t&Gi;return e===t?"legacy":e},deserialize:n=>{const t=ga.deserializeMessageVersion(n);if(t==="legacy")return Ce.from(n);if(t===0)return Sr.deserialize(n);throw new Error(`Transaction message version ${t} deserialization is not supported`)}};let Ye=(function(n){return n[n.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",n[n.PROCESSED=1]="PROCESSED",n[n.TIMED_OUT=2]="TIMED_OUT",n[n.NONCE_INVALID=3]="NONCE_INVALID",n})({});const Ff=ft.Buffer.alloc(pn).fill(0);class Bt{constructor(t){this.keys=void 0,this.programId=void 0,this.data=ft.Buffer.alloc(0),this.programId=t.programId,this.keys=t.keys,t.data&&(this.data=t.data)}toJSON(){return{keys:this.keys.map(({pubkey:t,isSigner:e,isWritable:r})=>({pubkey:t.toJSON(),isSigner:e,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class xt{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(t){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!t)if(t.feePayer&&(this.feePayer=t.feePayer),t.signatures&&(this.signatures=t.signatures),Object.prototype.hasOwnProperty.call(t,"nonceInfo")){const{minContextSlot:e,nonceInfo:r}=t;this.minNonceContextSlot=e,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")){const{blockhash:e,lastValidBlockHeight:r}=t;this.recentBlockhash=e,this.lastValidBlockHeight=r}else{const{recentBlockhash:e,nonceInfo:r}=t;r&&(this.nonceInfo=r),this.recentBlockhash=e}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(t=>t.toJSON()),signers:this.signatures.map(({publicKey:t})=>t.toJSON())}}add(...t){if(t.length===0)throw new Error("No instructions");return t.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new Bt(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let t,e;if(this.nonceInfo?(t=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?e=[this.nonceInfo.nonceInstruction,...this.instructions]:e=this.instructions):(t=this.recentBlockhash,e=this.instructions),!t)throw new Error("Transaction recentBlockhash required");e.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let R=0;R<e.length;R++)if(e[R].programId===void 0)throw new Error(`Transaction instruction index ${R} has undefined program id`);const s=[],i=[];e.forEach(R=>{R.keys.forEach(F=>{i.push({...F})});const L=R.programId.toString();s.includes(L)||s.push(L)}),s.forEach(R=>{i.push({pubkey:new tt(R),isSigner:!1,isWritable:!1})});const o=[];i.forEach(R=>{const L=R.pubkey.toString(),F=o.findIndex(H=>H.pubkey.toString()===L);F>-1?(o[F].isWritable=o[F].isWritable||R.isWritable,o[F].isSigner=o[F].isSigner||R.isSigner):o.push(R)}),o.sort(function(R,L){if(R.isSigner!==L.isSigner)return R.isSigner?-1:1;if(R.isWritable!==L.isWritable)return R.isWritable?-1:1;const F={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return R.pubkey.toBase58().localeCompare(L.pubkey.toBase58(),"en",F)});const u=o.findIndex(R=>R.pubkey.equals(r));if(u>-1){const[R]=o.splice(u,1);R.isSigner=!0,R.isWritable=!0,o.unshift(R)}else o.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const R of this.signatures){const L=o.findIndex(F=>F.pubkey.equals(R.publicKey));if(L>-1)o[L].isSigner||(o[L].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${R.publicKey.toString()}`)}let d=0,b=0,I=0;const B=[],A=[];o.forEach(({pubkey:R,isSigner:L,isWritable:F})=>{L?(B.push(R.toString()),d+=1,F||(b+=1)):(A.push(R.toString()),F||(I+=1))});const S=B.concat(A),M=e.map(R=>{const{data:L,programId:F}=R;return{programIdIndex:S.indexOf(F.toString()),accounts:R.keys.map(H=>S.indexOf(H.pubkey.toString())),data:le.encode(L)}});return M.forEach(R=>{bt(R.programIdIndex>=0),R.accounts.forEach(L=>bt(L>=0))}),new Ce({header:{numRequiredSignatures:d,numReadonlySignedAccounts:b,numReadonlyUnsignedAccounts:I},accountKeys:S,recentBlockhash:t,instructions:M})}_compile(){const t=this.compileMessage(),e=t.accountKeys.slice(0,t.header.numRequiredSignatures);return this.signatures.length===e.length&&this.signatures.every((s,i)=>e[i].equals(s.publicKey))||(this.signatures=e.map(r=>({signature:null,publicKey:r}))),t}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(t){return(await t.getFeeForMessage(this.compileMessage())).value}setSigners(...t){if(t.length===0)throw new Error("No signers");const e=new Set;this.signatures=t.filter(r=>{const s=r.toString();return e.has(s)?!1:(e.add(s),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const i of t){const o=i.publicKey.toString();e.has(o)||(e.add(o),r.push(i))}this.signatures=r.map(i=>({signature:null,publicKey:i.publicKey}));const s=this._compile();this._partialSign(s,...r)}partialSign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const i of t){const o=i.publicKey.toString();e.has(o)||(e.add(o),r.push(i))}const s=this._compile();this._partialSign(s,...r)}_partialSign(t,...e){const r=t.serialize();e.forEach(s=>{const i=ji(r,s.secretKey);this._addSignature(s.publicKey,yt(i))})}addSignature(t,e){this._compile(),this._addSignature(t,e)}_addSignature(t,e){bt(e.length===64);const r=this.signatures.findIndex(s=>t.equals(s.publicKey));if(r<0)throw new Error(`unknown signer: ${t.toString()}`);this.signatures[r].signature=ft.Buffer.from(e)}verifySignatures(t=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),t)}_getMessageSignednessErrors(t,e){const r={};for(const{signature:s,publicKey:i}of this.signatures)s===null?e&&(r.missing||=[]).push(i):Mf(s,t,i.toBytes())||(r.invalid||=[]).push(i);return r.invalid||r.missing?r:void 0}serialize(t){const{requireAllSignatures:e,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},t),s=this.serializeMessage();if(r){const i=this._getMessageSignednessErrors(s,e);if(i){let o="Signature verification failed.";throw i.invalid&&(o+=`
Invalid signature for public key${i.invalid.length===1?"":"(s)"} [\`${i.invalid.map(u=>u.toBase58()).join("`, `")}\`].`),i.missing&&(o+=`
Missing signature for public key${i.missing.length===1?"":"(s)"} [\`${i.missing.map(u=>u.toBase58()).join("`, `")}\`].`),new Error(o)}}return this._serialize(s)}_serialize(t){const{signatures:e}=this,r=[];Ee(r,e.length);const s=r.length+e.length*64+t.length,i=ft.Buffer.alloc(s);return bt(e.length<256),ft.Buffer.from(r).copy(i,0),e.forEach(({signature:o},u)=>{o!==null&&(bt(o.length===64,"signature has invalid length"),ft.Buffer.from(o).copy(i,r.length+u*64))}),t.copy(i,r.length+e.length*64),bt(i.length<=or,`Transaction too large: ${i.length} > ${or}`),i}get keys(){return bt(this.instructions.length===1),this.instructions[0].keys.map(t=>t.pubkey)}get programId(){return bt(this.instructions.length===1),this.instructions[0].programId}get data(){return bt(this.instructions.length===1),this.instructions[0].data}static from(t){let e=[...t];const r=ke(e);let s=[];for(let i=0;i<r;i++){const o=ve(e,0,pn);s.push(le.encode(ft.Buffer.from(o)))}return xt.populate(Ce.from(e),s)}static populate(t,e=[]){const r=new xt;return r.recentBlockhash=t.recentBlockhash,t.header.numRequiredSignatures>0&&(r.feePayer=t.accountKeys[0]),e.forEach((s,i)=>{const o={signature:s==le.encode(Ff)?null:le.decode(s),publicKey:t.accountKeys[i]};r.signatures.push(o)}),t.instructions.forEach(s=>{const i=s.accounts.map(o=>{const u=t.accountKeys[o];return{pubkey:u,isSigner:r.signatures.some(d=>d.publicKey.toString()===u.toString())||t.isAccountSigner(o),isWritable:t.isAccountWritable(o)}});r.instructions.push(new Bt({keys:i,programId:t.accountKeys[s.programIdIndex],data:le.decode(s.data)}))}),r._message=t,r._json=r.toJSON(),r}}class ya{constructor(t){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=t.payerKey,this.instructions=t.instructions,this.recentBlockhash=t.recentBlockhash}static decompile(t,e){const{header:r,compiledInstructions:s,recentBlockhash:i}=t,{numRequiredSignatures:o,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:d}=r,b=o-u;bt(b>0,"Message header is invalid");const I=t.staticAccountKeys.length-o-d;bt(I>=0,"Message header is invalid");const B=t.getAccountKeys(e),A=B.get(0);if(A===void 0)throw new Error("Failed to decompile message because no account keys were found");const S=[];for(const M of s){const R=[];for(const F of M.accountKeyIndexes){const H=B.get(F);if(H===void 0)throw new Error(`Failed to find key for account key index ${F}`);const K=F<o;let X;K?X=F<b:F<B.staticAccountKeys.length?X=F-o<I:X=F-B.staticAccountKeys.length<B.accountKeysFromLookups.writable.length,R.push({pubkey:H,isSigner:F<r.numRequiredSignatures,isWritable:X})}const L=B.get(M.programIdIndex);if(L===void 0)throw new Error(`Failed to find program id for program id index ${M.programIdIndex}`);S.push(new Bt({programId:L,data:yt(M.data),keys:R}))}return new ya({payerKey:A,instructions:S,recentBlockhash:i})}compileToLegacyMessage(){return Ce.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(t){return Sr.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:t})}}class ma{get version(){return this.message.version}constructor(t,e){if(this.signatures=void 0,this.message=void 0,e!==void 0)bt(e.length===t.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=e;else{const r=[];for(let s=0;s<t.header.numRequiredSignatures;s++)r.push(new Uint8Array(pn));this.signatures=r}this.message=t}serialize(){const t=this.message.serialize(),e=Array();Ee(e,this.signatures.length);const r=P.struct([P.blob(e.length,"encodedSignaturesLength"),P.seq(Lf(),this.signatures.length,"signatures"),P.blob(t.length,"serializedMessage")]),s=new Uint8Array(2048),i=r.encode({encodedSignaturesLength:new Uint8Array(e),signatures:this.signatures,serializedMessage:t},s);return s.slice(0,i)}static deserialize(t){let e=[...t];const r=[],s=ke(e);for(let o=0;o<s;o++)r.push(new Uint8Array(ve(e,0,pn)));const i=ga.deserialize(new Uint8Array(e));return new ma(i,r)}sign(t){const e=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const s of t){const i=r.findIndex(o=>o.equals(s.publicKey));bt(i>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[i]=ji(e,s.secretKey)}}addSignature(t,e){bt(e.byteLength===64,"Signature must be 64 bytes long");const s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(i=>i.equals(t));bt(s>=0,`Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=e}}const zf=160,Kf=64,qf=zf/Kf,wa=1e3/qf,ze=new tt("SysvarC1ock11111111111111111111111111111111"),Oh=new tt("SysvarEpochSchedu1e111111111111111111111111"),Nh=new tt("Sysvar1nstructions1111111111111111111111111"),yi=new tt("SysvarRecentB1ockHashes11111111111111111111"),Or=new tt("SysvarRent111111111111111111111111111111111"),Fh=new tt("SysvarRewards111111111111111111111111111111"),zh=new tt("SysvarS1otHashes111111111111111111111111111"),Kh=new tt("SysvarS1otHistory11111111111111111111111111"),mi=new tt("SysvarStakeHistory1111111111111111111111111");class yn extends Error{constructor({action:t,signature:e,transactionMessage:r,logs:s}){const i=s?`Logs: 
${JSON.stringify(s.slice(-10),null,2)}. `:"",o="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let u;switch(t){case"send":u=`Transaction ${e} resulted in an error. 
${r}. `+i+o;break;case"simulate":u=`Simulation failed. 
Message: ${r}. 
`+i+o;break;default:u=`Unknown action '${(d=>d)(t)}'`}super(u),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=e,this.transactionMessage=r,this.transactionLogs=s||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const t=this.transactionLogs;if(!(t!=null&&typeof t=="object"&&"then"in t))return t}async getLogs(t){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((e,r)=>{t.getTransaction(this.signature).then(s=>{if(s&&s.meta&&s.meta.logMessages){const i=s.meta.logMessages;this.transactionLogs=i,e(i)}else r(new Error("Log messages not found"))}).catch(r)})),await this.transactionLogs}}const qh={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class at extends Error{constructor({code:t,message:e,data:r},s){super(s!=null?`${s}: ${e}`:e),this.code=void 0,this.data=void 0,this.code=t,this.data=r,this.name="SolanaJSONRPCError"}}async function Gs(n,t,e,r){const s=r&&{skipPreflight:r.skipPreflight,preflightCommitment:r.preflightCommitment||r.commitment,maxRetries:r.maxRetries,minContextSlot:r.minContextSlot},i=await n.sendTransaction(t,e,s);let o;if(t.recentBlockhash!=null&&t.lastValidBlockHeight!=null)o=(await n.confirmTransaction({abortSignal:r?.abortSignal,signature:i,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},r&&r.commitment)).value;else if(t.minNonceContextSlot!=null&&t.nonceInfo!=null){const{nonceInstruction:u}=t.nonceInfo,d=u.keys[0].pubkey;o=(await n.confirmTransaction({abortSignal:r?.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:d,nonceValue:t.nonceInfo.nonce,signature:i},r&&r.commitment)).value}else r?.abortSignal!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),o=(await n.confirmTransaction(i,r&&r.commitment)).value;if(o.err)throw i!=null?new yn({action:"send",signature:i,transactionMessage:`Status: (${JSON.stringify(o)})`}):new Error(`Transaction ${i} failed (${JSON.stringify(o)})`);return i}function tr(n){return new Promise(t=>setTimeout(t,n))}function wt(n,t){const e=n.layout.span>=0?n.layout.span:da(n,t),r=ft.Buffer.alloc(e),s=Object.assign({instruction:n.index},t);return n.layout.encode(s,r),r}function St(n,t){let e;try{e=n.layout.decode(t)}catch(r){throw new Error("invalid instruction; "+r)}if(e.instruction!==n.index)throw new Error(`invalid instruction; instruction index mismatch ${e.instruction} != ${n.index}`);return e}const Df=P.nu64("lamportsPerSignature"),ba=P.struct([P.u32("version"),P.u32("state"),mt("authorizedPubkey"),mt("nonce"),P.struct([Df],"feeCalculator")]),Zs=ba.span;class Zi{constructor(t){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=t.authorizedPubkey,this.nonce=t.nonce,this.feeCalculator=t.feeCalculator}static fromAccountData(t){const e=ba.decode(yt(t),0);return new Zi({authorizedPubkey:new tt(e.authorizedPubkey),nonce:new tt(e.nonce).toString(),feeCalculator:e.feeCalculator})}}function xr(n){const t=P.blob(8,n),e=t.decode.bind(t),r=t.encode.bind(t),s=t,i=xu();return s.decode=(o,u)=>{const d=e(o,u);return i.decode(d)},s.encode=(o,u,d)=>{const b=i.encode(o);return r(b,u,d)},s}class Dh{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=P.u32("instruction").decode(t.data);let s;for(const[i,o]of Object.entries(Tt))if(o.index==r){s=i;break}if(!s)throw new Error("Instruction type incorrect; not a SystemInstruction");return s}static decodeCreateAccount(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{lamports:e,space:r,programId:s}=St(Tt.Create,t.data);return{fromPubkey:t.keys[0].pubkey,newAccountPubkey:t.keys[1].pubkey,lamports:e,space:r,programId:new tt(s)}}static decodeTransfer(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{lamports:e}=St(Tt.Transfer,t.data);return{fromPubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,lamports:e}}static decodeTransferWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e,seed:r,programId:s}=St(Tt.TransferWithSeed,t.data);return{fromPubkey:t.keys[0].pubkey,basePubkey:t.keys[1].pubkey,toPubkey:t.keys[2].pubkey,lamports:e,seed:r,programId:new tt(s)}}static decodeAllocate(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{space:e}=St(Tt.Allocate,t.data);return{accountPubkey:t.keys[0].pubkey,space:e}}static decodeAllocateWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{base:e,seed:r,space:s,programId:i}=St(Tt.AllocateWithSeed,t.data);return{accountPubkey:t.keys[0].pubkey,basePubkey:new tt(e),seed:r,space:s,programId:new tt(i)}}static decodeAssign(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{programId:e}=St(Tt.Assign,t.data);return{accountPubkey:t.keys[0].pubkey,programId:new tt(e)}}static decodeAssignWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{base:e,seed:r,programId:s}=St(Tt.AssignWithSeed,t.data);return{accountPubkey:t.keys[0].pubkey,basePubkey:new tt(e),seed:r,programId:new tt(s)}}static decodeCreateWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{base:e,seed:r,lamports:s,space:i,programId:o}=St(Tt.CreateWithSeed,t.data);return{fromPubkey:t.keys[0].pubkey,newAccountPubkey:t.keys[1].pubkey,basePubkey:new tt(e),seed:r,lamports:s,space:i,programId:new tt(o)}}static decodeNonceInitialize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{authorized:e}=St(Tt.InitializeNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,authorizedPubkey:new tt(e)}}static decodeNonceAdvance(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),St(Tt.AdvanceNonceAccount,t.data),{noncePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey}}static decodeNonceWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,5);const{lamports:e}=St(Tt.WithdrawNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey,lamports:e}}static decodeNonceAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{authorized:e}=St(Tt.AuthorizeNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[1].pubkey,newAuthorizedPubkey:new tt(e)}}static checkProgramId(t){if(!t.equals(he.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const Tt=Object.freeze({Create:{index:0,layout:P.struct([P.u32("instruction"),P.ns64("lamports"),P.ns64("space"),mt("programId")])},Assign:{index:1,layout:P.struct([P.u32("instruction"),mt("programId")])},Transfer:{index:2,layout:P.struct([P.u32("instruction"),xr("lamports")])},CreateWithSeed:{index:3,layout:P.struct([P.u32("instruction"),mt("base"),ir("seed"),P.ns64("lamports"),P.ns64("space"),mt("programId")])},AdvanceNonceAccount:{index:4,layout:P.struct([P.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:P.struct([P.u32("instruction"),P.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:P.struct([P.u32("instruction"),mt("authorized")])},AuthorizeNonceAccount:{index:7,layout:P.struct([P.u32("instruction"),mt("authorized")])},Allocate:{index:8,layout:P.struct([P.u32("instruction"),P.ns64("space")])},AllocateWithSeed:{index:9,layout:P.struct([P.u32("instruction"),mt("base"),ir("seed"),P.ns64("space"),mt("programId")])},AssignWithSeed:{index:10,layout:P.struct([P.u32("instruction"),mt("base"),ir("seed"),mt("programId")])},TransferWithSeed:{index:11,layout:P.struct([P.u32("instruction"),xr("lamports"),ir("seed"),mt("programId")])},UpgradeNonceAccount:{index:12,layout:P.struct([P.u32("instruction")])}});class he{constructor(){}static createAccount(t){const e=Tt.Create,r=wt(e,{lamports:t.lamports,space:t.space,programId:yt(t.programId.toBuffer())});return new Bt({keys:[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(t){let e,r;if("basePubkey"in t){const s=Tt.TransferWithSeed;e=wt(s,{lamports:BigInt(t.lamports),seed:t.seed,programId:yt(t.programId.toBuffer())}),r=[{pubkey:t.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=Tt.Transfer;e=wt(s,{lamports:BigInt(t.lamports)}),r=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}return new Bt({keys:r,programId:this.programId,data:e})}static assign(t){let e,r;if("basePubkey"in t){const s=Tt.AssignWithSeed;e=wt(s,{base:yt(t.basePubkey.toBuffer()),seed:t.seed,programId:yt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Tt.Assign;e=wt(s,{programId:yt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new Bt({keys:r,programId:this.programId,data:e})}static createAccountWithSeed(t){const e=Tt.CreateWithSeed,r=wt(e,{base:yt(t.basePubkey.toBuffer()),seed:t.seed,lamports:t.lamports,space:t.space,programId:yt(t.programId.toBuffer())});let s=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!1,isWritable:!0}];return t.basePubkey.equals(t.fromPubkey)||s.push({pubkey:t.basePubkey,isSigner:!0,isWritable:!1}),new Bt({keys:s,programId:this.programId,data:r})}static createNonceAccount(t){const e=new xt;"basePubkey"in t&&"seed"in t?e.add(he.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:Zs,programId:this.programId})):e.add(he.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,lamports:t.lamports,space:Zs,programId:this.programId}));const r={noncePubkey:t.noncePubkey,authorizedPubkey:t.authorizedPubkey};return e.add(this.nonceInitialize(r)),e}static nonceInitialize(t){const e=Tt.InitializeNonceAccount,r=wt(e,{authorized:yt(t.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:yi,isSigner:!1,isWritable:!1},{pubkey:Or,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new Bt(s)}static nonceAdvance(t){const e=Tt.AdvanceNonceAccount,r=wt(e),s={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:yi,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new Bt(s)}static nonceWithdraw(t){const e=Tt.WithdrawNonceAccount,r=wt(e,{lamports:t.lamports});return new Bt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0},{pubkey:yi,isSigner:!1,isWritable:!1},{pubkey:Or,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(t){const e=Tt.AuthorizeNonceAccount,r=wt(e,{authorized:yt(t.newAuthorizedPubkey.toBuffer())});return new Bt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(t){let e,r;if("basePubkey"in t){const s=Tt.AllocateWithSeed;e=wt(s,{base:yt(t.basePubkey.toBuffer()),seed:t.seed,space:t.space,programId:yt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Tt.Allocate;e=wt(s,{space:t.space}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new Bt({keys:r,programId:this.programId,data:e})}}he.programId=new tt("11111111111111111111111111111111");const Wf=or-300;class Er{constructor(){}static getMinNumSignatures(t){return 2*(Math.ceil(t/Er.chunkSize)+1+1)}static async load(t,e,r,s,i){{const B=await t.getMinimumBalanceForRentExemption(i.length),A=await t.getAccountInfo(r.publicKey,"confirmed");let S=null;if(A!==null){if(A.executable)return console.error("Program load failed, account is already executable"),!1;A.data.length!==i.length&&(S=S||new xt,S.add(he.allocate({accountPubkey:r.publicKey,space:i.length}))),A.owner.equals(s)||(S=S||new xt,S.add(he.assign({accountPubkey:r.publicKey,programId:s}))),A.lamports<B&&(S=S||new xt,S.add(he.transfer({fromPubkey:e.publicKey,toPubkey:r.publicKey,lamports:B-A.lamports})))}else S=new xt().add(he.createAccount({fromPubkey:e.publicKey,newAccountPubkey:r.publicKey,lamports:B>0?B:1,space:i.length,programId:s}));S!==null&&await Gs(t,S,[e,r],{commitment:"confirmed"})}const o=P.struct([P.u32("instruction"),P.u32("offset"),P.u32("bytesLength"),P.u32("bytesLengthPadding"),P.seq(P.u8("byte"),P.offset(P.u32(),-8),"bytes")]),u=Er.chunkSize;let d=0,b=i,I=[];for(;b.length>0;){const B=b.slice(0,u),A=ft.Buffer.alloc(u+16);o.encode({instruction:0,offset:d,bytes:B,bytesLength:0,bytesLengthPadding:0},A);const S=new xt().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:s,data:A});I.push(Gs(t,S,[e,r],{commitment:"confirmed"})),t._rpcEndpoint.includes("solana.com")&&await tr(1e3/4),d+=u,b=b.slice(u)}await Promise.all(I);{const B=P.struct([P.u32("instruction")]),A=ft.Buffer.alloc(B.span);B.encode({instruction:1},A);const S=new xt().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:Or,isSigner:!1,isWritable:!1}],programId:s,data:A}),M="processed",R=await t.sendTransaction(S,[e,r],{preflightCommitment:M}),{context:L,value:F}=await t.confirmTransaction({signature:R,lastValidBlockHeight:S.lastValidBlockHeight,blockhash:S.recentBlockhash},M);if(F.err)throw new Error(`Transaction ${R} failed (${JSON.stringify(F)})`);for(;;){try{if(await t.getSlot({commitment:M})>L.slot)break}catch{}await new Promise(H=>setTimeout(H,Math.round(wa/2)))}}return!0}}Er.chunkSize=Wf;const Wh=new tt("BPFLoader2111111111111111111111111111111111");class $h{static getMinNumSignatures(t){return Er.getMinNumSignatures(t)}static load(t,e,r,s,i){return Er.load(t,e,r,i,s)}}function $f(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var wi,Ys;function Vf(){if(Ys)return wi;Ys=1;var n=Object.prototype.toString,t=Object.keys||function(r){var s=[];for(var i in r)s.push(i);return s};function e(r,s){var i,o,u,d,b,I,B;if(r===!0)return"true";if(r===!1)return"false";switch(typeof r){case"object":if(r===null)return null;if(r.toJSON&&typeof r.toJSON=="function")return e(r.toJSON(),s);if(B=n.call(r),B==="[object Array]"){for(u="[",o=r.length-1,i=0;i<o;i++)u+=e(r[i],!0)+",";return o>-1&&(u+=e(r[i],!0)),u+"]"}else if(B==="[object Object]"){for(d=t(r).sort(),o=d.length,u="",i=0;i<o;)b=d[i],I=e(r[b],!1),I!==void 0&&(u&&(u+=","),u+=JSON.stringify(b)+":"+I),i++;return"{"+u+"}"}else return JSON.stringify(r);case"function":case"undefined":return s?null:void 0;case"string":return JSON.stringify(r);default:return isFinite(r)?r:null}}return wi=function(r){var s=e(r,!1);if(s!==void 0)return""+s},wi}var Hf=Vf(),Xs=$f(Hf);const Mr=32;function bi(n){let t=0;for(;n>1;)n/=2,t++;return t}function jf(n){return n===0?1:(n--,n|=n>>1,n|=n>>2,n|=n>>4,n|=n>>8,n|=n>>16,n|=n>>32,n+1)}class Gf{constructor(t,e,r,s,i){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=t,this.leaderScheduleSlotOffset=e,this.warmup=r,this.firstNormalEpoch=s,this.firstNormalSlot=i}getEpoch(t){return this.getEpochAndSlotIndex(t)[0]}getEpochAndSlotIndex(t){if(t<this.firstNormalSlot){const e=bi(jf(t+Mr+1))-bi(Mr)-1,r=this.getSlotsInEpoch(e),s=t-(r-Mr);return[e,s]}else{const e=t-this.firstNormalSlot,r=Math.floor(e/this.slotsPerEpoch),s=this.firstNormalEpoch+r,i=e%this.slotsPerEpoch;return[s,i]}}getFirstSlotInEpoch(t){return t<=this.firstNormalEpoch?(Math.pow(2,t)-1)*Mr:(t-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(t){return this.getFirstSlotInEpoch(t)+this.getSlotsInEpoch(t)-1}getSlotsInEpoch(t){return t<this.firstNormalEpoch?Math.pow(2,t+bi(Mr)):this.slotsPerEpoch}}var Zf=globalThis.fetch;class Yf extends of{constructor(t,e,r){const s=i=>{const o=nf(i,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...e});return"socket"in o?this.underlyingSocket=o.socket:this.underlyingSocket=o,o};super(s,t,e,r),this.underlyingSocket=void 0}call(...t){const e=this.underlyingSocket?.readyState;return e===1?super.call(...t):Promise.reject(new Error("Tried to call a JSON-RPC method `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}notify(...t){const e=this.underlyingSocket?.readyState;return e===1?super.notify(...t):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}}function Xf(n,t){let e;try{e=n.layout.decode(t)}catch(r){throw new Error("invalid instruction; "+r)}if(e.typeIndex!==n.index)throw new Error(`invalid account data; account type mismatch ${e.typeIndex} != ${n.index}`);return e}const Js=56;class Qs{constructor(t){this.key=void 0,this.state=void 0,this.key=t.key,this.state=t.state}isActive(){const t=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===t}static deserialize(t){const e=Xf(Jf,t),r=t.length-Js;bt(r>=0,"lookup table is invalid"),bt(r%32===0,"lookup table is invalid");const s=r/32,{addresses:i}=P.struct([P.seq(mt(),s,"addresses")]).decode(t.slice(Js));return{deactivationSlot:e.deactivationSlot,lastExtendedSlot:e.lastExtendedSlot,lastExtendedSlotStartIndex:e.lastExtendedStartIndex,authority:e.authority.length!==0?new tt(e.authority[0]):void 0,addresses:i.map(o=>new tt(o))}}}const Jf={index:1,layout:P.struct([P.u32("typeIndex"),xr("deactivationSlot"),P.nu64("lastExtendedSlot"),P.u8("lastExtendedStartIndex"),P.u8(),P.seq(mt(),P.offset(P.u8(),-1),"authority")])},Qf=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function tl(n){const t=n.match(Qf);if(t==null)throw TypeError(`Failed to validate endpoint URL \`${n}\``);const[e,r,s,i]=t,o=n.startsWith("https:")?"wss:":"ws:",u=s==null?null:parseInt(s.slice(1),10),d=u==null?"":`:${u+1}`;return`${o}//${r}${d}${i}`}const Ot=Wr(Di(tt),J(),n=>new tt(n)),ka=Wi([J(),Ut("base64")]),Yi=Wr(Di(ft.Buffer),ka,n=>ft.Buffer.from(n[0],"base64")),el=30*1e3;function rl(n){if(/^https?:/.test(n)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return n}function At(n){let t,e;if(typeof n=="string")t=n;else if(n){const{commitment:r,...s}=n;t=r,e=s}return{commitment:t,config:e}}function to(n){return n.map(t=>"memcmp"in t?{...t,memcmp:{...t.memcmp,encoding:t.memcmp.encoding??"base58"}}:t)}function va(n){return be([Z({jsonrpc:Ut("2.0"),id:J(),result:n}),Z({jsonrpc:Ut("2.0"),id:J(),error:Z({code:_r(),message:J(),data:ut(Ru())})})])}const nl=va(_r());function gt(n){return Wr(va(n),nl,t=>"error"in t?t:{...t,result:et(t.result,n)})}function Wt(n){return gt(Z({context:Z({slot:D()}),value:n}))}function _n(n){return Z({context:Z({slot:D()}),value:n})}function ki(n,t){return n===0?new Sr({header:t.header,staticAccountKeys:t.accountKeys.map(e=>new tt(e)),recentBlockhash:t.recentBlockhash,compiledInstructions:t.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:le.decode(e.data)})),addressTableLookups:t.addressTableLookups}):new Ce(t)}const il=Z({foundation:D(),foundationTerm:D(),initial:D(),taper:D(),terminal:D()}),sl=gt(nt(it(Z({epoch:D(),effectiveSlot:D(),amount:D(),postBalance:D(),commission:ut(it(D()))})))),ol=nt(Z({slot:D(),prioritizationFee:D()})),al=Z({total:D(),validator:D(),foundation:D(),epoch:D()}),cl=Z({epoch:D(),slotIndex:D(),slotsInEpoch:D(),absoluteSlot:D(),blockHeight:ut(D()),transactionCount:ut(D())}),ul=Z({slotsPerEpoch:D(),leaderScheduleSlotOffset:D(),warmup:Le(),firstNormalEpoch:D(),firstNormalSlot:D()}),fl=jo(J(),nt(D())),fr=it(be([Z({}),J()])),ll=Z({err:fr}),hl=Ut("receivedSignature"),dl=Z({"solana-core":J(),"feature-set":ut(D())}),pl=Z({program:J(),programId:Ot,parsed:_r()}),gl=Z({programId:Ot,accounts:nt(Ot),data:J()}),eo=Wt(Z({err:it(be([Z({}),J()])),logs:it(nt(J())),accounts:ut(it(nt(it(Z({executable:Le(),owner:J(),lamports:D(),data:nt(J()),rentEpoch:ut(D())}))))),unitsConsumed:ut(D()),returnData:ut(it(Z({programId:J(),data:Wi([J(),Ut("base64")])}))),innerInstructions:ut(it(nt(Z({index:D(),instructions:nt(be([pl,gl]))}))))})),yl=Wt(Z({byIdentity:jo(J(),nt(D())),range:Z({firstSlot:D(),lastSlot:D()})}));function ml(n,t,e,r,s,i){const o=e||Zf;let u;i!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let d;return r&&(d=async(I,B)=>{const A=await new Promise((S,M)=>{try{r(I,B,(R,L)=>S([R,L]))}catch(R){M(R)}});return await o(...A)}),new Qu(async(I,B)=>{const A={method:"POST",body:I,agent:u,headers:Object.assign({"Content-Type":"application/json"},t||{},mh)};try{let S=5,M,R=500;for(;d?M=await d(n,A):M=await o(n,A),!(M.status!==429||s===!0||(S-=1,S===0));)console.error(`Server responded with ${M.status} ${M.statusText}.  Retrying after ${R}ms delay...`),await tr(R),R*=2;const L=await M.text();M.ok?B(null,L):B(new Error(`${M.status} ${M.statusText}: ${L}`))}catch(S){S instanceof Error&&B(S)}},{})}function wl(n){return(t,e)=>new Promise((r,s)=>{n.request(t,e,(i,o)=>{if(i){s(i);return}r(o)})})}function bl(n){return t=>new Promise((e,r)=>{t.length===0&&e([]);const s=t.map(i=>n.request(i.methodName,i.args));n.request(s,(i,o)=>{if(i){r(i);return}e(o)})})}const kl=gt(il),vl=gt(al),Sl=gt(ol),xl=gt(cl),El=gt(ul),Il=gt(fl),_l=gt(D()),Al=Wt(Z({total:D(),circulating:D(),nonCirculating:D(),nonCirculatingAccounts:nt(Ot)})),Bi=Z({amount:J(),uiAmount:it(D()),decimals:D(),uiAmountString:ut(J())}),Bl=Wt(nt(Z({address:Ot,amount:J(),uiAmount:it(D()),decimals:D(),uiAmountString:ut(J())}))),Rl=Wt(nt(Z({pubkey:Ot,account:Z({executable:Le(),owner:Ot,lamports:D(),data:Yi,rentEpoch:D()})}))),Ri=Z({program:J(),parsed:_r(),space:D()}),Ml=Wt(nt(Z({pubkey:Ot,account:Z({executable:Le(),owner:Ot,lamports:D(),data:Ri,rentEpoch:D()})}))),Tl=Wt(nt(Z({lamports:D(),address:Ot}))),Nr=Z({executable:Le(),owner:Ot,lamports:D(),data:Yi,rentEpoch:D()}),Pl=Z({pubkey:Ot,account:Nr}),Ll=Wr(be([Di(ft.Buffer),Ri]),be([ka,Ri]),n=>Array.isArray(n)?et(n,Yi):n),Mi=Z({executable:Le(),owner:Ot,lamports:D(),data:Ll,rentEpoch:D()}),Cl=Z({pubkey:Ot,account:Mi}),Ul=Z({state:be([Ut("active"),Ut("inactive"),Ut("activating"),Ut("deactivating")]),active:D(),inactive:D()}),Ol=gt(nt(Z({signature:J(),slot:D(),err:fr,memo:it(J()),blockTime:ut(it(D()))}))),Nl=gt(nt(Z({signature:J(),slot:D(),err:fr,memo:it(J()),blockTime:ut(it(D()))}))),Fl=Z({subscription:D(),result:_n(Nr)}),zl=Z({pubkey:Ot,account:Nr}),Kl=Z({subscription:D(),result:_n(zl)}),ql=Z({parent:D(),slot:D(),root:D()}),Dl=Z({subscription:D(),result:ql}),Wl=be([Z({type:be([Ut("firstShredReceived"),Ut("completed"),Ut("optimisticConfirmation"),Ut("root")]),slot:D(),timestamp:D()}),Z({type:Ut("createdBank"),parent:D(),slot:D(),timestamp:D()}),Z({type:Ut("frozen"),slot:D(),timestamp:D(),stats:Z({numTransactionEntries:D(),numSuccessfulTransactions:D(),numFailedTransactions:D(),maxTransactionsPerEntry:D()})}),Z({type:Ut("dead"),slot:D(),timestamp:D(),err:J()})]),$l=Z({subscription:D(),result:Wl}),Vl=Z({subscription:D(),result:_n(be([ll,hl]))}),Hl=Z({subscription:D(),result:D()}),jl=Z({pubkey:J(),gossip:it(J()),tpu:it(J()),rpc:it(J()),version:it(J())}),ro=Z({votePubkey:J(),nodePubkey:J(),activatedStake:D(),epochVoteAccount:Le(),epochCredits:nt(Wi([D(),D(),D()])),commission:D(),lastVote:D(),rootSlot:it(D())}),Gl=gt(Z({current:nt(ro),delinquent:nt(ro)})),Zl=be([Ut("processed"),Ut("confirmed"),Ut("finalized")]),Yl=Z({slot:D(),confirmations:it(D()),err:fr,confirmationStatus:ut(Zl)}),Xl=Wt(nt(it(Yl))),Jl=gt(D()),Sa=Z({accountKey:Ot,writableIndexes:nt(D()),readonlyIndexes:nt(D())}),Xi=Z({signatures:nt(J()),message:Z({accountKeys:nt(J()),header:Z({numRequiredSignatures:D(),numReadonlySignedAccounts:D(),numReadonlyUnsignedAccounts:D()}),instructions:nt(Z({accounts:nt(D()),data:J(),programIdIndex:D()})),recentBlockhash:J(),addressTableLookups:ut(nt(Sa))})}),xa=Z({pubkey:Ot,signer:Le(),writable:Le(),source:ut(be([Ut("transaction"),Ut("lookupTable")]))}),Ea=Z({accountKeys:nt(xa),signatures:nt(J())}),Ia=Z({parsed:_r(),program:J(),programId:Ot}),_a=Z({accounts:nt(Ot),data:J(),programId:Ot}),Ql=be([_a,Ia]),th=be([Z({parsed:_r(),program:J(),programId:J()}),Z({accounts:nt(J()),data:J(),programId:J()})]),Aa=Wr(Ql,th,n=>"accounts"in n?et(n,_a):et(n,Ia)),Ba=Z({signatures:nt(J()),message:Z({accountKeys:nt(xa),instructions:nt(Aa),recentBlockhash:J(),addressTableLookups:ut(it(nt(Sa)))})}),mn=Z({accountIndex:D(),mint:J(),owner:ut(J()),programId:ut(J()),uiTokenAmount:Bi}),Ra=Z({writable:nt(Ot),readonly:nt(Ot)}),An=Z({err:fr,fee:D(),innerInstructions:ut(it(nt(Z({index:D(),instructions:nt(Z({accounts:nt(D()),data:J(),programIdIndex:D()}))})))),preBalances:nt(D()),postBalances:nt(D()),logMessages:ut(it(nt(J()))),preTokenBalances:ut(it(nt(mn))),postTokenBalances:ut(it(nt(mn))),loadedAddresses:ut(Ra),computeUnitsConsumed:ut(D()),costUnits:ut(D())}),Ji=Z({err:fr,fee:D(),innerInstructions:ut(it(nt(Z({index:D(),instructions:nt(Aa)})))),preBalances:nt(D()),postBalances:nt(D()),logMessages:ut(it(nt(J()))),preTokenBalances:ut(it(nt(mn))),postTokenBalances:ut(it(nt(mn))),loadedAddresses:ut(Ra),computeUnitsConsumed:ut(D()),costUnits:ut(D())}),Ar=be([Ut(0),Ut("legacy")]),lr=Z({pubkey:J(),lamports:D(),postBalance:it(D()),rewardType:it(J()),commission:ut(it(D()))}),eh=gt(it(Z({blockhash:J(),previousBlockhash:J(),parentSlot:D(),transactions:nt(Z({transaction:Xi,meta:it(An),version:ut(Ar)})),rewards:ut(nt(lr)),blockTime:it(D()),blockHeight:it(D())}))),rh=gt(it(Z({blockhash:J(),previousBlockhash:J(),parentSlot:D(),rewards:ut(nt(lr)),blockTime:it(D()),blockHeight:it(D())}))),nh=gt(it(Z({blockhash:J(),previousBlockhash:J(),parentSlot:D(),transactions:nt(Z({transaction:Ea,meta:it(An),version:ut(Ar)})),rewards:ut(nt(lr)),blockTime:it(D()),blockHeight:it(D())}))),ih=gt(it(Z({blockhash:J(),previousBlockhash:J(),parentSlot:D(),transactions:nt(Z({transaction:Ba,meta:it(Ji),version:ut(Ar)})),rewards:ut(nt(lr)),blockTime:it(D()),blockHeight:it(D())}))),sh=gt(it(Z({blockhash:J(),previousBlockhash:J(),parentSlot:D(),transactions:nt(Z({transaction:Ea,meta:it(Ji),version:ut(Ar)})),rewards:ut(nt(lr)),blockTime:it(D()),blockHeight:it(D())}))),oh=gt(it(Z({blockhash:J(),previousBlockhash:J(),parentSlot:D(),rewards:ut(nt(lr)),blockTime:it(D()),blockHeight:it(D())}))),ah=gt(it(Z({blockhash:J(),previousBlockhash:J(),parentSlot:D(),transactions:nt(Z({transaction:Xi,meta:it(An)})),rewards:ut(nt(lr)),blockTime:it(D())}))),no=gt(it(Z({blockhash:J(),previousBlockhash:J(),parentSlot:D(),signatures:nt(J()),blockTime:it(D())}))),vi=gt(it(Z({slot:D(),meta:it(An),blockTime:ut(it(D())),transaction:Xi,version:ut(Ar)}))),en=gt(it(Z({slot:D(),transaction:Ba,meta:it(Ji),blockTime:ut(it(D())),version:ut(Ar)}))),ch=Wt(Z({blockhash:J(),lastValidBlockHeight:D()})),uh=Wt(Le()),fh=Z({slot:D(),numTransactions:D(),numSlots:D(),samplePeriodSecs:D()}),lh=gt(nt(fh)),hh=Wt(it(Z({feeCalculator:Z({lamportsPerSignature:D()})}))),dh=gt(J()),ph=gt(J()),gh=Z({err:fr,logs:nt(J()),signature:J()}),yh=Z({result:_n(gh),subscription:D()}),mh={"solana-client":"js/1.0.0-maintenance"};class Vh{constructor(t,e){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const b={};return async I=>{const{commitment:B,config:A}=At(I),S=this._buildArgs([],B,void 0,A),M=Xs(S);return b[M]=b[M]??(async()=>{try{const R=await this._rpcRequest("getBlockHeight",S),L=et(R,gt(D()));if("error"in L)throw new at(L.error,"failed to get block height information");return L.result}finally{delete b[M]}})(),await b[M]}})();let r,s,i,o,u,d;e&&typeof e=="string"?this._commitment=e:e&&(this._commitment=e.commitment,this._confirmTransactionInitialTimeout=e.confirmTransactionInitialTimeout,r=e.wsEndpoint,s=e.httpHeaders,i=e.fetch,o=e.fetchMiddleware,u=e.disableRetryOnRateLimit,d=e.httpAgent),this._rpcEndpoint=rl(t),this._rpcWsEndpoint=r||tl(t),this._rpcClient=ml(t,s,i,o,u,d),this._rpcRequest=wl(this._rpcClient),this._rpcBatchRequest=bl(this._rpcClient),this._rpcWebSocket=new Yf(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(t,e){const{commitment:r,config:s}=At(e),i=this._buildArgs([t.toBase58()],r,void 0,s),o=await this._rpcRequest("getBalance",i),u=et(o,Wt(D()));if("error"in u)throw new at(u.error,`failed to get balance for ${t.toBase58()}`);return u.result}async getBalance(t,e){return await this.getBalanceAndContext(t,e).then(r=>r.value).catch(r=>{throw new Error("failed to get balance of account "+t.toBase58()+": "+r)})}async getBlockTime(t){const e=await this._rpcRequest("getBlockTime",[t]),r=et(e,gt(it(D())));if("error"in r)throw new at(r.error,`failed to get block time for slot ${t}`);return r.result}async getMinimumLedgerSlot(){const t=await this._rpcRequest("minimumLedgerSlot",[]),e=et(t,gt(D()));if("error"in e)throw new at(e.error,"failed to get minimum ledger slot");return e.result}async getFirstAvailableBlock(){const t=await this._rpcRequest("getFirstAvailableBlock",[]),e=et(t,_l);if("error"in e)throw new at(e.error,"failed to get first available block");return e.result}async getSupply(t){let e={};typeof t=="string"?e={commitment:t}:t?e={...t,commitment:t&&t.commitment||this.commitment}:e={commitment:this.commitment};const r=await this._rpcRequest("getSupply",[e]),s=et(r,Al);if("error"in s)throw new at(s.error,"failed to get supply");return s.result}async getTokenSupply(t,e){const r=this._buildArgs([t.toBase58()],e),s=await this._rpcRequest("getTokenSupply",r),i=et(s,Wt(Bi));if("error"in i)throw new at(i.error,"failed to get token supply");return i.result}async getTokenAccountBalance(t,e){const r=this._buildArgs([t.toBase58()],e),s=await this._rpcRequest("getTokenAccountBalance",r),i=et(s,Wt(Bi));if("error"in i)throw new at(i.error,"failed to get token account balance");return i.result}async getTokenAccountsByOwner(t,e,r){const{commitment:s,config:i}=At(r);let o=[t.toBase58()];"mint"in e?o.push({mint:e.mint.toBase58()}):o.push({programId:e.programId.toBase58()});const u=this._buildArgs(o,s,"base64",i),d=await this._rpcRequest("getTokenAccountsByOwner",u),b=et(d,Rl);if("error"in b)throw new at(b.error,`failed to get token accounts owned by account ${t.toBase58()}`);return b.result}async getParsedTokenAccountsByOwner(t,e,r){let s=[t.toBase58()];"mint"in e?s.push({mint:e.mint.toBase58()}):s.push({programId:e.programId.toBase58()});const i=this._buildArgs(s,r,"jsonParsed"),o=await this._rpcRequest("getTokenAccountsByOwner",i),u=et(o,Ml);if("error"in u)throw new at(u.error,`failed to get token accounts owned by account ${t.toBase58()}`);return u.result}async getLargestAccounts(t){const e={...t,commitment:t&&t.commitment||this.commitment},r=e.filter||e.commitment?[e]:[],s=await this._rpcRequest("getLargestAccounts",r),i=et(s,Tl);if("error"in i)throw new at(i.error,"failed to get largest accounts");return i.result}async getTokenLargestAccounts(t,e){const r=this._buildArgs([t.toBase58()],e),s=await this._rpcRequest("getTokenLargestAccounts",r),i=et(s,Bl);if("error"in i)throw new at(i.error,"failed to get token largest accounts");return i.result}async getAccountInfoAndContext(t,e){const{commitment:r,config:s}=At(e),i=this._buildArgs([t.toBase58()],r,"base64",s),o=await this._rpcRequest("getAccountInfo",i),u=et(o,Wt(it(Nr)));if("error"in u)throw new at(u.error,`failed to get info about account ${t.toBase58()}`);return u.result}async getParsedAccountInfo(t,e){const{commitment:r,config:s}=At(e),i=this._buildArgs([t.toBase58()],r,"jsonParsed",s),o=await this._rpcRequest("getAccountInfo",i),u=et(o,Wt(it(Mi)));if("error"in u)throw new at(u.error,`failed to get info about account ${t.toBase58()}`);return u.result}async getAccountInfo(t,e){try{return(await this.getAccountInfoAndContext(t,e)).value}catch(r){throw new Error("failed to get info about account "+t.toBase58()+": "+r)}}async getMultipleParsedAccounts(t,e){const{commitment:r,config:s}=At(e),i=t.map(b=>b.toBase58()),o=this._buildArgs([i],r,"jsonParsed",s),u=await this._rpcRequest("getMultipleAccounts",o),d=et(u,Wt(nt(it(Mi))));if("error"in d)throw new at(d.error,`failed to get info for accounts ${i}`);return d.result}async getMultipleAccountsInfoAndContext(t,e){const{commitment:r,config:s}=At(e),i=t.map(b=>b.toBase58()),o=this._buildArgs([i],r,"base64",s),u=await this._rpcRequest("getMultipleAccounts",o),d=et(u,Wt(nt(it(Nr))));if("error"in d)throw new at(d.error,`failed to get info for accounts ${i}`);return d.result}async getMultipleAccountsInfo(t,e){return(await this.getMultipleAccountsInfoAndContext(t,e)).value}async getStakeActivation(t,e,r){const{commitment:s,config:i}=At(e),o=this._buildArgs([t.toBase58()],s,void 0,{...i,epoch:r??i?.epoch}),u=await this._rpcRequest("getStakeActivation",o),d=et(u,gt(Ul));if("error"in d)throw new at(d.error,`failed to get Stake Activation ${t.toBase58()}`);return d.result}async getProgramAccounts(t,e){const{commitment:r,config:s}=At(e),{encoding:i,...o}=s||{},u=this._buildArgs([t.toBase58()],r,i||"base64",{...o,...o.filters?{filters:to(o.filters)}:null}),d=await this._rpcRequest("getProgramAccounts",u),b=nt(Pl),I=o.withContext===!0?et(d,Wt(b)):et(d,gt(b));if("error"in I)throw new at(I.error,`failed to get accounts owned by program ${t.toBase58()}`);return I.result}async getParsedProgramAccounts(t,e){const{commitment:r,config:s}=At(e),i=this._buildArgs([t.toBase58()],r,"jsonParsed",s),o=await this._rpcRequest("getProgramAccounts",i),u=et(o,gt(nt(Cl)));if("error"in u)throw new at(u.error,`failed to get accounts owned by program ${t.toBase58()}`);return u.result}async confirmTransaction(t,e){let r;if(typeof t=="string")r=t;else{const i=t;if(i.abortSignal?.aborted)return Promise.reject(i.abortSignal.reason);r=i.signature}let s;try{s=le.decode(r)}catch{throw new Error("signature must be base58 encoded: "+r)}return bt(s.length===64,"signature has invalid length"),typeof t=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:e||this.commitment,signature:r}):"lastValidBlockHeight"in t?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e||this.commitment,strategy:t}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:e||this.commitment,strategy:t})}getCancellationPromise(t){return new Promise((e,r)=>{t!=null&&(t.aborted?r(t.reason):t.addEventListener("abort",()=>{r(t.reason)}))})}getTransactionConfirmationPromise({commitment:t,signature:e}){let r,s,i=!1;const o=new Promise((d,b)=>{try{r=this.onSignature(e,(B,A)=>{r=void 0;const S={context:A,value:B};d({__type:Ye.PROCESSED,response:S})},t);const I=new Promise(B=>{r==null?B():s=this._onSubscriptionStateChange(r,A=>{A==="subscribed"&&B()})});(async()=>{if(await I,i)return;const B=await this.getSignatureStatus(e);if(i||B==null)return;const{context:A,value:S}=B;if(S!=null)if(S?.err)b(S.err);else{switch(t){case"confirmed":case"single":case"singleGossip":{if(S.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(S.confirmationStatus==="processed"||S.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}i=!0,d({__type:Ye.PROCESSED,response:{context:A,value:S}})}})()}catch(I){b(I)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),r!=null&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:o}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t,strategy:{abortSignal:e,lastValidBlockHeight:r,signature:s}}){let i=!1;const o=new Promise(B=>{const A=async()=>{try{return await this.getBlockHeight(t)}catch{return-1}};(async()=>{let S=await A();if(!i){for(;S<=r;)if(await tr(1e3),i||(S=await A(),i))return;B({__type:Ye.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:u,confirmationPromise:d}=this.getTransactionConfirmationPromise({commitment:t,signature:s}),b=this.getCancellationPromise(e);let I;try{const B=await Promise.race([b,d,o]);if(B.__type===Ye.PROCESSED)I=B.response;else throw new la(s)}finally{i=!0,u()}return I}async confirmTransactionUsingDurableNonceStrategy({commitment:t,strategy:{abortSignal:e,minContextSlot:r,nonceAccountPubkey:s,nonceValue:i,signature:o}}){let u=!1;const d=new Promise(S=>{let M=i,R=null;const L=async()=>{try{const{context:F,value:H}=await this.getNonceAndContext(s,{commitment:t,minContextSlot:r});return R=F.slot,H?.nonce}catch{return M}};(async()=>{if(M=await L(),!u)for(;;){if(i!==M){S({__type:Ye.NONCE_INVALID,slotInWhichNonceDidAdvance:R});return}if(await tr(2e3),u||(M=await L(),u))return}})()}),{abortConfirmation:b,confirmationPromise:I}=this.getTransactionConfirmationPromise({commitment:t,signature:o}),B=this.getCancellationPromise(e);let A;try{const S=await Promise.race([B,I,d]);if(S.__type===Ye.PROCESSED)A=S.response;else{let M;for(;;){const R=await this.getSignatureStatus(o);if(R==null)break;if(R.context.slot<(S.slotInWhichNonceDidAdvance??r)){await tr(400);continue}M=R;break}if(M?.value){const R=t||"finalized",{confirmationStatus:L}=M.value;switch(R){case"processed":case"recent":if(L!=="processed"&&L!=="confirmed"&&L!=="finalized")throw new Tr(o);break;case"confirmed":case"single":case"singleGossip":if(L!=="confirmed"&&L!=="finalized")throw new Tr(o);break;case"finalized":case"max":case"root":if(L!=="finalized")throw new Tr(o);break;default:}A={context:M.context,value:{err:M.value.err}}}else throw new Tr(o)}}finally{u=!0,b()}return A}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:t,signature:e}){let r;const s=new Promise(d=>{let b=this._confirmTransactionInitialTimeout||6e4;switch(t){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{b=this._confirmTransactionInitialTimeout||3e4;break}}r=setTimeout(()=>d({__type:Ye.TIMED_OUT,timeoutMs:b}),b)}),{abortConfirmation:i,confirmationPromise:o}=this.getTransactionConfirmationPromise({commitment:t,signature:e});let u;try{const d=await Promise.race([o,s]);if(d.__type===Ye.PROCESSED)u=d.response;else throw new ha(e,d.timeoutMs/1e3)}finally{clearTimeout(r),i()}return u}async getClusterNodes(){const t=await this._rpcRequest("getClusterNodes",[]),e=et(t,gt(nt(jl)));if("error"in e)throw new at(e.error,"failed to get cluster nodes");return e.result}async getVoteAccounts(t){const e=this._buildArgs([],t),r=await this._rpcRequest("getVoteAccounts",e),s=et(r,Gl);if("error"in s)throw new at(s.error,"failed to get vote accounts");return s.result}async getSlot(t){const{commitment:e,config:r}=At(t),s=this._buildArgs([],e,void 0,r),i=await this._rpcRequest("getSlot",s),o=et(i,gt(D()));if("error"in o)throw new at(o.error,"failed to get slot");return o.result}async getSlotLeader(t){const{commitment:e,config:r}=At(t),s=this._buildArgs([],e,void 0,r),i=await this._rpcRequest("getSlotLeader",s),o=et(i,gt(J()));if("error"in o)throw new at(o.error,"failed to get slot leader");return o.result}async getSlotLeaders(t,e){const r=[t,e],s=await this._rpcRequest("getSlotLeaders",r),i=et(s,gt(nt(Ot)));if("error"in i)throw new at(i.error,"failed to get slot leaders");return i.result}async getSignatureStatus(t,e){const{context:r,value:s}=await this.getSignatureStatuses([t],e);bt(s.length===1);const i=s[0];return{context:r,value:i}}async getSignatureStatuses(t,e){const r=[t];e&&r.push(e);const s=await this._rpcRequest("getSignatureStatuses",r),i=et(s,Xl);if("error"in i)throw new at(i.error,"failed to get signature status");return i.result}async getTransactionCount(t){const{commitment:e,config:r}=At(t),s=this._buildArgs([],e,void 0,r),i=await this._rpcRequest("getTransactionCount",s),o=et(i,gt(D()));if("error"in o)throw new at(o.error,"failed to get transaction count");return o.result}async getTotalSupply(t){return(await this.getSupply({commitment:t,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(t){const e=this._buildArgs([],t),r=await this._rpcRequest("getInflationGovernor",e),s=et(r,kl);if("error"in s)throw new at(s.error,"failed to get inflation");return s.result}async getInflationReward(t,e,r){const{commitment:s,config:i}=At(r),o=this._buildArgs([t.map(b=>b.toBase58())],s,void 0,{...i,epoch:e??i?.epoch}),u=await this._rpcRequest("getInflationReward",o),d=et(u,sl);if("error"in d)throw new at(d.error,"failed to get inflation reward");return d.result}async getInflationRate(){const t=await this._rpcRequest("getInflationRate",[]),e=et(t,vl);if("error"in e)throw new at(e.error,"failed to get inflation rate");return e.result}async getEpochInfo(t){const{commitment:e,config:r}=At(t),s=this._buildArgs([],e,void 0,r),i=await this._rpcRequest("getEpochInfo",s),o=et(i,xl);if("error"in o)throw new at(o.error,"failed to get epoch info");return o.result}async getEpochSchedule(){const t=await this._rpcRequest("getEpochSchedule",[]),e=et(t,El);if("error"in e)throw new at(e.error,"failed to get epoch schedule");const r=e.result;return new Gf(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const t=await this._rpcRequest("getLeaderSchedule",[]),e=et(t,Il);if("error"in e)throw new at(e.error,"failed to get leader schedule");return e.result}async getMinimumBalanceForRentExemption(t,e){const r=this._buildArgs([t],e),s=await this._rpcRequest("getMinimumBalanceForRentExemption",r),i=et(s,Jl);return"error"in i?(console.warn("Unable to fetch minimum balance for rent exemption"),0):i.result}async getRecentBlockhashAndContext(t){const{context:e,value:{blockhash:r}}=await this.getLatestBlockhashAndContext(t);return{context:e,value:{blockhash:r,feeCalculator:{get lamportsPerSignature(){throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON(){return{}}}}}}async getRecentPerformanceSamples(t){const e=await this._rpcRequest("getRecentPerformanceSamples",t?[t]:[]),r=et(e,lh);if("error"in r)throw new at(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(t,e){const r=this._buildArgs([t],e),s=await this._rpcRequest("getFeeCalculatorForBlockhash",r),i=et(s,hh);if("error"in i)throw new at(i.error,"failed to get fee calculator");const{context:o,value:u}=i.result;return{context:o,value:u!==null?u.feeCalculator:null}}async getFeeForMessage(t,e){const r=yt(t.serialize()).toString("base64"),s=this._buildArgs([r],e),i=await this._rpcRequest("getFeeForMessage",s),o=et(i,Wt(it(D())));if("error"in o)throw new at(o.error,"failed to get fee for message");if(o.result===null)throw new Error("invalid blockhash");return o.result}async getRecentPrioritizationFees(t){const e=t?.lockedWritableAccounts?.map(o=>o.toBase58()),r=e?.length?[e]:[],s=await this._rpcRequest("getRecentPrioritizationFees",r),i=et(s,Sl);if("error"in i)throw new at(i.error,"failed to get recent prioritization fees");return i.result}async getRecentBlockhash(t){try{return(await this.getRecentBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhash(t){try{return(await this.getLatestBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhashAndContext(t){const{commitment:e,config:r}=At(t),s=this._buildArgs([],e,void 0,r),i=await this._rpcRequest("getLatestBlockhash",s),o=et(i,ch);if("error"in o)throw new at(o.error,"failed to get latest blockhash");return o.result}async isBlockhashValid(t,e){const{commitment:r,config:s}=At(e),i=this._buildArgs([t],r,void 0,s),o=await this._rpcRequest("isBlockhashValid",i),u=et(o,uh);if("error"in u)throw new at(u.error,"failed to determine if the blockhash `"+t+"`is valid");return u.result}async getVersion(){const t=await this._rpcRequest("getVersion",[]),e=et(t,gt(dl));if("error"in e)throw new at(e.error,"failed to get version");return e.result}async getGenesisHash(){const t=await this._rpcRequest("getGenesisHash",[]),e=et(t,gt(J()));if("error"in e)throw new at(e.error,"failed to get genesis hash");return e.result}async getBlock(t,e){const{commitment:r,config:s}=At(e),i=this._buildArgsAtLeastConfirmed([t],r,void 0,s),o=await this._rpcRequest("getBlock",i);try{switch(s?.transactionDetails){case"accounts":{const u=et(o,nh);if("error"in u)throw u.error;return u.result}case"none":{const u=et(o,rh);if("error"in u)throw u.error;return u.result}default:{const u=et(o,eh);if("error"in u)throw u.error;const{result:d}=u;return d?{...d,transactions:d.transactions.map(({transaction:b,meta:I,version:B})=>({meta:I,transaction:{...b,message:ki(B,b.message)},version:B}))}:null}}}catch(u){throw new at(u,"failed to get confirmed block")}}async getParsedBlock(t,e){const{commitment:r,config:s}=At(e),i=this._buildArgsAtLeastConfirmed([t],r,"jsonParsed",s),o=await this._rpcRequest("getBlock",i);try{switch(s?.transactionDetails){case"accounts":{const u=et(o,sh);if("error"in u)throw u.error;return u.result}case"none":{const u=et(o,oh);if("error"in u)throw u.error;return u.result}default:{const u=et(o,ih);if("error"in u)throw u.error;return u.result}}}catch(u){throw new at(u,"failed to get block")}}async getBlockProduction(t){let e,r;if(typeof t=="string")r=t;else if(t){const{commitment:u,...d}=t;r=u,e=d}const s=this._buildArgs([],r,"base64",e),i=await this._rpcRequest("getBlockProduction",s),o=et(i,yl);if("error"in o)throw new at(o.error,"failed to get block production information");return o.result}async getTransaction(t,e){const{commitment:r,config:s}=At(e),i=this._buildArgsAtLeastConfirmed([t],r,void 0,s),o=await this._rpcRequest("getTransaction",i),u=et(o,vi);if("error"in u)throw new at(u.error,"failed to get transaction");const d=u.result;return d&&{...d,transaction:{...d.transaction,message:ki(d.version,d.transaction.message)}}}async getParsedTransaction(t,e){const{commitment:r,config:s}=At(e),i=this._buildArgsAtLeastConfirmed([t],r,"jsonParsed",s),o=await this._rpcRequest("getTransaction",i),u=et(o,en);if("error"in u)throw new at(u.error,"failed to get transaction");return u.result}async getParsedTransactions(t,e){const{commitment:r,config:s}=At(e),i=t.map(d=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([d],r,"jsonParsed",s)}));return(await this._rpcBatchRequest(i)).map(d=>{const b=et(d,en);if("error"in b)throw new at(b.error,"failed to get transactions");return b.result})}async getTransactions(t,e){const{commitment:r,config:s}=At(e),i=t.map(d=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([d],r,void 0,s)}));return(await this._rpcBatchRequest(i)).map(d=>{const b=et(d,vi);if("error"in b)throw new at(b.error,"failed to get transactions");const I=b.result;return I&&{...I,transaction:{...I.transaction,message:ki(I.version,I.transaction.message)}}})}async getConfirmedBlock(t,e){const r=this._buildArgsAtLeastConfirmed([t],e),s=await this._rpcRequest("getBlock",r),i=et(s,ah);if("error"in i)throw new at(i.error,"failed to get confirmed block");const o=i.result;if(!o)throw new Error("Confirmed block "+t+" not found");const u={...o,transactions:o.transactions.map(({transaction:d,meta:b})=>{const I=new Ce(d.message);return{meta:b,transaction:{...d,message:I}}})};return{...u,transactions:u.transactions.map(({transaction:d,meta:b})=>({meta:b,transaction:xt.populate(d.message,d.signatures)}))}}async getBlocks(t,e,r){const s=this._buildArgsAtLeastConfirmed(e!==void 0?[t,e]:[t],r),i=await this._rpcRequest("getBlocks",s),o=et(i,gt(nt(D())));if("error"in o)throw new at(o.error,"failed to get blocks");return o.result}async getBlockSignatures(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",r),i=et(s,no);if("error"in i)throw new at(i.error,"failed to get block");const o=i.result;if(!o)throw new Error("Block "+t+" not found");return o}async getConfirmedBlockSignatures(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",r),i=et(s,no);if("error"in i)throw new at(i.error,"failed to get confirmed block");const o=i.result;if(!o)throw new Error("Confirmed block "+t+" not found");return o}async getConfirmedTransaction(t,e){const r=this._buildArgsAtLeastConfirmed([t],e),s=await this._rpcRequest("getTransaction",r),i=et(s,vi);if("error"in i)throw new at(i.error,"failed to get transaction");const o=i.result;if(!o)return o;const u=new Ce(o.transaction.message),d=o.transaction.signatures;return{...o,transaction:xt.populate(u,d)}}async getParsedConfirmedTransaction(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,"jsonParsed"),s=await this._rpcRequest("getTransaction",r),i=et(s,en);if("error"in i)throw new at(i.error,"failed to get confirmed transaction");return i.result}async getParsedConfirmedTransactions(t,e){const r=t.map(o=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([o],e,"jsonParsed")}));return(await this._rpcBatchRequest(r)).map(o=>{const u=et(o,en);if("error"in u)throw new at(u.error,"failed to get confirmed transactions");return u.result})}async getConfirmedSignaturesForAddress(t,e,r){let s={},i=await this.getFirstAvailableBlock();for(;!("until"in s)&&(e--,!(e<=0||e<i));)try{const d=await this.getConfirmedBlockSignatures(e,"finalized");d.signatures.length>0&&(s.until=d.signatures[d.signatures.length-1].toString())}catch(d){if(d instanceof Error&&d.message.includes("skipped"))continue;throw d}let o=await this.getSlot("finalized");for(;!("before"in s)&&(r++,!(r>o));)try{const d=await this.getConfirmedBlockSignatures(r);d.signatures.length>0&&(s.before=d.signatures[d.signatures.length-1].toString())}catch(d){if(d instanceof Error&&d.message.includes("skipped"))continue;throw d}return(await this.getConfirmedSignaturesForAddress2(t,s)).map(d=>d.signature)}async getConfirmedSignaturesForAddress2(t,e,r){const s=this._buildArgsAtLeastConfirmed([t.toBase58()],r,void 0,e),i=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),o=et(i,Ol);if("error"in o)throw new at(o.error,"failed to get confirmed signatures for address");return o.result}async getSignaturesForAddress(t,e,r){const s=this._buildArgsAtLeastConfirmed([t.toBase58()],r,void 0,e),i=await this._rpcRequest("getSignaturesForAddress",s),o=et(i,Nl);if("error"in o)throw new at(o.error,"failed to get signatures for address");return o.result}async getAddressLookupTable(t,e){const{context:r,value:s}=await this.getAccountInfoAndContext(t,e);let i=null;return s!==null&&(i=new Qs({key:t,state:Qs.deserialize(s.data)})),{context:r,value:i}}async getNonceAndContext(t,e){const{context:r,value:s}=await this.getAccountInfoAndContext(t,e);let i=null;return s!==null&&(i=Zi.fromAccountData(s.data)),{context:r,value:i}}async getNonce(t,e){return await this.getNonceAndContext(t,e).then(r=>r.value).catch(r=>{throw new Error("failed to get nonce for account "+t.toBase58()+": "+r)})}async requestAirdrop(t,e){const r=await this._rpcRequest("requestAirdrop",[t.toBase58(),e]),s=et(r,dh);if("error"in s)throw new at(s.error,`airdrop to ${t.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(t){if(!t){for(;this._pollingBlockhash;)await tr(100);const r=Date.now()-this._blockhashInfo.lastFetch>=el;if(this._blockhashInfo.latestBlockhash!==null&&!r)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const t=Date.now(),e=this._blockhashInfo.latestBlockhash,r=e?e.blockhash:null;for(let s=0;s<50;s++){const i=await this.getLatestBlockhash("finalized");if(r!==i.blockhash)return this._blockhashInfo={latestBlockhash:i,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},i;await tr(wa/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-t}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(t){const{commitment:e,config:r}=At(t),s=this._buildArgs([],e,"base64",r),i=await this._rpcRequest("getStakeMinimumDelegation",s),o=et(i,Wt(D()));if("error"in o)throw new at(o.error,"failed to get stake minimum delegation");return o.result}async simulateTransaction(t,e,r){if("message"in t){const R=t.serialize(),L=ft.Buffer.from(R).toString("base64");if(Array.isArray(e)||r!==void 0)throw new Error("Invalid arguments");const F=e||{};F.encoding="base64","commitment"in F||(F.commitment=this.commitment),e&&typeof e=="object"&&"innerInstructions"in e&&(F.innerInstructions=e.innerInstructions);const H=[L,F],K=await this._rpcRequest("simulateTransaction",H),X=et(K,eo);if("error"in X)throw new Error("failed to simulate transaction: "+X.error.message);return X.result}let s;if(t instanceof xt){let M=t;s=new xt,s.feePayer=M.feePayer,s.instructions=t.instructions,s.nonceInfo=M.nonceInfo,s.signatures=M.signatures}else s=xt.populate(t),s._message=s._json=void 0;if(e!==void 0&&!Array.isArray(e))throw new Error("Invalid arguments");const i=e;if(s.nonceInfo&&i)s.sign(...i);else{let M=this._disableBlockhashCaching;for(;;){const R=await this._blockhashWithExpiryBlockHeight(M);if(s.lastValidBlockHeight=R.lastValidBlockHeight,s.recentBlockhash=R.blockhash,!i)break;if(s.sign(...i),!s.signature)throw new Error("!signature");const L=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(L)&&!this._blockhashInfo.transactionSignatures.includes(L)){this._blockhashInfo.simulatedSignatures.push(L);break}else M=!0}}const o=s._compile(),u=o.serialize(),b=s._serialize(u).toString("base64"),I={encoding:"base64",commitment:this.commitment};if(r){const M=(Array.isArray(r)?r:o.nonProgramIds()).map(R=>R.toBase58());I.accounts={encoding:"base64",addresses:M}}i&&(I.sigVerify=!0),e&&typeof e=="object"&&"innerInstructions"in e&&(I.innerInstructions=e.innerInstructions);const B=[b,I],A=await this._rpcRequest("simulateTransaction",B),S=et(A,eo);if("error"in S){let M;if("data"in S.error&&(M=S.error.data.logs,M&&Array.isArray(M))){const R=`
    `,L=R+M.join(R);console.error(S.error.message,L)}throw new yn({action:"simulate",signature:"",transactionMessage:S.error.message,logs:M})}return S.result}async sendTransaction(t,e,r){if("version"in t){if(e&&Array.isArray(e))throw new Error("Invalid arguments");const o=t.serialize();return await this.sendRawTransaction(o,e)}if(e===void 0||!Array.isArray(e))throw new Error("Invalid arguments");const s=e;if(t.nonceInfo)t.sign(...s);else{let o=this._disableBlockhashCaching;for(;;){const u=await this._blockhashWithExpiryBlockHeight(o);if(t.lastValidBlockHeight=u.lastValidBlockHeight,t.recentBlockhash=u.blockhash,t.sign(...s),!t.signature)throw new Error("!signature");const d=t.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(d))o=!0;else{this._blockhashInfo.transactionSignatures.push(d);break}}}const i=t.serialize();return await this.sendRawTransaction(i,r)}async sendRawTransaction(t,e){const r=yt(t).toString("base64");return await this.sendEncodedTransaction(r,e)}async sendEncodedTransaction(t,e){const r={encoding:"base64"},s=e&&e.skipPreflight,i=s===!0?"processed":e&&e.preflightCommitment||this.commitment;e&&e.maxRetries!=null&&(r.maxRetries=e.maxRetries),e&&e.minContextSlot!=null&&(r.minContextSlot=e.minContextSlot),s&&(r.skipPreflight=s),i&&(r.preflightCommitment=i);const o=[t,r],u=await this._rpcRequest("sendTransaction",o),d=et(u,ph);if("error"in d){let b;throw"data"in d.error&&(b=d.error.data.logs),new yn({action:s?"send":"simulate",signature:"",transactionMessage:d.error.message,logs:b})}return d.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(t){this._rpcWebSocketConnected=!1,console.error("ws error:",t.message)}_wsOnClose(t){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),t===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([e,r])=>{this._setSubscription(e,{...r,state:"pending"})})}_setSubscription(t,e){const r=this._subscriptionsByHash[t]?.state;if(this._subscriptionsByHash[t]=e,r!==e.state){const s=this._subscriptionStateChangeCallbacksByHash[t];s&&s.forEach(i=>{try{i(e.state)}catch{}})}}_onSubscriptionStateChange(t,e){const r=this._subscriptionHashByClientSubscriptionId[t];if(r==null)return()=>{};const s=this._subscriptionStateChangeCallbacksByHash[r]||=new Set;return s.add(e),()=>{s.delete(e),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(r){r instanceof Error&&console.log(`Error when closing socket connection: ${r.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const t=this._rpcWebSocketGeneration,e=()=>t===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async r=>{const s=this._subscriptionsByHash[r];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[r],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:i,method:o}=s;try{this._setSubscription(r,{...s,state:"subscribing"});const u=await this._rpcWebSocket.call(o,i);this._setSubscription(r,{...s,serverSubscriptionId:u,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[u]=s.callbacks,await this._updateSubscriptions()}catch(u){if(console.error(`Received ${u instanceof Error?"":"JSON-RPC "}error calling \`${o}\``,{args:i,error:u}),!e())return;this._setSubscription(r,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:i,unsubscribeMethod:o}=s;if(this._subscriptionsAutoDisposedByRpc.has(i))this._subscriptionsAutoDisposedByRpc.delete(i);else{this._setSubscription(r,{...s,state:"unsubscribing"}),this._setSubscription(r,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(o,[i])}catch(u){if(u instanceof Error&&console.error(`${o} error:`,u.message),!e())return;this._setSubscription(r,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(r,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(t,e){const r=this._subscriptionCallbacksByServerSubscriptionId[t];r!==void 0&&r.forEach(s=>{try{s(...e)}catch(i){console.error(i)}})}_wsOnAccountNotification(t){const{result:e,subscription:r}=et(t,Fl);this._handleServerNotification(r,[e.value,e.context])}_makeSubscription(t,e){const r=this._nextClientSubscriptionId++,s=Xs([t.method,e]),i=this._subscriptionsByHash[s];return i===void 0?this._subscriptionsByHash[s]={...t,args:e,callbacks:new Set([t.callback]),state:"pending"}:i.callbacks.add(t.callback),this._subscriptionHashByClientSubscriptionId[r]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const o=this._subscriptionsByHash[s];bt(o!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),o.callbacks.delete(t.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(t,e,r){const{commitment:s,config:i}=At(r),o=this._buildArgs([t.toBase58()],s||this._commitment||"finalized","base64",i);return this._makeSubscription({callback:e,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},o)}async removeAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"account change")}_wsOnProgramAccountNotification(t){const{result:e,subscription:r}=et(t,Kl);this._handleServerNotification(r,[{accountId:e.value.pubkey,accountInfo:e.value.account},e.context])}onProgramAccountChange(t,e,r,s){const{commitment:i,config:o}=At(r),u=this._buildArgs([t.toBase58()],i||this._commitment||"finalized","base64",o||(s?{filters:to(s)}:void 0));return this._makeSubscription({callback:e,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},u)}async removeProgramAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"program account change")}onLogs(t,e,r){const s=this._buildArgs([typeof t=="object"?{mentions:[t.toString()]}:t],r||this._commitment||"finalized");return this._makeSubscription({callback:e,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(t){await this._unsubscribeClientSubscription(t,"logs")}_wsOnLogsNotification(t){const{result:e,subscription:r}=et(t,yh);this._handleServerNotification(r,[e.value,e.context])}_wsOnSlotNotification(t){const{result:e,subscription:r}=et(t,Dl);this._handleServerNotification(r,[e])}onSlotChange(t){return this._makeSubscription({callback:t,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(t){await this._unsubscribeClientSubscription(t,"slot change")}_wsOnSlotUpdatesNotification(t){const{result:e,subscription:r}=et(t,$l);this._handleServerNotification(r,[e])}onSlotUpdate(t){return this._makeSubscription({callback:t,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(t){await this._unsubscribeClientSubscription(t,"slot update")}async _unsubscribeClientSubscription(t,e){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[t];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${t}\` for '${e}' events could not be found.`)}_buildArgs(t,e,r,s){const i=e||this._commitment;if(i||r||s){let o={};r&&(o.encoding=r),i&&(o.commitment=i),s&&(o=Object.assign(o,s)),t.push(o)}return t}_buildArgsAtLeastConfirmed(t,e,r,s){const i=e||this._commitment;if(i&&!["confirmed","finalized"].includes(i))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(t,e,r,s)}_wsOnSignatureNotification(t){const{result:e,subscription:r}=et(t,Vl);e.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,e.value==="receivedSignature"?[{type:"received"},e.context]:[{type:"status",result:e.value},e.context])}onSignature(t,e,r){const s=this._buildArgs([t],r||this._commitment||"finalized"),i=this._makeSubscription({callback:(o,u)=>{if(o.type==="status"){e(o.result,u);try{this.removeSignatureListener(i)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return i}onSignatureWithOptions(t,e,r){const{commitment:s,...i}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},o=this._buildArgs([t],s,void 0,i),u=this._makeSubscription({callback:(d,b)=>{e(d,b);try{this.removeSignatureListener(u)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},o);return u}async removeSignatureListener(t){await this._unsubscribeClientSubscription(t,"signature result")}_wsOnRootNotification(t){const{result:e,subscription:r}=et(t,Hl);this._handleServerNotification(r,[e])}onRootChange(t){return this._makeSubscription({callback:t,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(t){await this._unsubscribeClientSubscription(t,"root change")}}class Pr{constructor(t){this._keypair=void 0,this._keypair=t??Vs()}static generate(){return new Pr(Vs())}static fromSecretKey(t,e){if(t.byteLength!==64)throw new Error("bad secret key size");const r=t.slice(32,64);if(!e||!e.skipValidation){const s=t.slice(0,32),i=dn(s);for(let o=0;o<32;o++)if(r[o]!==i[o])throw new Error("provided secretKey is invalid")}return new Pr({publicKey:r,secretKey:t})}static fromSeed(t){const e=dn(t),r=new Uint8Array(64);return r.set(t),r.set(e,32),new Pr({publicKey:e,secretKey:r})}get publicKey(){return new tt(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const Xe=Object.freeze({CreateLookupTable:{index:0,layout:P.struct([P.u32("instruction"),xr("recentSlot"),P.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:P.struct([P.u32("instruction")])},ExtendLookupTable:{index:2,layout:P.struct([P.u32("instruction"),xr(),P.seq(mt(),P.offset(P.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:P.struct([P.u32("instruction")])},CloseLookupTable:{index:4,layout:P.struct([P.u32("instruction")])}});class Hh{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=P.u32("instruction").decode(t.data);let s;for(const[i,o]of Object.entries(Xe))if(o.index==r){s=i;break}if(!s)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return s}static decodeCreateLookupTable(t){this.checkProgramId(t.programId),this.checkKeysLength(t.keys,4);const{recentSlot:e}=St(Xe.CreateLookupTable,t.data);return{authority:t.keys[1].pubkey,payer:t.keys[2].pubkey,recentSlot:Number(e)}}static decodeExtendLookupTable(t){if(this.checkProgramId(t.programId),t.keys.length<2)throw new Error(`invalid instruction; found ${t.keys.length} keys, expected at least 2`);const{addresses:e}=St(Xe.ExtendLookupTable,t.data);return{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey,payer:t.keys.length>2?t.keys[2].pubkey:void 0,addresses:e.map(r=>new tt(r))}}static decodeCloseLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,3),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey,recipient:t.keys[2].pubkey}}static decodeFreezeLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,2),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey}}static decodeDeactivateLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,2),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey}}static checkProgramId(t){if(!t.equals(Ma.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}class Ma{constructor(){}static createLookupTable(t){const[e,r]=tt.findProgramAddressSync([t.authority.toBuffer(),$o().encode(t.recentSlot)],this.programId),s=Xe.CreateLookupTable,i=wt(s,{recentSlot:BigInt(t.recentSlot),bumpSeed:r}),o=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1},{pubkey:t.payer,isSigner:!0,isWritable:!0},{pubkey:he.programId,isSigner:!1,isWritable:!1}];return[new Bt({programId:this.programId,keys:o,data:i}),e]}static freezeLookupTable(t){const e=Xe.FreezeLookupTable,r=wt(e),s=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return new Bt({programId:this.programId,keys:s,data:r})}static extendLookupTable(t){const e=Xe.ExtendLookupTable,r=wt(e,{addresses:t.addresses.map(i=>i.toBytes())}),s=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return t.payer&&s.push({pubkey:t.payer,isSigner:!0,isWritable:!0},{pubkey:he.programId,isSigner:!1,isWritable:!1}),new Bt({programId:this.programId,keys:s,data:r})}static deactivateLookupTable(t){const e=Xe.DeactivateLookupTable,r=wt(e),s=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return new Bt({programId:this.programId,keys:s,data:r})}static closeLookupTable(t){const e=Xe.CloseLookupTable,r=wt(e),s=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1},{pubkey:t.recipient,isSigner:!1,isWritable:!0}];return new Bt({programId:this.programId,keys:s,data:r})}}Ma.programId=new tt("AddressLookupTab1e1111111111111111111111111");class jh{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=P.u8("instruction").decode(t.data);let s;for(const[i,o]of Object.entries(qe))if(o.index==r){s=i;break}if(!s)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return s}static decodeRequestUnits(t){this.checkProgramId(t.programId);const{units:e,additionalFee:r}=St(qe.RequestUnits,t.data);return{units:e,additionalFee:r}}static decodeRequestHeapFrame(t){this.checkProgramId(t.programId);const{bytes:e}=St(qe.RequestHeapFrame,t.data);return{bytes:e}}static decodeSetComputeUnitLimit(t){this.checkProgramId(t.programId);const{units:e}=St(qe.SetComputeUnitLimit,t.data);return{units:e}}static decodeSetComputeUnitPrice(t){this.checkProgramId(t.programId);const{microLamports:e}=St(qe.SetComputeUnitPrice,t.data);return{microLamports:e}}static checkProgramId(t){if(!t.equals(Ta.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const qe=Object.freeze({RequestUnits:{index:0,layout:P.struct([P.u8("instruction"),P.u32("units"),P.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:P.struct([P.u8("instruction"),P.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:P.struct([P.u8("instruction"),P.u32("units")])},SetComputeUnitPrice:{index:3,layout:P.struct([P.u8("instruction"),xr("microLamports")])}});class Ta{constructor(){}static requestUnits(t){const e=qe.RequestUnits,r=wt(e,t);return new Bt({keys:[],programId:this.programId,data:r})}static requestHeapFrame(t){const e=qe.RequestHeapFrame,r=wt(e,t);return new Bt({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(t){const e=qe.SetComputeUnitLimit,r=wt(e,t);return new Bt({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(t){const e=qe.SetComputeUnitPrice,r=wt(e,{microLamports:BigInt(t.microLamports)});return new Bt({keys:[],programId:this.programId,data:r})}}Ta.programId=new tt("ComputeBudget111111111111111111111111111111");const io=64,so=32,oo=64,ao=P.struct([P.u8("numSignatures"),P.u8("padding"),P.u16("signatureOffset"),P.u16("signatureInstructionIndex"),P.u16("publicKeyOffset"),P.u16("publicKeyInstructionIndex"),P.u16("messageDataOffset"),P.u16("messageDataSize"),P.u16("messageInstructionIndex")]);class Qi{constructor(){}static createInstructionWithPublicKey(t){const{publicKey:e,message:r,signature:s,instructionIndex:i}=t;bt(e.length===so,`Public Key must be ${so} bytes but received ${e.length} bytes`),bt(s.length===oo,`Signature must be ${oo} bytes but received ${s.length} bytes`);const o=ao.span,u=o+e.length,d=u+s.length,b=1,I=ft.Buffer.alloc(d+r.length),B=i??65535;return ao.encode({numSignatures:b,padding:0,signatureOffset:u,signatureInstructionIndex:B,publicKeyOffset:o,publicKeyInstructionIndex:B,messageDataOffset:d,messageDataSize:r.length,messageInstructionIndex:B},I),I.fill(e,o),I.fill(s,u),I.fill(r,d),new Bt({keys:[],programId:Qi.programId,data:I})}static createInstructionWithPrivateKey(t){const{privateKey:e,message:r,instructionIndex:s}=t;bt(e.length===io,`Private key must be ${io} bytes but received ${e.length} bytes`);try{const i=Pr.fromSecretKey(e),o=i.publicKey.toBytes(),u=ji(r,i.secretKey);return this.createInstructionWithPublicKey({publicKey:o,message:r,signature:u,instructionIndex:s})}catch(i){throw new Error(`Error creating instruction; ${i}`)}}}Qi.programId=new tt("Ed25519SigVerify111111111111111111111111111");const wh=(n,t)=>{const e=Hi.sign(n,t);return[e.toCompactRawBytes(),e.recovery]};Hi.utils.isValidPrivateKey;const bh=Hi.getPublicKey,co=32,Si=20,uo=64,kh=11,xi=P.struct([P.u8("numSignatures"),P.u16("signatureOffset"),P.u8("signatureInstructionIndex"),P.u16("ethAddressOffset"),P.u8("ethAddressInstructionIndex"),P.u16("messageDataOffset"),P.u16("messageDataSize"),P.u8("messageInstructionIndex"),P.blob(20,"ethAddress"),P.blob(64,"signature"),P.u8("recoveryId")]);class Lr{constructor(){}static publicKeyToEthAddress(t){bt(t.length===uo,`Public key must be ${uo} bytes but received ${t.length} bytes`);try{return ft.Buffer.from(Ds(yt(t))).slice(-Si)}catch(e){throw new Error(`Error constructing Ethereum address: ${e}`)}}static createInstructionWithPublicKey(t){const{publicKey:e,message:r,signature:s,recoveryId:i,instructionIndex:o}=t;return Lr.createInstructionWithEthAddress({ethAddress:Lr.publicKeyToEthAddress(e),message:r,signature:s,recoveryId:i,instructionIndex:o})}static createInstructionWithEthAddress(t){const{ethAddress:e,message:r,signature:s,recoveryId:i,instructionIndex:o=0}=t;let u;typeof e=="string"?e.startsWith("0x")?u=ft.Buffer.from(e.substr(2),"hex"):u=ft.Buffer.from(e,"hex"):u=e,bt(u.length===Si,`Address must be ${Si} bytes but received ${u.length} bytes`);const d=1+kh,b=d,I=d+u.length,B=I+s.length+1,A=1,S=ft.Buffer.alloc(xi.span+r.length);return xi.encode({numSignatures:A,signatureOffset:I,signatureInstructionIndex:o,ethAddressOffset:b,ethAddressInstructionIndex:o,messageDataOffset:B,messageDataSize:r.length,messageInstructionIndex:o,signature:yt(s),ethAddress:yt(u),recoveryId:i},S),S.fill(yt(r),xi.span),new Bt({keys:[],programId:Lr.programId,data:S})}static createInstructionWithPrivateKey(t){const{privateKey:e,message:r,instructionIndex:s}=t;bt(e.length===co,`Private key must be ${co} bytes but received ${e.length} bytes`);try{const i=yt(e),o=bh(i,!1).slice(1),u=ft.Buffer.from(Ds(yt(r))),[d,b]=wh(u,i);return this.createInstructionWithPublicKey({publicKey:o,message:r,signature:d,recoveryId:b,instructionIndex:s})}catch(i){throw new Error(`Error creating instruction; ${i}`)}}}Lr.programId=new tt("KeccakSecp256k11111111111111111111111111111");var Pa;const vh=new tt("StakeConfig11111111111111111111111111111111");class Sh{constructor(t,e){this.staker=void 0,this.withdrawer=void 0,this.staker=t,this.withdrawer=e}}class Bn{constructor(t,e,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=t,this.epoch=e,this.custodian=r}}Pa=Bn;Bn.default=new Pa(0,0,tt.default);class Gh{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=P.u32("instruction").decode(t.data);let s;for(const[i,o]of Object.entries(fe))if(o.index==r){s=i;break}if(!s)throw new Error("Instruction type incorrect; not a StakeInstruction");return s}static decodeInitialize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{authorized:e,lockup:r}=St(fe.Initialize,t.data);return{stakePubkey:t.keys[0].pubkey,authorized:new Sh(new tt(e.staker),new tt(e.withdrawer)),lockup:new Bn(r.unixTimestamp,r.epoch,new tt(r.custodian))}}static decodeDelegate(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,6),St(fe.Delegate,t.data),{stakePubkey:t.keys[0].pubkey,votePubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[5].pubkey}}static decodeAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{newAuthorized:e,stakeAuthorizationType:r}=St(fe.Authorize,t.data),s={stakePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey,newAuthorizedPubkey:new tt(e),stakeAuthorizationType:{index:r}};return t.keys.length>3&&(s.custodianPubkey=t.keys[3].pubkey),s}static decodeAuthorizeWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{newAuthorized:e,stakeAuthorizationType:r,authoritySeed:s,authorityOwner:i}=St(fe.AuthorizeWithSeed,t.data),o={stakePubkey:t.keys[0].pubkey,authorityBase:t.keys[1].pubkey,authoritySeed:s,authorityOwner:new tt(i),newAuthorizedPubkey:new tt(e),stakeAuthorizationType:{index:r}};return t.keys.length>3&&(o.custodianPubkey=t.keys[3].pubkey),o}static decodeSplit(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e}=St(fe.Split,t.data);return{stakePubkey:t.keys[0].pubkey,splitStakePubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[2].pubkey,lamports:e}}static decodeMerge(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),St(fe.Merge,t.data),{stakePubkey:t.keys[0].pubkey,sourceStakePubKey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey}}static decodeWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,5);const{lamports:e}=St(fe.Withdraw,t.data),r={stakePubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey,lamports:e};return t.keys.length>5&&(r.custodianPubkey=t.keys[5].pubkey),r}static decodeDeactivate(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),St(fe.Deactivate,t.data),{stakePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey}}static checkProgramId(t){if(!t.equals(ts.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const fe=Object.freeze({Initialize:{index:0,layout:P.struct([P.u32("instruction"),Cf(),Uf()])},Authorize:{index:1,layout:P.struct([P.u32("instruction"),mt("newAuthorized"),P.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:P.struct([P.u32("instruction")])},Split:{index:3,layout:P.struct([P.u32("instruction"),P.ns64("lamports")])},Withdraw:{index:4,layout:P.struct([P.u32("instruction"),P.ns64("lamports")])},Deactivate:{index:5,layout:P.struct([P.u32("instruction")])},Merge:{index:7,layout:P.struct([P.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:P.struct([P.u32("instruction"),mt("newAuthorized"),P.u32("stakeAuthorizationType"),ir("authoritySeed"),mt("authorityOwner")])}}),Zh=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class ts{constructor(){}static initialize(t){const{stakePubkey:e,authorized:r,lockup:s}=t,i=s||Bn.default,o=fe.Initialize,u=wt(o,{authorized:{staker:yt(r.staker.toBuffer()),withdrawer:yt(r.withdrawer.toBuffer())},lockup:{unixTimestamp:i.unixTimestamp,epoch:i.epoch,custodian:yt(i.custodian.toBuffer())}}),d={keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:Or,isSigner:!1,isWritable:!1}],programId:this.programId,data:u};return new Bt(d)}static createAccountWithSeed(t){const e=new xt;e.add(he.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.stakePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:s,lockup:i}=t;return e.add(this.initialize({stakePubkey:r,authorized:s,lockup:i}))}static createAccount(t){const e=new xt;e.add(he.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.stakePubkey,lamports:t.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:s,lockup:i}=t;return e.add(this.initialize({stakePubkey:r,authorized:s,lockup:i}))}static delegate(t){const{stakePubkey:e,authorizedPubkey:r,votePubkey:s}=t,i=fe.Delegate,o=wt(i);return new xt().add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:vh,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static authorize(t){const{stakePubkey:e,authorizedPubkey:r,newAuthorizedPubkey:s,stakeAuthorizationType:i,custodianPubkey:o}=t,u=fe.Authorize,d=wt(u,{newAuthorized:yt(s.toBuffer()),stakeAuthorizationType:i.index}),b=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:ze,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return o&&b.push({pubkey:o,isSigner:!0,isWritable:!1}),new xt().add({keys:b,programId:this.programId,data:d})}static authorizeWithSeed(t){const{stakePubkey:e,authorityBase:r,authoritySeed:s,authorityOwner:i,newAuthorizedPubkey:o,stakeAuthorizationType:u,custodianPubkey:d}=t,b=fe.AuthorizeWithSeed,I=wt(b,{newAuthorized:yt(o.toBuffer()),stakeAuthorizationType:u.index,authoritySeed:s,authorityOwner:yt(i.toBuffer())}),B=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1}];return d&&B.push({pubkey:d,isSigner:!0,isWritable:!1}),new xt().add({keys:B,programId:this.programId,data:I})}static splitInstruction(t){const{stakePubkey:e,authorizedPubkey:r,splitStakePubkey:s,lamports:i}=t,o=fe.Split,u=wt(o,{lamports:i});return new Bt({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:u})}static split(t,e){const r=new xt;return r.add(he.createAccount({fromPubkey:t.authorizedPubkey,newAccountPubkey:t.splitStakePubkey,lamports:e,space:this.space,programId:this.programId})),r.add(this.splitInstruction(t))}static splitWithSeed(t,e){const{stakePubkey:r,authorizedPubkey:s,splitStakePubkey:i,basePubkey:o,seed:u,lamports:d}=t,b=new xt;return b.add(he.allocate({accountPubkey:i,basePubkey:o,seed:u,space:this.space,programId:this.programId})),e&&e>0&&b.add(he.transfer({fromPubkey:t.authorizedPubkey,toPubkey:i,lamports:e})),b.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:s,splitStakePubkey:i,lamports:d}))}static merge(t){const{stakePubkey:e,sourceStakePubKey:r,authorizedPubkey:s}=t,i=fe.Merge,o=wt(i);return new xt().add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static withdraw(t){const{stakePubkey:e,authorizedPubkey:r,toPubkey:s,lamports:i,custodianPubkey:o}=t,u=fe.Withdraw,d=wt(u,{lamports:i}),b=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:mi,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return o&&b.push({pubkey:o,isSigner:!0,isWritable:!1}),new xt().add({keys:b,programId:this.programId,data:d})}static deactivate(t){const{stakePubkey:e,authorizedPubkey:r}=t,s=fe.Deactivate,i=wt(s);return new xt().add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}}ts.programId=new tt("Stake11111111111111111111111111111111111111");ts.space=200;class xh{constructor(t,e,r,s){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=t,this.authorizedVoter=e,this.authorizedWithdrawer=r,this.commission=s}}class Yh{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=P.u32("instruction").decode(t.data);let s;for(const[i,o]of Object.entries(Pe))if(o.index==r){s=i;break}if(!s)throw new Error("Instruction type incorrect; not a VoteInstruction");return s}static decodeInitializeAccount(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,4);const{voteInit:e}=St(Pe.InitializeAccount,t.data);return{votePubkey:t.keys[0].pubkey,nodePubkey:t.keys[3].pubkey,voteInit:new xh(new tt(e.nodePubkey),new tt(e.authorizedVoter),new tt(e.authorizedWithdrawer),e.commission)}}static decodeAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{newAuthorized:e,voteAuthorizationType:r}=St(Pe.Authorize,t.data);return{votePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey,newAuthorizedPubkey:new tt(e),voteAuthorizationType:{index:r}}}static decodeAuthorizeWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:e,currentAuthorityDerivedKeySeed:r,newAuthorized:s,voteAuthorizationType:i}}=St(Pe.AuthorizeWithSeed,t.data);return{currentAuthorityDerivedKeyBasePubkey:t.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new tt(e),currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:new tt(s),voteAuthorizationType:{index:i},votePubkey:t.keys[0].pubkey}}static decodeWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e}=St(Pe.Withdraw,t.data);return{votePubkey:t.keys[0].pubkey,authorizedWithdrawerPubkey:t.keys[2].pubkey,lamports:e,toPubkey:t.keys[1].pubkey}}static checkProgramId(t){if(!t.equals($r.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const Pe=Object.freeze({InitializeAccount:{index:0,layout:P.struct([P.u32("instruction"),Of()])},Authorize:{index:1,layout:P.struct([P.u32("instruction"),mt("newAuthorized"),P.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:P.struct([P.u32("instruction"),P.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:P.struct([P.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:P.struct([P.u32("instruction"),Nf()])}}),Xh=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class $r{constructor(){}static initializeAccount(t){const{votePubkey:e,nodePubkey:r,voteInit:s}=t,i=Pe.InitializeAccount,o=wt(i,{voteInit:{nodePubkey:yt(s.nodePubkey.toBuffer()),authorizedVoter:yt(s.authorizedVoter.toBuffer()),authorizedWithdrawer:yt(s.authorizedWithdrawer.toBuffer()),commission:s.commission}}),u={keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:Or,isSigner:!1,isWritable:!1},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o};return new Bt(u)}static createAccount(t){const e=new xt;return e.add(he.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.votePubkey,lamports:t.lamports,space:this.space,programId:this.programId})),e.add(this.initializeAccount({votePubkey:t.votePubkey,nodePubkey:t.voteInit.nodePubkey,voteInit:t.voteInit}))}static authorize(t){const{votePubkey:e,authorizedPubkey:r,newAuthorizedPubkey:s,voteAuthorizationType:i}=t,o=Pe.Authorize,u=wt(o,{newAuthorized:yt(s.toBuffer()),voteAuthorizationType:i.index}),d=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new xt().add({keys:d,programId:this.programId,data:u})}static authorizeWithSeed(t){const{currentAuthorityDerivedKeyBasePubkey:e,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:s,newAuthorizedPubkey:i,voteAuthorizationType:o,votePubkey:u}=t,d=Pe.AuthorizeWithSeed,b=wt(d,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:yt(r.toBuffer()),currentAuthorityDerivedKeySeed:s,newAuthorized:yt(i.toBuffer()),voteAuthorizationType:o.index}}),I=[{pubkey:u,isSigner:!1,isWritable:!0},{pubkey:ze,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1}];return new xt().add({keys:I,programId:this.programId,data:b})}static withdraw(t){const{votePubkey:e,authorizedWithdrawerPubkey:r,lamports:s,toPubkey:i}=t,o=Pe.Withdraw,u=wt(o,{lamports:s}),d=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return new xt().add({keys:d,programId:this.programId,data:u})}static safeWithdraw(t,e,r){if(t.lamports>e-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return $r.withdraw(t)}static updateValidatorIdentity(t){const{votePubkey:e,authorizedWithdrawerPubkey:r,nodePubkey:s}=t,i=Pe.UpdateValidatorIdentity,o=wt(i),u=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new xt().add({keys:u,programId:this.programId,data:o})}}$r.programId=new tt("Vote111111111111111111111111111111111111111");$r.space=3762;const Eh=new tt("Va1idator1nfo111111111111111111111111111111"),Ih=Z({name:J(),website:ut(J()),details:ut(J()),iconUrl:ut(J()),keybaseUsername:ut(J())});class La{constructor(t,e){this.key=void 0,this.info=void 0,this.key=t,this.info=e}static fromConfigData(t){let e=[...t];if(ke(e)!==2)return null;const s=[];for(let i=0;i<2;i++){const o=new tt(ve(e,0,We)),u=Te(e)===1;s.push({publicKey:o,isSigner:u})}if(s[0].publicKey.equals(Eh)&&s[1].isSigner){const i=ir().decode(ft.Buffer.from(e)),o=JSON.parse(i);return Vo(o,Ih),new La(s[1].publicKey,o)}return null}}const Jh=new tt("Vote111111111111111111111111111111111111111"),_h=P.struct([mt("nodePubkey"),mt("authorizedWithdrawer"),P.u8("commission"),P.nu64(),P.seq(P.struct([P.nu64("slot"),P.u32("confirmationCount")]),P.offset(P.u32(),-8),"votes"),P.u8("rootSlotValid"),P.nu64("rootSlot"),P.nu64(),P.seq(P.struct([P.nu64("epoch"),mt("authorizedVoter")]),P.offset(P.u32(),-8),"authorizedVoters"),P.struct([P.seq(P.struct([mt("authorizedPubkey"),P.nu64("epochOfLastAuthorizedSwitch"),P.nu64("targetEpoch")]),32,"buf"),P.nu64("idx"),P.u8("isEmpty")],"priorVoters"),P.nu64(),P.seq(P.struct([P.nu64("epoch"),P.nu64("credits"),P.nu64("prevCredits")]),P.offset(P.u32(),-8),"epochCredits"),P.struct([P.nu64("slot"),P.nu64("timestamp")],"lastTimestamp")]);class Ca{constructor(t){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=t.nodePubkey,this.authorizedWithdrawer=t.authorizedWithdrawer,this.commission=t.commission,this.rootSlot=t.rootSlot,this.votes=t.votes,this.authorizedVoters=t.authorizedVoters,this.priorVoters=t.priorVoters,this.epochCredits=t.epochCredits,this.lastTimestamp=t.lastTimestamp}static fromAccountData(t){const r=_h.decode(yt(t),4);let s=r.rootSlot;return r.rootSlotValid||(s=null),new Ca({nodePubkey:new tt(r.nodePubkey),authorizedWithdrawer:new tt(r.authorizedWithdrawer),commission:r.commission,votes:r.votes,rootSlot:s,authorizedVoters:r.authorizedVoters.map(Ah),priorVoters:Bh(r.priorVoters),epochCredits:r.epochCredits,lastTimestamp:r.lastTimestamp})}}function Ah({authorizedVoter:n,epoch:t}){return{epoch:t,authorizedVoter:new tt(n)}}function fo({authorizedPubkey:n,epochOfLastAuthorizedSwitch:t,targetEpoch:e}){return{authorizedPubkey:new tt(n),epochOfLastAuthorizedSwitch:t,targetEpoch:e}}function Bh({buf:n,idx:t,isEmpty:e}){return e?[]:[...n.slice(t+1).map(fo),...n.slice(0,t).map(fo)]}const lo={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function Qh(n,t){const e=t===!1?"http":"https";if(!n)return lo[e].devnet;const r=lo[e][n];if(!r)throw new Error(`Unknown ${e} cluster: ${n}`);return r}async function td(n,t,e,r){let s,i;e&&Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")||e&&Object.prototype.hasOwnProperty.call(e,"nonceValue")?(s=e,i=r):i=e;const o=i&&{skipPreflight:i.skipPreflight,preflightCommitment:i.preflightCommitment||i.commitment,minContextSlot:i.minContextSlot},u=await n.sendRawTransaction(t,o),d=i&&i.commitment,I=(await(s?n.confirmTransaction(s,d):n.confirmTransaction(u,d))).value;if(I.err)throw u!=null?new yn({action:o?.skipPreflight?"send":"simulate",signature:u,transactionMessage:`Status: (${JSON.stringify(I)})`}):new Error(`Raw transaction ${u} failed (${JSON.stringify(I)})`);return u}const ed=1e9;export{Ch as Account,Qs as AddressLookupTableAccount,Hh as AddressLookupTableInstruction,Ma as AddressLookupTableProgram,Sh as Authorized,el as BLOCKHASH_CACHE_TIMEOUT_MS,Uh as BPF_LOADER_DEPRECATED_PROGRAM_ID,Wh as BPF_LOADER_PROGRAM_ID,$h as BpfLoader,qe as COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,jh as ComputeBudgetInstruction,Ta as ComputeBudgetProgram,Vh as Connection,Qi as Ed25519Program,Lh as Enum,Gf as EpochSchedule,Df as FeeCalculatorLayout,Pr as Keypair,ed as LAMPORTS_PER_SOL,Xe as LOOKUP_TABLE_INSTRUCTION_LAYOUTS,Er as Loader,Bn as Lockup,Tf as MAX_SEED_LENGTH,Ce as Message,gn as MessageAccountKeys,Sr as MessageV0,Zs as NONCE_ACCOUNT_LENGTH,Zi as NonceAccount,or as PACKET_DATA_SIZE,We as PUBLIC_KEY_LENGTH,tt as PublicKey,pn as SIGNATURE_LENGTH_IN_BYTES,nn as SOLANA_SCHEMA,vh as STAKE_CONFIG_ID,fe as STAKE_INSTRUCTION_LAYOUTS,Tt as SYSTEM_INSTRUCTION_LAYOUTS,ze as SYSVAR_CLOCK_PUBKEY,Oh as SYSVAR_EPOCH_SCHEDULE_PUBKEY,Nh as SYSVAR_INSTRUCTIONS_PUBKEY,yi as SYSVAR_RECENT_BLOCKHASHES_PUBKEY,Or as SYSVAR_RENT_PUBKEY,Fh as SYSVAR_REWARDS_PUBKEY,zh as SYSVAR_SLOT_HASHES_PUBKEY,Kh as SYSVAR_SLOT_HISTORY_PUBKEY,mi as SYSVAR_STAKE_HISTORY_PUBKEY,Lr as Secp256k1Program,yn as SendTransactionError,at as SolanaJSONRPCError,qh as SolanaJSONRPCErrorCode,Zh as StakeAuthorizationLayout,Gh as StakeInstruction,ts as StakeProgram,ua as Struct,Dh as SystemInstruction,he as SystemProgram,xt as Transaction,la as TransactionExpiredBlockheightExceededError,Tr as TransactionExpiredNonceInvalidError,ha as TransactionExpiredTimeoutError,Bt as TransactionInstruction,ya as TransactionMessage,Ye as TransactionStatus,Eh as VALIDATOR_INFO_KEY,Gi as VERSION_PREFIX_MASK,Jh as VOTE_PROGRAM_ID,La as ValidatorInfo,ga as VersionedMessage,ma as VersionedTransaction,Ca as VoteAccount,Xh as VoteAuthorizationLayout,xh as VoteInit,Yh as VoteInstruction,$r as VoteProgram,Qh as clusterApiUrl,td as sendAndConfirmRawTransaction,Gs as sendAndConfirmTransaction};
